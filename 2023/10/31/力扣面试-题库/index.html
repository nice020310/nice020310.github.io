<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>避风港 | 避风港</title><meta name="author" content="Love"><meta name="copyright" content="Love"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="title: 力扣面试+题库.md date: 2023-10-31 23:25:04tags: 算法categories: 面试 力扣面试+数据结构作业题库1.合并有序数组两种思路，第一个交换  void merge(vector<int>&amp; nums1, int m, vector<int>&amp; nums2, int n) &amp;#123;    int i">
<meta property="og:type" content="article">
<meta property="og:title" content="避风港">
<meta property="og:url" content="http://example.com/2023/10/31/%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95-%E9%A2%98%E5%BA%93/index.html">
<meta property="og:site_name" content="避风港">
<meta property="og:description" content="title: 力扣面试+题库.md date: 2023-10-31 23:25:04tags: 算法categories: 面试 力扣面试+数据结构作业题库1.合并有序数组两种思路，第一个交换  void merge(vector<int>&amp; nums1, int m, vector<int>&amp; nums2, int n) &amp;#123;    int i">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/gou.png">
<meta property="article:published_time" content="2023-10-31T15:25:04.633Z">
<meta property="article:modified_time" content="2024-01-14T06:19:54.658Z">
<meta property="article:author" content="Love">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/gou.png"><link rel="shortcut icon" href="/img/meigui.png"><link rel="canonical" href="http://example.com/2023/10/31/%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95-%E9%A2%98%E5%BA%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '避风港',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-14 14:19:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/gou.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/luori.png')"><nav id="nav"><span id="blog-info"><a href="/" title="避风港"><span class="site-name">避风港</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-31T15:25:04.633Z" title="发表于 2023-10-31 23:25:04">2023-10-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-14T06:19:54.658Z" title="更新于 2024-01-14 14:19:54">2024-01-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('/img/luori.png');"></div><article class="post-content" id="article-container"><p>title: 力扣面试+题库.md</p>
<p>date: 2023-10-31 23:25:04<br>tags: 算法<br>categories: 面试</p>
<h1 id="力扣面试-数据结构作业题库"><a href="#力扣面试-数据结构作业题库" class="headerlink" title="力扣面试+数据结构作业题库"></a>力扣面试+数据结构作业题库</h1><h2 id="1-合并有序数组"><a href="#1-合并有序数组" class="headerlink" title="1.合并有序数组"></a>1.合并有序数组</h2><p>两种思路，第一个交换</p>
<p><img src="https://pic.leetcode-cn.com/29ab5c730deb7ffec1d7854bbfdc1552a6829a6ac5da4e64e591150f08757e68-%E5%9B%BE%E7%89%87.png" alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {</span><br><span class="line">    int i = nums1.size() - 1;</span><br><span class="line">    m--;</span><br><span class="line">    n--;</span><br><span class="line">    while (n &gt;= 0) {</span><br><span class="line">        while (m &gt;= 0 &amp;&amp; nums1[m] &gt; nums2[n]) {</span><br><span class="line">            swap(nums1[i--], nums1[m--]);</span><br><span class="line">        }</span><br><span class="line">        swap(nums1[i--], nums2[n--]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>第二种，直接覆盖，在排列</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i) {</span><br><span class="line">            nums1[m + i] = nums2[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>方法三：双指针<br>算法</p>
<p>  已经被排序的性质。为了利用这一性质，我们可以使用双指针方法。这一方法将两个数组看作队列，每次从两个数组头部取出比较小的数字放到结果中。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sorted[m + n];</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n) {</span><br><span class="line">            <span class="keyword">if</span> (p1 == m) {</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (p2 == n) {</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) {</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            }</span><br><span class="line">            sorted[p1 + p2 - <span class="number">1</span>] = cur;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != m + n; ++i) {</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-移除元素"><a href="#2-移除元素" class="headerlink" title="2.移除元素"></a>2.移除元素</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">     {</span><br><span class="line">         <span class="keyword">if</span>(nums[i]==val)</span><br><span class="line">         {</span><br><span class="line">             nums[i]=<span class="number">0</span>;</span><br><span class="line">             j++;</span><br><span class="line">         }</span><br><span class="line">         </span><br><span class="line">     }</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>()-j;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>由于题目要求删除数组中等于 val的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置。</p>
<p>如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</p>
<p>如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位。</p>
<p>整个过程保持不变的性质是：区间 [0,left) 中的元素都不等于 val。当左右指针遍历完输入数组以后，left 的值就是输出数组的长度。</p>
<p>这样的算法在最坏情况下（输入数组中没有元素等于 val），左右指针各遍历了数组一次。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; right++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != val) {</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>时间复杂度O（n)z至多遍历2次</p>
<p>空间复杂度O(1)</p>
<h3 id="双指针优化"><a href="#双指针优化" class="headerlink" title="双指针优化"></a>双指针优化</h3><p>如果要移除的元素恰好在数组的开头，例如序列 [1,2,3,4,5][1,2,3,4,5][1,2,3,4,5]，当 val为 111 时，我们需要把每一个元素都左移一位。注意到题目中说：「元素的顺序可以改变」。实际上我们可以直接将最后一个元素 555 移动到序列开头，取代元素 111，得到序列 [5,2,3,4][5,2,3,4][5,2,3,4]，同样满足题目要求。这个优化在序列中 val 元素的数量较少时非常有效。</p>
<p>实现方面，我们依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。</p>
<p>算法</p>
<p>如果左指针 left指向的元素等于 val，此时将右指针 right 指向的元素复制到左指针 left 的位置，然后右指针 right 左移一位。如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 val 为止。</p>
<p>当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素。</p>
<p>这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>;<span class="type">int</span> right=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(nums[left]==val)</span><br><span class="line">            {</span><br><span class="line">                nums[left]=nums[right<span class="number">-1</span>];</span><br><span class="line">                right--;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                left++;</span><br><span class="line">                 }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-删除有序数组中的重复项"><a href="#3-删除有序数组中的重复项" class="headerlink" title="3.删除有序数组中的重复项"></a>3.删除有序数组中的重复项</h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p>
<p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p>
<ul>
<li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li>
<li>返回 <code>k</code> 。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">      <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=nums[i<span class="number">-1</span>])</span><br><span class="line">            {</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">         </span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1.双指针"></a>1.双指针</h3><p>i为慢指针，指向答案位置</p>
<p>j为快指针，用来扫描</p>
<p>当nums[j]!=nums[i],找到不重复项，复制到答案位置，i指针前进一步</p>
<h2 id="4-删除有序数组中的重复项二"><a href="#4-删除有序数组中的重复项二" class="headerlink" title="4.删除有序数组中的重复项二"></a>4.删除有序数组中的重复项二</h2><p>简单修改3就可</p>
<h2 id="5-多数元素"><a href="#5-多数元素" class="headerlink" title="5.多数元素"></a>5.多数元素</h2><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">         </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>最简单的暴力方法是，枚举数组中的每个元素，再遍历一遍数组统计其出现次数。该方法的时间复杂度是 O(n2)O(n^2)O(n<br>2<br> )，会超出时间限制，因此我们需要找出时间复杂度小于 O(n2)O(n^2)O(n<br>2<br> ) 的优秀做法。</p>
<h4 id="1-方法一：哈希表"><a href="#1-方法一：哈希表" class="headerlink" title="1.方法一：哈希表"></a>1.方法一：哈希表</h4><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%A3%E5%88%97%E8%A1%A8&amp;spm=1001.2101.3001.7020">散列表</a>（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p>
<ul>
<li><p>哈希表也叫散列表</p>
</li>
<li><p>哈希表是一个数据结构</p>
</li>
<li><p>散列表是数组结构</p>
</li>
<li><pre><code class="c++">class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int,int&gt;counts;
        int majority =0,cnt =0;
        for(int num:nums)
        {
            ++counts[num];
        
       if(counts[num]&gt;cnt)
       {
           majority =num;
           cnt =counts[num];
       }

        }

return majority;
    }
};

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">  首先创建一个哈希表counts，然后遍历数组nums</span><br><span class="line"></span><br><span class="line">  ![1695388913246](C:\Users\Nice\AppData\Roaming\Typora\typora-user-images\1695388913246.png)</span><br><span class="line"></span><br><span class="line">  用for的另外用法，对应的数的数组加一，进行打擂台形式选择最大项</span><br><span class="line"></span><br><span class="line">#### 2.摩根投票</span><br><span class="line"></span><br><span class="line">核心理念为 **票数正负抵消** 。此方法时间和空间复杂度分别为 O(N)和 O(1)，为本题的最佳解法。</span><br><span class="line"></span><br><span class="line">设输入数组 nums 的众数为 x ，数组长度为 n 。</span><br><span class="line"></span><br><span class="line">推论一： 若记 众数 的票数为 +1，非众数 的票数为 −1，则一定有所有数字的 票数和 &gt;0 。</span><br><span class="line"></span><br><span class="line">推论二： 若数组的前 a个数字的 票数和 =0，则 数组剩余 (n−a)个数字的 票数和一定仍 &gt;0，即后 (n−a) 个数字的 众数仍为 x 。</span><br><span class="line"></span><br><span class="line">。</span><br><span class="line"></span><br><span class="line">![Picture1.png](https://pic.leetcode-cn.com/1603612327-bOQxzq-Picture1.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 6.轮转数组</span><br><span class="line"></span><br><span class="line">给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 1.方法一</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) {</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;int&gt; newArr(n);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) {</span><br><span class="line">            newArr[(i + k) % n] = nums[i];</span><br><span class="line">        }</span><br><span class="line">        nums.assign(newArr.begin(), newArr.end());</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
</ul>
<p>我们可以使用额外的数组来将每个元素放至正确的位置。用 n 表示数组的长度，我们遍历原数组，将原数组下标为 i 的元素放至新数组下标为 (i+k)mod n 的位置，最后将新数组拷贝至原数组即可。</p>
<ul>
<li>时间复杂度： O(n)，其中 n 为数组的长度。</li>
<li>空间复杂度： O(n</li>
</ul>
<p>(i+k)%n  轮转相当于对k进行模</p>
<h4 id="2-方法二：环状替换"><a href="#2-方法二：环状替换" class="headerlink" title="2.方法二：环状替换"></a>2.方法二：环状替换</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="type">int</span> count = <span class="built_in">gcd</span>(k, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; count; ++start) {</span><br><span class="line">            <span class="type">int</span> current = start;</span><br><span class="line">            <span class="type">int</span> prev = nums[start];</span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line">                <span class="type">int</span> next = (current + k) % n;</span><br><span class="line">                <span class="built_in">swap</span>(nums[next], prev);</span><br><span class="line">                current = next;</span><br><span class="line">            } <span class="keyword">while</span> (start != current);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>方法一中使用额外数组的原因在于如果我们直接将每个数字放至它最后的位置，这样被放置位置的元素会被覆盖从而丢失。因此，从另一个角度，我们可以将被替换的元素保存在变量 temp中，从而避免了额外数组的开销。</p>
<p>我们从位置0开始，最初令temp = nums [0] 。根据规则，位置0的元素会放至(0＋ k) mod n的位置，令x=(0＋k) mod n，此时交换temp和nums[x]，完成位置x的更新。然后，我们考察位置x，并交换temp和nums[(a ＋k) mod n]，从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置0。</p>
<p>容易发现，当回到初始位置 0 时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？我们不妨先考虑这样一个问题：从 0开始不断遍历，最终回到起点 0 的过程中，我们遍历了多少个元素？</p>
<p>由于最终回到了起点，故该过程恰好走了整数数量的圈，不妨设为 a 圈；再设该过程总共遍历了 b 个元素。因此，我们有 an=bk即 an 一定为 n,k 的公倍数。又因为我们在第一次回到起点时就结束，因此 a要尽可能小，故 an 就是 n,k的最小公倍数 lcm(n,k)，因此 b 就为 lcm(n,k)/k</p>
<p>这说明单次遍历会访问到 lcm(n,k)/k 个元素。为了访问到所有的元素，我们需要进行遍历的次数为</p>
<p><img src="/.com//test-blog\source_posts\力扣面试题\1.png" alt="1"></p>
<p>其中 gcd 指的是最大公约数。</p>
<p>我们用下面的例子更具体地说明这个过程：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">nums = [1, 2, 3, 4, 5, 6]</span><br><span class="line">k = 2</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://pic.leetcode-cn.com/f0493a97cdb7bc46b37306ca14e555451496f9f9c21effcad8517a81a26f30d6-image.png" alt="image.png"></p>
<p>时间复杂度：O(n)，其中 n 为数组的长度。每个元素只会被遍历一次。</p>
<p>空间复杂度：O(1))。我们只需常数空间存放若干变量</p>
<h4 id="3-方法三：数组翻转"><a href="#3-方法三：数组翻转" class="headerlink" title="3.方法三：数组翻转"></a>3.方法三：数组翻转</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) {</span><br><span class="line">            <span class="built_in">swap</span>(nums[start], nums[end]);</span><br><span class="line">            start += <span class="number">1</span>;</span><br><span class="line">            end -= <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, k, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>该方法基于如下的事实：当我们将数组的元素向右移动 k 次后，尾部 k mod n 个元素会移动至数组头部，其余元素向后移动 k mod n 个位置。</p>
<p>该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的 k mod n个元素就被移至数组头部，然后我们再翻转[0,k mod n-1] 区间的元素和 [k mod n,n−1] 区间的元素即能得到最后的答案。</p>
<p>我们以 n=7，k=3为例进行如下展示：</p>
<p><img src="/.com//test-blog\source_posts\力扣面试题\2.png" alt="2"></p>
<h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<h3 id="1-暴力法（遍历n-n-1-x2F-2找最大值）"><a href="#1-暴力法（遍历n-n-1-x2F-2找最大值）" class="headerlink" title="1.暴力法（遍历n*(n-1)/2找最大值）"></a>1.暴力法（遍历n*(n-1)/2找最大值）</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> a =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            {</span><br><span class="line">                a=<span class="built_in">max</span>(a,prices[j]-prices[i]);</span><br><span class="line">                </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>时间复杂度：O(n2)<br> )。循环运行 n(n−1)/2</p>
<p>  次。<br>空间复杂度：O(1)。只使用了常数个变量。</p>
<h3 id="2-一次遍历法"><a href="#2-一次遍历法" class="headerlink" title="2.一次遍历法"></a>2.一次遍历法<img src="/.com//test-blog\source_posts\力扣面试题\3.png" alt="3"></h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">        <span class="type">int</span> minprice = inf, maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price: prices) {</span><br><span class="line">            maxprofit = <span class="built_in">max</span>(maxprofit, price - minprice);</span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。</p>
<p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。</p>
<ul>
<li>时间复杂度：O(n)，只需要遍历一次。</li>
<li>空间复杂度：O(1)，只使用了常数个变量。</li>
<li>差值最大却不在最低点买入的情况，这一定发生在到达股票最低点日子之前，记录 maxprofit 。 之后即使到了最低点，更改了 minprice, 但 maxprofit 却不会改变了。仍然是正确值</li>
</ul>
<h2 id="买卖股票的最佳时机2"><a href="#买卖股票的最佳时机2" class="headerlink" title="买卖股票的最佳时机2"></a>买卖股票的最佳时机2</h2><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>













<h2 id="方法二：简单一次遍历"><a href="#方法二：简单一次遍历" class="headerlink" title="方法二：简单一次遍历"></a>方法二：简单一次遍历</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> profit=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">           {</span><br><span class="line">               <span class="keyword">if</span>(prices[i]&gt;prices[i<span class="number">-1</span>])</span><br><span class="line">               {</span><br><span class="line">                   profit+=prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">return</span> profit;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>







<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="1-迭代法"><a href="#1-迭代法" class="headerlink" title="1.迭代法"></a>1.迭代法</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>* <span class="built_in">ReverseList</span>(<span class="keyword">struct</span> ListNode* pHead ) {</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *curr = pHead;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">NULL</span>) {</span><br><span class="line">        next = curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;    </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>反转链表：<br>head    pre   next<br>1  -&gt;  2  -&gt;  3  -&gt;  4  -&gt;  5<br>head   pre    next<br>1  &lt;-  2      3  -&gt;  4  -&gt;  5<br>head    pre    next<br>1  &lt;-  2  &lt;-  3      4  -&gt;  5<br>head    pre    next<br>1  &lt;-  2  &lt;-  3  &lt;-  4      5<br>head    pre    next<br>1  &lt;-  2  &lt;-  3  &lt;-  4  &lt;-  5</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1. 将 curr 的下一个节点指向 prev：这一步是为了将当前节点 curr 的 next 指针指向它的前一个节点 prev。这样做的目的是为了使链表反转，将当前节点的指针方向改变，指向前一个节点。</span><br><span class="line"></span><br><span class="line">2. 将 prev 移动到 curr：这一步是为了将 prev 指针向右移动一位，使它指向 curr。这样做的目的是为了在下一次循环中，curr 的下一个节点仍然能够访问到它。</span><br><span class="line"></span><br><span class="line">3. 将 curr 移动到 next：这一步是为了将 curr 指针向右移动一位，使它指向 next。这样做的目的是为了在下一次循环中，将 curr 的下一个节点指向它的前一个节点。</span><br><span class="line"></span><br><span class="line">4. 将 next 移动到 curr 的下一个节点：这一步是为了将 next 指针向右移动一位，使它指向 curr 的下一个节点。这样做的目的是为了在下一次循环中，访问到 curr 的下一个节点。</span><br><span class="line"></span><br><span class="line">这些步骤综合起来，实际上就是在不断地将链表的指针方向进行反转，使得链表从原来的顺序变成相反的顺序。最后 prev 就会指向反转后链表的表头。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-递归法"><a href="#2-递归法" class="headerlink" title="2.递归法"></a>2.递归法</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) {</span><br><span class="line">        if (!head || !head-&gt;next) {</span><br><span class="line">            return head;</span><br><span class="line">        }</span><br><span class="line">        ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = nullptr;</span><br><span class="line">        return newHead;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>





<h1 id="for在c-的五种用法和string的用法"><a href="#for在c-的五种用法和string的用法" class="headerlink" title="for在c++的五种用法和string的用法"></a>for在c++的五种用法和string的用法</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int nArray[] = { 0, 1, 2, 3, 4, 5 };</span><br><span class="line">vector&lt;int&gt; vecNum(nArray, nArray + 6);</span><br><span class="line">CString strText;</span><br><span class="line"> </span><br><span class="line">// 第一种用法：最原始的语法(用下标)</span><br><span class="line">for (size_t i = 0; i &lt; vecNum.size(); ++i)</span><br><span class="line">{</span><br><span class="line">    strText.Format("%d", nArray[i]);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// 第二种用法：最原始的语法(用迭代器)</span><br><span class="line">for (auto it = vecNum.begin(); it != vecNum.end(); ++it)</span><br><span class="line">{</span><br><span class="line">    strText.Format("%d", *it);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// 第三种用法：简化数组遍历语法(从vs2008开始支持)</span><br><span class="line">for each(auto item in vecNum)</span><br><span class="line">{</span><br><span class="line">    strText.Format("%d", item);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// 第四种用法：STL函数</span><br><span class="line">std::for_each(vecNum.begin(), vecNum.end(), [](int item){</span><br><span class="line">    CString strText;</span><br><span class="line">    strText.Format("%d", item);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">});</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// 第五种用法：C++11新增加的(VS2012支持)</span><br><span class="line">for(auto item : vecNum)</span><br><span class="line">{</span><br><span class="line">    strText.Format("%d", item);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">C++string类常用方法</span><br><span class="line">1、string(const char *s) ：将 string 对象初始化为 s 指向的字符串</span><br><span class="line"></span><br><span class="line">string str("hello");</span><br><span class="line"></span><br><span class="line">string(size_type n,char c) ：创建一个包含 n 个元素的 string 对象，其中每个元素都被初始化为字符 c</span><br><span class="line"></span><br><span class="line">string str(10, 'a');</span><br><span class="line"></span><br><span class="line">string(const string &amp;str) ：将一个 string 对象初始化为 string 对象 str（复制构造函数）</span><br><span class="line"></span><br><span class="line">string str("abcde");</span><br><span class="line">string str2(str);</span><br><span class="line">string() ：创建一个默认的 string 对象，长度为 0（默认构造函数）</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">使用C语言风格字符串处理string对象</span><br><span class="line"></span><br><span class="line">string str = "hello!";</span><br><span class="line">获取string对象的长度，C语言中使用strlen()来获取字符串长度，C++中使用str.size()或str.length().</span><br><span class="line"></span><br><span class="line">string str("hello!");</span><br><span class="line">int len1 = str.size();</span><br><span class="line">int len2 = str.length();</span><br><span class="line"></span><br><span class="line">将一个 string 对象赋值给另一个 string 对象</span><br><span class="line"></span><br><span class="line">string str("hello!");</span><br><span class="line">string str2;</span><br><span class="line">str2 = str;</span><br><span class="line"></span><br><span class="line">8、string 对象的拼接</span><br><span class="line">C 语言中使用 strcat、strncat 函数来进行字符串拼接操作，C++中可以采用以下方式：</span><br><span class="line"></span><br><span class="line">string str1("hello");</span><br><span class="line">string str2("world");</span><br><span class="line">string str3 = str1 + str2;</span><br><span class="line"></span><br><span class="line">9、使用 += 来在一个 string 对象后面附加一个 string 对象、字符以及 C 风格的字符串</span><br><span class="line"></span><br><span class="line">string str("hello");</span><br><span class="line">string str2("world");</span><br><span class="line">str += str2;</span><br><span class="line">str += 'a';</span><br><span class="line">str += "abcd";</span><br><span class="line"></span><br><span class="line">10、string.append() 函数，在string对象后添加一个string对象或c风格字符串。</span><br><span class="line"></span><br><span class="line">string str("hello");</span><br><span class="line">string str2("world");</span><br><span class="line">str.append(str2);</span><br><span class="line">str.append("abcd");</span><br><span class="line"></span><br><span class="line">11、string.push_back() 函数来在一个 string 对象后面附加一个字符</span><br><span class="line"></span><br><span class="line">string str("hello");</span><br><span class="line">char ch = 'a';</span><br><span class="line">str.push_back(ch);</span><br><span class="line"></span><br><span class="line">12、对于string对象的比较，可以直接使用关系运算符。</span><br><span class="line"></span><br><span class="line">string str1("abcd");</span><br><span class="line">string str2("abcd");</span><br><span class="line">if(str1 == str2)</span><br><span class="line">	break;</span><br><span class="line"></span><br><span class="line">13、string对象的比较也可以使用string.compare() 方法</span><br><span class="line"></span><br><span class="line">int compare(const string&amp;str) const;</span><br><span class="line">int compare(size_t pos，size_t len，const string&amp;str)const;</span><br><span class="line">int compare(size_t pos，size_t len，const string&amp;str, size_t subpos，size_t sublen)const;</span><br><span class="line">int compare(const char * s)const;</span><br><span class="line">int compare(size_t pos，size_t len，const char * s)const;</span><br><span class="line">int compare(size_t pos，size_t len，const char * s，size_t n)const;</span><br><span class="line"></span><br><span class="line">// example</span><br><span class="line">string str1("hello world");</span><br><span class="line">string str2("hello boy");</span><br><span class="line">str1.compare(6, 3, str2, 6, 3);</span><br><span class="line"></span><br><span class="line">14、使用 string.substr() 函数来获取子串</span><br><span class="line"></span><br><span class="line">string str("hello");</span><br><span class="line">string str2 = str.substr(3,2)</span><br><span class="line"></span><br><span class="line">15、访问 string 字符串的元素</span><br><span class="line"></span><br><span class="line">string str("hello");</span><br><span class="line">cout &lt;&lt; str[2] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str.at(2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">16、使用 string.find() 方法查找字符</span><br><span class="line"></span><br><span class="line">//  从字符串的 pos 位置开始（若不指定 pos 的值，则默认从索引 0 处开始），查找子字符串 str。</span><br><span class="line">//  如果找到，则返回该子字符串首次出现时其首字符的索引；否则，返回 string::npos：</span><br><span class="line">//  string 类将 npos 定义为保证大于任何有效下标的值。</span><br><span class="line">size_type find (const string&amp; str, size_type pos = 0) const;</span><br><span class="line">size_type find (const char *s, size_type pos = 0) const;</span><br><span class="line">size_type find (const char *s, size_type pos, size_type n);</span><br><span class="line">size_type find (char ch, size_type pos = 0) const;</span><br><span class="line"></span><br><span class="line">17、string.rfind() 与 string.find() 方法类似，只是查找顺序不一样， string.rfind() 是从指定位置 pos （默认为字符串末尾）开始向前查找，直到字符串的首部，并返回第一次查找到匹配项时匹配项首字符的索引。换句话说，就是查找子字符串或字符最后一次出现的位置。</span><br><span class="line"></span><br><span class="line">18、string.find_first_of() 方法在字符串中从指定位置开始向后（默认为索引 0 处）查找参数中任何一个字符首次出现的位置</span><br><span class="line"></span><br><span class="line">string str("hello world");</span><br><span class="line">int pos = str.find_first_of("abcde");</span><br><span class="line">int pos = str.find_first_of("abcde", 1);  // 第二个参数为位置</span><br><span class="line"></span><br><span class="line">19、string.find_last_of() 方法在字符串中查找参数中任何一个字符最后一次出现的位置</span><br><span class="line"></span><br><span class="line">20、string.find_first_not_of() 方法在字符串中查找第一个不包含在参数中的字符</span><br><span class="line"></span><br><span class="line">21、string.find_last_not_of() 方法在字符串中查找最后一个不包含在参数中的字符</span><br><span class="line"></span><br><span class="line">22、使用 string.insert() 进行插入操作</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，const string＆str）;　　　</span><br><span class="line">// 在位置 pos 处插入字符串 str</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，const string＆str，size_t subpos，size_t sublen）;　</span><br><span class="line">// 在位置 pos 处插入字符串 str 的从位置 subpos 处开始的 sublen 个字符</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，const char * s）;　　　　</span><br><span class="line">// 在位置 pos 处插入字符串 s</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，const char * s，size_t n）;　</span><br><span class="line">// 在位置 pos 处插入字符串 s 的前 n 个字符</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，size_t n，char c）;　　　　　 </span><br><span class="line">// 在位置 pos 处插入 n 个字符 c</span><br><span class="line"></span><br><span class="line">iterator insert (const_iterator p, size_t n, char c);　</span><br><span class="line">// 在 p 处插入 n 个字符 c，并返回插入后迭代器的位置</span><br><span class="line"></span><br><span class="line">iterator insert (const_iterator p, char c);　　　　　　 </span><br><span class="line">// 在 p 处插入字符 c，并返回插入后迭代器的位置</span><br><span class="line"></span><br><span class="line">23、使用 string.erase() 进行元素删除操作</span><br><span class="line"></span><br><span class="line">string&amp; erase (size_t pos = 0, size_t len = npos);　　　// 删除从 pos 处开始的 n 个字符</span><br><span class="line">iterator erase (const_iterator p);　　　　　　　　　　　　// 删除 p 处的一个字符，并返回删除后迭代器的位置</span><br><span class="line">iterator erase (const_iterator first, const_iterator last);　// 删除从 first 到last 之间的字符，并返回删除后迭代器的位置</span><br><span class="line"></span><br><span class="line">24、使用 getline() 函数来获取 string 输入</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">getline(cin, str);</span><br><span class="line"></span><br><span class="line">25、使用 string.empty() 函数判断字符串是否为空</span><br><span class="line"></span><br><span class="line">26、使用 string.swap() 函数交换两个字符串</span><br><span class="line"></span><br><span class="line">string str1 = "hello";</span><br><span class="line">string str2 = "HELLO";</span><br><span class="line">str1.swap(str2);</span><br><span class="line"></span><br><span class="line">27、string.back()获取或修改字符串最后一个字符</span><br><span class="line"></span><br><span class="line">string str("abcd");</span><br><span class="line">char b = str.back();</span><br><span class="line">str.back() = 'e';</span><br><span class="line"></span><br><span class="line">28、string.front()获取或修改字符串第一个字符</span><br><span class="line"></span><br><span class="line">29、string.pop_back()删除字符串最后一个元素</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h2 id="作业题库1-括号匹配（用顺序栈）"><a href="#作业题库1-括号匹配（用顺序栈）" class="headerlink" title="作业题库1 括号匹配（用顺序栈）"></a>作业题库1 括号匹配（用顺序栈）</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ElemType char</span><br><span class="line">#define MaxSize 50</span><br><span class="line"></span><br><span class="line">typedef struct//自定义名为SqStack的栈</span><br><span class="line">{</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    int top;</span><br><span class="line">} SqStack;</span><br><span class="line"></span><br><span class="line">bool StackEmpty(SqStack S)//判断是否为空栈</span><br><span class="line">{</span><br><span class="line">    if (S.top == -1)</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">bool Pop(SqStack&amp; S, ElemType&amp; x)//出栈</span><br><span class="line">{</span><br><span class="line">    if (S.top == -1)</span><br><span class="line">        return false;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    S.top--;</span><br><span class="line">    return true;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">bool Push(SqStack&amp; S, ElemType x)//入栈</span><br><span class="line">{</span><br><span class="line">    if (S.top == MaxSize - 1)</span><br><span class="line">        return false;</span><br><span class="line">    S.top++;</span><br><span class="line">    S.data[S.top] = x;</span><br><span class="line">    return true;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">bool GetPop(SqStack S, ElemType&amp; x)</span><br><span class="line">{</span><br><span class="line">    if (S.top == -1)</span><br><span class="line">        return false;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    return true;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void initStack(SqStack&amp; S)</span><br><span class="line">{</span><br><span class="line">    S.top = -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    SqStack S;</span><br><span class="line">    initStack(S);</span><br><span class="line">    string v;</span><br><span class="line">    getline(cin, v);</span><br><span class="line">    vector&lt;char&gt; c;</span><br><span class="line">    for (int i = 0; i &lt; v.size(); i++)</span><br><span class="line">    {</span><br><span class="line">        if (v[i] == '(' || v[i] == ')')</span><br><span class="line">        {</span><br><span class="line">            c.push_back(v[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    int b = 0;</span><br><span class="line">    char a;</span><br><span class="line">    int flag = 1;</span><br><span class="line">    while (b &lt; c.size() &amp;&amp; flag != 0)</span><br><span class="line">    {</span><br><span class="line">        a = c[b];</span><br><span class="line">        if (a == '(')</span><br><span class="line">        {</span><br><span class="line">            Push(S, a);</span><br><span class="line">            b++;</span><br><span class="line">        }</span><br><span class="line">        else</span><br><span class="line">        {</span><br><span class="line">            char getpop;</span><br><span class="line">            GetPop(S, getpop);</span><br><span class="line">            if (getpop == '(' &amp;&amp; a == ')')</span><br><span class="line">            {</span><br><span class="line">                char pop;</span><br><span class="line">                Pop(S, pop);</span><br><span class="line">                b++;</span><br><span class="line">                flag = 1;</span><br><span class="line">            }</span><br><span class="line">            else</span><br><span class="line">            {</span><br><span class="line">                flag = 0;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    if (StackEmpty(S) &amp;&amp; flag == 1)</span><br><span class="line">        cout &lt;&lt; "Yes" &lt;&lt; endl;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; "No" &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="作业题库2-回文序列（用链栈）"><a href="#作业题库2-回文序列（用链栈）" class="headerlink" title="作业题库2 回文序列（用链栈）"></a>作业题库2 回文序列（用链栈）</h2><p>“回文”指正读反读均相同的字符序列，如“abcdcba”和“abba”均是回文，使用栈这种数据结构判断给定字符序列是否为回文，要求使用链栈实现。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;//stl容器</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">bool isPalindrome(string str) {</span><br><span class="line">    stack&lt;char&gt; st;</span><br><span class="line">    int len = str.length();</span><br><span class="line"></span><br><span class="line">    // 将字符序列依次入栈</span><br><span class="line">    for (int i = 0; i &lt; len; i++) {</span><br><span class="line">        st.push(str[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 依次比较栈顶和栈底指针指向的字符</span><br><span class="line">    for (int i = 0; i &lt; len; i++) {</span><br><span class="line">        char topChar = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line"></span><br><span class="line">        if (topChar != str[i]) {</span><br><span class="line">            return false;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">    if (isPalindrome(str)) {</span><br><span class="line">        cout &lt;&lt; "true" &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    else {</span><br><span class="line">        cout &lt;&lt; "false" &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>





<h2 id="题库3入栈和出栈"><a href="#题库3入栈和出栈" class="headerlink" title="题库3入栈和出栈"></a>题库3入栈和出栈</h2><p>给定一个正整数数列（以0表示输入结束），从第一个数开始，将每一个数入栈，入栈的同时获得一个分数，即该数的数值乘以入栈后栈的大小，请计算将所有元素入栈后的分数和，然后将栈内元素依次输出，要求使用顺序栈。元素个数&lt;100，每个元素&lt;100。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> str[<span class="number">100</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> ( i = <span class="number">0</span>;; i++)</span><br><span class="line">	{</span><br><span class="line">		cin &gt;&gt; str[i];</span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		sum += (i+<span class="number">1</span>) * str[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="type">int</span> len = i;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="comment">// 将字符序列依次入栈</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;i ; j++) {</span><br><span class="line">		st.<span class="built_in">push</span>(str[j]);</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; st.<span class="built_in">top</span>()&lt;&lt;<span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">		st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>







<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_SIZE = 100; // 栈的最大容量</span><br><span class="line"></span><br><span class="line">class Stack {</span><br><span class="line">private:</span><br><span class="line">    int* data; // 栈的数组</span><br><span class="line">    int top; // 栈顶指针</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Stack() {</span><br><span class="line">        data = new int[MAX_SIZE];</span><br><span class="line">        top = -1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~Stack() {</span><br><span class="line">        delete[] data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    bool isEmpty() {</span><br><span class="line">        return top == -1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    bool isFull() {</span><br><span class="line">        return top == MAX_SIZE - 1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void push(int value) {</span><br><span class="line">        if (isFull()) {</span><br><span class="line">            cout &lt;&lt; "Stack is full. Cannot push more elements." &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        top++;</span><br><span class="line">        data[top] = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int pop() {</span><br><span class="line">        if (isEmpty()) {</span><br><span class="line">            cout &lt;&lt; "Stack is empty. Cannot pop any element." &lt;&lt; endl;</span><br><span class="line">            return -1;</span><br><span class="line">        }</span><br><span class="line">        int value = data[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int getSize() {</span><br><span class="line">        return top + 1;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    Stack stack;</span><br><span class="line">    int num, scoreSum = 0;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    while (num != 0) {</span><br><span class="line">        stack.push(num);</span><br><span class="line">        int score = stack.getSize() * num; // 计算分数</span><br><span class="line">        scoreSum += score;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">    }</span><br><span class="line">    while (!stack.isEmpty()) {</span><br><span class="line">        int value = stack.pop();</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; " ";</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="题库4-点击消除"><a href="#题库4-点击消除" class="headerlink" title="题库4     点击消除"></a>题库4     点击消除</h2><p>给定一个字符串，每次“点击”，可以把字符串中相邻两个相同字母消除，例如，字符串”abbc”点击后可以生成”ac”。但相同而不相邻、不相同的相邻字母都是不可以被消除的。<br>通过点击足够多次之后可以把字符串变得尽可能短，编程实现输出给定字符串足够多次点击后的最终形态。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<ol>
<li>初始化一个空栈。</li>
<li>依次遍历字符串中的每个字符：<ul>
<li>如果栈为空，将当前字符入栈。</li>
<li>如果栈不为空且当前字符与栈顶字符相同，将栈顶字符出栈。</li>
<li>如果栈不为空且当前字符与栈顶字符不相同，将当前字符入栈。</li>
</ul>
</li>
<li>栈中剩余的字符即为点击足够多次后的最终形态。</li>
</ol>
<h2 id="题库5-周末舞会"><a href="#题库5-周末舞会" class="headerlink" title="题库5 周末舞会"></a>题库5 周末舞会</h2><p>假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头上各出一人配成舞伴。规定每个舞曲能有一对跳舞者。若两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。现要求写一个程序，模拟上述舞伴配对问题。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxqsize 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dancePartner</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; males;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; females;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">        males.<span class="built_in">push</span>(i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        females.<span class="built_in">push</span>(i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) {</span><br><span class="line">        <span class="keyword">if</span> (males.<span class="built_in">empty</span>() || females.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> male = males.<span class="built_in">front</span>();</span><br><span class="line">        males.<span class="built_in">push</span>(male);</span><br><span class="line">        males.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> female = females.<span class="built_in">front</span>();</span><br><span class="line">        females.<span class="built_in">pop</span>();</span><br><span class="line">        females.<span class="built_in">push</span>(female);</span><br><span class="line">        cout &lt;&lt; male &lt;&lt; <span class="string">" "</span> &lt;&lt; female &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> m, n, k;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">        cin&gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dancePartner</span>(m, n, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>采用STL库里的queue队列库，将其变成循环队列就好</p>
<h2 id="题库6-无法吃午餐的学生数量"><a href="#题库6-无法吃午餐的学生数量" class="headerlink" title="题库6  无法吃午餐的学生数量"></a>题库6  <strong>无法吃午餐的学生数量</strong></h2><p>学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：<br>1.如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。<br>否则，这名学生会 放弃这个三明治 并回到队列的尾部。<br>2.这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。</p>
<p>输入两个整数数组 students 和 sandwiches ，其中 sandwiches[i] 是栈里面第 i个三明治的类型（i = 0 是栈的顶部）， students[j] 是初始队列里第 j名学生对三明治的喜好（j = 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#define maxqsize 1000</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">void Partner(int *a,int *b, int len) {</span><br><span class="line">    queue&lt;int&gt; studentsqueue;</span><br><span class="line">    stack&lt;int&gt; sandwichesstack;</span><br><span class="line">    int  unhappyCount = 0;</span><br><span class="line">    for (int i = 0; i &lt; len; i++)</span><br><span class="line">    {</span><br><span class="line">        studentsqueue.push(a[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for (int i = len-1; i&gt;=0; i--) {</span><br><span class="line">        sandwichesstack.push(b[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    while (!studentsqueue.empty() &amp;&amp; !sandwichesstack.empty()) {</span><br><span class="line">        int frontStudent = studentsqueue.front();</span><br><span class="line">        int topSandwich = sandwichesstack.top();</span><br><span class="line"></span><br><span class="line">        if (frontStudent == topSandwich) {</span><br><span class="line">            // 学生喜欢栈顶的三明治，拿走它并离开队列</span><br><span class="line">            studentsqueue.pop();</span><br><span class="line">            sandwichesstack.pop();</span><br><span class="line">            unhappyCount = 0; // 重置无法吃午餐的学生数量</span><br><span class="line">        }</span><br><span class="line">        else {</span><br><span class="line">            // 学生不喜欢栈顶的三明治，放弃它并排到队尾</span><br><span class="line">            studentsqueue.pop();</span><br><span class="line">            studentsqueue.push(frontStudent);</span><br><span class="line">            unhappyCount++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 检查队列中剩余学生的喜好是否与栈顶的三明治类型相同</span><br><span class="line">        if (unhappyCount == studentsqueue.size()) {</span><br><span class="line">            break;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; studentsqueue.size();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    int students[100];</span><br><span class="line">    int sandwiches[100];</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    for ( i = 0;; i++)</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; students[i];</span><br><span class="line"></span><br><span class="line">        if (students[i] == -1)</span><br><span class="line">        {</span><br><span class="line">            break;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    for (j = 0;; j++)</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; sandwiches[j];</span><br><span class="line"></span><br><span class="line">        if (sandwiches[j] == -1)</span><br><span class="line">        {</span><br><span class="line">            break;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    Partner(students,sandwiches,i);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>队列是先进先出，栈是先进后出，不满意口味的当unhappystudents数量等于目前队列长度则跳出循环</p>
<h2 id="题库7-栈的操作"><a href="#题库7-栈的操作" class="headerlink" title="题库7  栈的操作"></a>题库7  栈的操作</h2><p>请你实现一个栈。<br>可以完成操作：<br>push x：将 x入栈，保证 x为 int 型整数。<br>pop：输出栈顶，并让栈顶出栈<br>top：输出栈顶，栈顶不出栈</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt;str;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	{</span><br><span class="line">		string a;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">getline</span>(cin, a);</span><br><span class="line">		<span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="string">'p'</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">'u'</span>)</span><br><span class="line">			{</span><br><span class="line">				string b;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">5</span>; j &lt; a.<span class="built_in">size</span>(); j++)</span><br><span class="line">				{</span><br><span class="line">					b[sum] = a[j];</span><br><span class="line">					sum++;</span><br><span class="line">				}</span><br><span class="line">				<span class="type">int</span> num = <span class="built_in">stoi</span>(b);</span><br><span class="line">				str.<span class="built_in">push</span>(num);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">'o'</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">				{</span><br><span class="line">					cout &lt;&lt; <span class="string">"error"</span> &lt;&lt; endl;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					cout &lt;&lt; str.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">					str.<span class="built_in">pop</span>();</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">			{</span><br><span class="line">				cout &lt;&lt; <span class="string">"error"</span>&lt;&lt;endl;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout &lt;&lt;str.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h2 id="题库-8-栈的压入、弹出序列"><a href="#题库-8-栈的压入、弹出序列" class="headerlink" title="题库 8 栈的压入、弹出序列"></a><strong>题库 8 栈的压入、弹出序列</strong></h2><p>对输入的两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p>
<ol>
<li>栈中数据的数量≤1000<br>\2. push 的所有数字均不相同</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">bool isPopOrderPossible(const vector&lt;int&gt;&amp; pushOrder, const vector&lt;int&gt;&amp; popOrder) {</span><br><span class="line">    stack&lt;int&gt; stack;//辅助栈</span><br><span class="line">    int pushIndex = 0;//初始化了一个指针pushIndex，用于遍历压入序列。</span><br><span class="line">    //循环来遍历弹出序列中的每个元素</span><br><span class="line">    for (int popIndex = 0; popIndex &lt; popOrder.size(); ++popIndex) {</span><br><span class="line">        while (stack.empty() || stack.top() != popOrder[popIndex]) {</span><br><span class="line">            if (pushIndex == pushOrder.size()) {</span><br><span class="line">                return false;</span><br><span class="line">            }</span><br><span class="line">            stack.push(pushOrder[pushIndex]);</span><br><span class="line">            ++pushIndex;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        stack.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return stack.empty() &amp;&amp; pushIndex == pushOrder.size();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    vector&lt;int&gt; pushOrder;</span><br><span class="line">    vector&lt;int&gt; popOrder;//压入序列和弹出序列</span><br><span class="line">    int num ;</span><br><span class="line">    while (cin &gt;&gt; num &amp;&amp; num != -1) {</span><br><span class="line">        pushOrder.push_back(num);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 输入栈的弹出顺序</span><br><span class="line">    while (cin &gt;&gt; num &amp;&amp; num != -1) {</span><br><span class="line">        popOrder.push_back(num);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; boolalpha;  // Print "true" or "false" instead of "1" or "0"</span><br><span class="line">   cout  &lt;&lt; isPopOrderPossible(pushOrder, popOrder) &lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>判断第二个序列是否可能为该栈的弹出顺序的原理基于以下观察：</p>
<ol>
<li><p>对于一个元素进栈后，它只能出栈一次。</p>
</li>
<li><p>如果一个元素出栈，那么它之前所有比它先进栈的元素都应该已经出栈了。</p>
</li>
<li><p>首先，我们定义了一个<code>isPopOrderPossible</code>函数，该函数接受两个参数：<code>pushOrder</code>和<code>popOrder</code>，分别表示压入序列和弹出序列。</p>
</li>
<li><p>在函数内部，我们创建了一个辅助栈<code>stack</code>，用于模拟栈的压入和弹出操作。同时，我们初始化了一个指针<code>pushIndex</code>，用于遍历压入序列。</p>
</li>
<li><p>接下来，我们使用一个循环来遍历弹出序列中的每个元素。</p>
</li>
<li><p>在循环中，我们首先检查辅助栈是否为空或栈顶元素是否与当前弹出元素相等。如果不相等，则说明该元素要么还未进栈，要么已经出栈但不在栈顶。此时，我们需要将压入序列中的元素进栈，直到找到与当前弹出元素相等的元素为止，或者压入序列中的所有元素都进栈了。</p>
</li>
<li><p>如果压入序列的指针<code>pushIndex</code>已经遍历完所有元素，但栈顶元素仍然不等于当前弹出元素，说明无法找到与当前弹出元素相等的元素，即第二个序列不可能是该栈的弹出序列。因此，我们返回<code>false</code>。</p>
</li>
<li><p>如果栈顶元素等于当前弹出元素，我们将栈顶元素出栈，并移动弹出序列的指针。</p>
</li>
<li><p>循环结束后，我们需要检查辅助栈是否为空且压入序列的指针是否已经遍历完所有元素。如果这两个条件都满足，说明第二个序列可能是该栈的弹出序列，我们返回<code>true</code>；否则，返回<code>false</code>。</p>
</li>
</ol>
<h2 id="题库9-最长有效括号"><a href="#题库9-最长有效括号" class="headerlink" title="题库9  最长有效括号"></a>题库9  最长有效括号</h2><p>给你一个只包含 ‘(’ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度</p>
<h3 id="第一种-不用栈，用count表示左括号"><a href="#第一种-不用栈，用count表示左括号" class="headerlink" title="第一种  不用栈，用count表示左括号"></a>第一种  不用栈，用count表示左括号</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>{</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> longest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) {</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">                count--;</span><br><span class="line">                len += <span class="number">2</span>;</span><br><span class="line">                longest = <span class="built_in">max</span>(longest, len);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 遇到右括号且没有与之匹配的左括号，重新开始计算长度</span></span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">longestValidParentheses</span>(str);</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="第二种用栈"><a href="#第二种用栈" class="headerlink" title="第二种用栈"></a>第二种用栈</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	string str;</span><br><span class="line">	getline(cin, str);</span><br><span class="line">	stack&lt;char&gt;strstack;</span><br><span class="line">	int num = 0;</span><br><span class="line">	char a;</span><br><span class="line">	int len = 0;</span><br><span class="line">	while (num &lt; str.size())</span><br><span class="line">	{</span><br><span class="line">		a = str[num];</span><br><span class="line">		if (a == '(')</span><br><span class="line">		{</span><br><span class="line">			strstack.push(a);</span><br><span class="line">			num++;</span><br><span class="line">		}</span><br><span class="line">		else</span><br><span class="line">		{</span><br><span class="line">			/*if (strstack.empty() &amp;&amp; a == ')')</span><br><span class="line">			{</span><br><span class="line"></span><br><span class="line">			}*/</span><br><span class="line">			if (!strstack.empty())</span><br><span class="line">			{</span><br><span class="line">				if (strstack.top() == '(' &amp;&amp; a == ')')</span><br><span class="line">				{</span><br><span class="line"></span><br><span class="line">					strstack.pop();</span><br><span class="line">					num++;</span><br><span class="line">					len += 2;</span><br><span class="line"></span><br><span class="line">				}</span><br><span class="line"></span><br><span class="line">			}</span><br><span class="line">			else</span><br><span class="line">				num++;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>





<h2 id="题库-11-找出游戏胜利者"><a href="#题库-11-找出游戏胜利者" class="headerlink" title="题库 11  找出游戏胜利者"></a>题库 11  找出游戏胜利者</h2><p>共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 &lt;= i &lt; n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。<br>游戏遵循如下规则：</p>
<ul>
<li>从第 1 名小伙伴所在位置 开始 。</li>
<li>沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li>
<li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li>
<li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行</li>
<li>否则，圈子中最后一名小伙伴赢得游戏。</li>
</ul>
<p>给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int findTheWinner(int n, int k) {</span><br><span class="line">    std::queue&lt;int&gt; circle;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) {</span><br><span class="line">        circle.push(i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    while (circle.size() &gt; 1) {</span><br><span class="line">        for (int i = 1; i &lt; k; ++i) {</span><br><span class="line">            circle.push(circle.front());</span><br><span class="line">            circle.pop();</span><br><span class="line">        }</span><br><span class="line">        // 将被淘汰的人移出队列</span><br><span class="line">        circle.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return circle.front();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    int n;</span><br><span class="line">    int k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    int winner = findTheWinner(n, k);</span><br><span class="line">    cout &lt;&lt; winner &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 &lt;= i &lt; n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。<br>游戏遵循如下规则：</p>
<ul>
<li>从第 1 名小伙伴所在位置 开始 。</li>
<li>沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li>
<li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li>
<li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行</li>
<li>否则，圈子中最后一名小伙伴赢得游戏。</li>
</ul>
<p>给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。</p>
<h1 id="作业题库-数组和串"><a href="#作业题库-数组和串" class="headerlink" title="作业题库 数组和串"></a>作业题库 数组和串</h1><h2 id="1-数组与串-小鱼比可爱"><a href="#1-数组与串-小鱼比可爱" class="headerlink" title="1.数组与串-小鱼比可爱"></a>1.<strong>数组与串-小鱼比可爱</strong></h2><p>人比人，气死人；鱼比鱼，难死鱼。小鱼最近参加了一个“比可爱”比赛，比的是每只鱼的可爱程度。参赛的鱼被从左到右排成一排，头都朝向左边，然后每只鱼会得到一个整数数值，表示这只鱼的可爱程度，很显然整数越大，表示这只鱼越可爱，而且任意两只鱼的可爱程度可能一样。由于所有的鱼头都朝向左边，所以每只鱼只能看见在它左边的鱼的可爱程度，它们心里都在计算，在自己的眼力范围内有多少只鱼不如自己可爱呢。请你帮这些可爱但是鱼脑不够用的小鱼们计算一下。</p>
<p>输入：<br>6<br>4 3 0 5 1 2<br>输出：<br>0 0 0 3 1 2</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	int n = 0;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	int arr[1000];</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	{</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	}</span><br><span class="line">	int number[1000];</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	{</span><br><span class="line">		int num = 0;//记录有几个可爱</span><br><span class="line">		for (int j = i; j &gt;= 0; j--)</span><br><span class="line">		{</span><br><span class="line">			if (arr[i] &gt; arr[j])</span><br><span class="line">			{</span><br><span class="line">				num++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		number[i] = num;</span><br><span class="line">	}</span><br><span class="line">	for (int k = 0; k &lt; n; k++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; number[k]&lt;&lt;' ';</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h2 id="2-数组与串-杨辉三角"><a href="#2-数组与串-杨辉三角" class="headerlink" title="2.数组与串-杨辉三角"></a>2.数组与串-杨辉三角</h2><p>给出 n(n≤20)，输出杨辉三角的前 n 行。<br>如果你不知道什么是杨辉三角，可以观察样例找找规律。</p>
<p>输入: 6<br>输出:<br>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br>1 5 10 10 5 1</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string yanghui(int numRows) {</span><br><span class="line">   string result;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; numRows; i++) {</span><br><span class="line">        int num = 1;</span><br><span class="line">        for (int j = 0; j &lt;= i; j++) {</span><br><span class="line">            result += to_string(num) + " ";</span><br><span class="line">            num = num * (i - j) / (j + 1);//为了打印后续重复的</span><br><span class="line">        }</span><br><span class="line">        result += "\n";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    int numRows;</span><br><span class="line">    cin &gt;&gt; numRows;</span><br><span class="line">    string str = yanghui(numRows);</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>string 用to_string将数字转变为字符</p>
<h2 id="3-数组与串-冰雹猜想"><a href="#3-数组与串-冰雹猜想" class="headerlink" title="3.数组与串-冰雹猜想"></a><strong>3.数组与串-冰雹猜想</strong></h2><p>给出一个正整数 n，然后对这个数字一直进行下面的操作：如果这个数字是奇数，那么将其乘 3 再加 1，否则除以 2。经过若干次循环后，最终都会回到 1。经过验证很大的数字（7*10^{11}）都可以按照这样的方式比变成 1，所以被称为“冰雹猜想”。例如当 n 是 2020，变化的过程是20→10→5→16→8→4→2→1。</p>
<p>输入描述</p>
<p>输入一个正整数 n。</p>
<p>输出描述</p>
<p>输出若干个由空格隔开的正整数，表示从最后的 1 开始倒序的变化数列。</p>
<p>输入输出样例</p>
<p>输入：20<br>输出：1 2 4 8 16 5 10 20</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	int num = 0;</span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line">	int arr[1000];</span><br><span class="line">	arr[0] = num;</span><br><span class="line">	int size = 1;</span><br><span class="line">	while (num != 1)</span><br><span class="line">	{</span><br><span class="line">		if (num % 2 != 0)</span><br><span class="line">		{</span><br><span class="line">			num = num * 3 + 1;</span><br><span class="line">			arr[size] = num;</span><br><span class="line">			size++;</span><br><span class="line">		}</span><br><span class="line">		else</span><br><span class="line">		{</span><br><span class="line">			num = num / 2;</span><br><span class="line">			arr[size] = num;</span><br><span class="line">			size++;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	for (int i = size - 1; i &gt;= 0; i--)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; ' ';</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-数组与串-液晶屏"><a href="#5-数组与串-液晶屏" class="headerlink" title="5.数组与串-液晶屏"></a>5.<strong>数组与串-液晶屏</strong></h2><p>液晶屏上，每个阿拉伯数字都是可以显示成 3×5 的点阵的（其中 X 表示亮点，. 表示暗点）。现在给出数字位数（不超过 100）和一串数字，要求输出这些数字在显示屏上的效果。数字的显示方式如同样例输出，注意每个数字之间都有一列间隔。</p>
<p>输入描述</p>
<p>第一行输入一个正整数 n，表示数字的位数。<br>第二行输入一个长度为 n 的自然数</p>
<p>输出描述</p>
<p>输出五行，表示显示屏上的数字。<br>有些同学反应看不懂，这里观察一下就知道了<br>每个数字是一个3×5的矩阵<br>每个数字之间用一个1×5的.相隔<br>这里输出有点显示字符占位不一样，导致显示问题。<br>这里我添加一张图片方便大家观察</p>
<p><img src="http://acm.scu.edu.cn/teach/data/problem/1550/image.png" alt="none"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define MAXSIZE 101</span><br><span class="line">const char digits[10][5][4] = {</span><br><span class="line">	{</span><br><span class="line">		"XXX",</span><br><span class="line">		"X X",</span><br><span class="line">		"X X",</span><br><span class="line">		"X X",</span><br><span class="line">		"XXX"</span><br><span class="line">	},</span><br><span class="line">	{</span><br><span class="line">		"  X",</span><br><span class="line">		"  X",</span><br><span class="line">		"  X",</span><br><span class="line">		"  X",</span><br><span class="line">		"  X"</span><br><span class="line">	},</span><br><span class="line">	{</span><br><span class="line">		"XXX",</span><br><span class="line">		"  X",</span><br><span class="line">		"XXX",</span><br><span class="line">		"X  ",</span><br><span class="line">		"XXX"</span><br><span class="line">	},</span><br><span class="line">	{</span><br><span class="line">		"XXX",</span><br><span class="line">		"  X",</span><br><span class="line">		"XXX",</span><br><span class="line">		"  X",</span><br><span class="line">		"XXX"</span><br><span class="line">	},</span><br><span class="line">	{</span><br><span class="line">		"X X",</span><br><span class="line">		"X X",</span><br><span class="line">		"XXX",</span><br><span class="line">		"  X",</span><br><span class="line">		"  X"</span><br><span class="line">	},</span><br><span class="line">	{</span><br><span class="line">		"XXX",</span><br><span class="line">		"X  ",</span><br><span class="line">		"XXX",</span><br><span class="line">		"  X",</span><br><span class="line">		"XXX"</span><br><span class="line">	},</span><br><span class="line">	{</span><br><span class="line">		"XXX",</span><br><span class="line">		"X  ",</span><br><span class="line">		"XXX",</span><br><span class="line">		"X X",</span><br><span class="line">		"XXX"</span><br><span class="line">	},</span><br><span class="line">	{</span><br><span class="line">		"XXX",</span><br><span class="line">		"  X",</span><br><span class="line">		"  X",</span><br><span class="line">		"  X",</span><br><span class="line">		"  X"</span><br><span class="line">	},</span><br><span class="line">	{</span><br><span class="line">		"XXX",</span><br><span class="line">		"X X",</span><br><span class="line">		"XXX",</span><br><span class="line">		"X X",</span><br><span class="line">		"XXX"</span><br><span class="line">	},</span><br><span class="line">	{</span><br><span class="line">		"XXX",</span><br><span class="line">		"X X",</span><br><span class="line">		"XXX",</span><br><span class="line">		"  X",</span><br><span class="line">		"XXX"</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line">int main() {</span><br><span class="line">	int n = 0;</span><br><span class="line">	scanf("%d", &amp;n);</span><br><span class="line">	char str[MAXSIZE];</span><br><span class="line">	scanf("%s", str);</span><br><span class="line">	int row, col;</span><br><span class="line">	for (row = 0; row &lt; 5; row++) {</span><br><span class="line">		for (int i = 0; i &lt; n; i++) {</span><br><span class="line">			int digit = str[i] - '0'; // 将字符数字转换为整数</span><br><span class="line">			for (col = 0; col &lt; 3; col++) {</span><br><span class="line">				if (digits[digit][row][col] == 'X') {</span><br><span class="line">					printf("X");</span><br><span class="line">				}</span><br><span class="line">				else {</span><br><span class="line">					printf(".");</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			if (i &lt; n - 1) {</span><br><span class="line">				printf("."); // 数字之间用点隔开</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		printf("\n");</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>定义三维数组，</p>
<h2 id="6-n皇后问题"><a href="#6-n皇后问题" class="headerlink" title="6.n皇后问题"></a>6.n皇后问题</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>题目难度 LeetCode+简单</p>
<p>输入一个数组</p>
<p>输出描述</p>
<p>输出方案总数</p>
<p>输入输出样例</p>
<p>输入：n = 4<br>输出：2</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n,string(n, <span class="string">'.'</span>))</span></span>;<span class="comment">//创建棋盘</span></span><br><span class="line">        <span class="built_in">solveNQueens</span>(board, <span class="number">0</span>, count);<span class="comment">//核心函数,回溯皇后</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveNQueens</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span>&amp; count)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (row == board.<span class="built_in">size</span>()) {</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; board.<span class="built_in">size</span>(); col++) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isSafe</span>(board, row, col)) {</span><br><span class="line">                board[row][col] = <span class="string">'Q'</span>;<span class="comment">//是安全的，就可以放皇后</span></span><br><span class="line">                <span class="built_in">solveNQueens</span>(board, row + <span class="number">1</span>, count);<span class="comment">//检查下一行</span></span><br><span class="line">                board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSafe</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>{<span class="comment">//判断是不是有没有皇后，是不是安全的</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) {</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左上是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row, j = col; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) {</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查右上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row, j = col; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; board.<span class="built_in">size</span>(); i--, j++) {</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> n ;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="type">int</span> result = solution.<span class="built_in">totalNQueens</span>(n);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSafe</span><span class="params">(<span class="type">int</span> board[], <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the column</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++) {</span><br><span class="line">        <span class="keyword">if</span> (board[i] == col || <span class="built_in">abs</span>(board[i] - col) == <span class="built_in">abs</span>(i - row)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> board[], <span class="type">int</span> row, <span class="type">int</span> n, <span class="type">int</span> *count)</span> {</span><br><span class="line">    <span class="keyword">if</span> (row == n) {</span><br><span class="line">        (*count)++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) {</span><br><span class="line">        <span class="keyword">if</span> (isSafe(board, row, col, n)) {</span><br><span class="line">            board[row] = col;</span><br><span class="line">            solveNQueens(board, row + <span class="number">1</span>, n, count);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">int</span> board[n];</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    solveNQueens(board, <span class="number">0</span>, n, &amp;count);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> result = totalNQueens(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>







<h2 id="作业题库：二叉树"><a href="#作业题库：二叉树" class="headerlink" title="作业题库：二叉树"></a>作业题库：二叉树</h2><h3 id="1-相同的树"><a href="#1-相同的树" class="headerlink" title="1.相同的树"></a>1.<strong>相同的树</strong></h3><p><img src="http://acm.scu.edu.cn/teach/data/problem/1562/11.png" alt="11.png"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	char arr1[10000];</span><br><span class="line">	char arr2[10000];</span><br><span class="line">	char s=1;</span><br><span class="line">	char t = 1;</span><br><span class="line">	int num1=0;</span><br><span class="line">    int num2=0;</span><br><span class="line">	string str1, str2;</span><br><span class="line">	getline(cin, str1);</span><br><span class="line">	getline(cin, str2);</span><br><span class="line">	if (str1 == str2)</span><br><span class="line">		cout &lt;&lt; "true";</span><br><span class="line">	else</span><br><span class="line">		cout &lt;&lt; "false";</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>直接比较字符串是否相同</p>
<h3 id="2-二叉树的中序遍历"><a href="#2-二叉树的中序遍历" class="headerlink" title="2.二叉树的中序遍历**"></a>2.二叉树的中序遍历**</h3><p>给你一个二叉树的根节点root，检查它是否轴对称。</p>
<p>输入描述<br>一个节点序列</p>
<p>输出描述<br>真假</p>
<p>输入输出样例</p>
<p>输入<br>1,2,3,4，null</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode {</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">};</span><br><span class="line">TreeNode* createTree(char* input) {</span><br><span class="line">    if (strcmp(input, "null") == 0) {</span><br><span class="line">        return NULL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int size = 1;</span><br><span class="line">    for (int i = 0; i &lt; strlen(input); i++) {</span><br><span class="line">        if (input[i] == ',') {</span><br><span class="line">            size++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    TreeNode** queue = new TreeNode * [size];</span><br><span class="line">    int front = 0, rear = 0;</span><br><span class="line">    TreeNode* root = new TreeNode;</span><br><span class="line">    root-&gt;val = atoi(strtok(input, ","));</span><br><span class="line">    root-&gt;left = root-&gt;right = NULL;</span><br><span class="line">    queue[rear++] = root;</span><br><span class="line"></span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; size) {</span><br><span class="line">        TreeNode* node = queue[front++];</span><br><span class="line">        char* in = strtok(NULL, ",");</span><br><span class="line"></span><br><span class="line">        if (strcmp(in, "null") != 0) {</span><br><span class="line">            node-&gt;left = new TreeNode;</span><br><span class="line">            node-&gt;left-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;left-&gt;left = node-&gt;left-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        in = strtok(NULL, ",");</span><br><span class="line">        if (i &lt; size &amp;&amp; strcmp(in, "null") != 0) {</span><br><span class="line">            node-&gt;right = new TreeNode;</span><br><span class="line">            node-&gt;right-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;right-&gt;left = node-&gt;right-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;right;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">}</span><br><span class="line">TreeNode* invertTree(TreeNode* root) {</span><br><span class="line">    if (root == NULL) {</span><br><span class="line">        return NULL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 递归翻转左右子树</span><br><span class="line">    TreeNode* temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;right = invertTree(temp);</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">}</span><br><span class="line">string levelOrderTraversal(TreeNode* root) {</span><br><span class="line">    if (root == NULL) {</span><br><span class="line">        return "";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    string result;</span><br><span class="line">    queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">    nodeQueue.push(root);</span><br><span class="line">    result += to_string(root-&gt;val) + ",";</span><br><span class="line">    while (!nodeQueue.empty()) {</span><br><span class="line">        TreeNode* node = nodeQueue.front();</span><br><span class="line">        nodeQueue.pop();</span><br><span class="line"></span><br><span class="line">        if (node-&gt;left != NULL) {</span><br><span class="line">            nodeQueue.push(node-&gt;left);</span><br><span class="line">            result += to_string(node-&gt;left-&gt;val) + ",";</span><br><span class="line">        }</span><br><span class="line">        else if (node-&gt;right) result += "null,";</span><br><span class="line">        else {</span><br><span class="line">            result += "null,";</span><br><span class="line">            result += "null,";</span><br><span class="line">        }</span><br><span class="line">        if (node-&gt;right != NULL) {</span><br><span class="line">            nodeQueue.push(node-&gt;right);</span><br><span class="line">            result += to_string(node-&gt;right-&gt;val) + ",";</span><br><span class="line">        }</span><br><span class="line">        else if (node-&gt;left) result += "null,";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if (!result.empty()) {</span><br><span class="line">        result.pop_back();  // 去除最后一个逗号</span><br><span class="line">    }</span><br><span class="line">    while (result[result.size() - 1] == 'l') {</span><br><span class="line">        result.pop_back();</span><br><span class="line">        result.pop_back();</span><br><span class="line">        result.pop_back();</span><br><span class="line">        result.pop_back();</span><br><span class="line">        result.pop_back();</span><br><span class="line">    }</span><br><span class="line">    return result;</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    char input[256];</span><br><span class="line">    cin.getline(input, sizeof(input));</span><br><span class="line">    int num = strlen(input);</span><br><span class="line">    TreeNode* root = createTree(input);</span><br><span class="line">    TreeNode* invertedRoot = invertTree(root);</span><br><span class="line">    string output;</span><br><span class="line">    output=  levelOrderTraversal(invertedRoot);</span><br><span class="line">    cout &lt;&lt; output;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-翻转二叉树"><a href="#3-翻转二叉树" class="headerlink" title="3.翻转二叉树"></a>3.翻转二叉树</h3><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<p><strong>输入描述：</strong><br>一个节点序列</p>
<p><strong>输出描述：</strong><br>返回其根节点序列</p>
<p><strong>样例</strong></p>
<p>输入<br>root = [4,2,7,1,3,6,9]<br>输出</p>
<p>[4,7,2,9,6,3,1]</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">TreeNode* invertTree(TreeNode* root) {</span><br><span class="line">    if (root == NULL) {</span><br><span class="line">        return NULL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 递归翻转左右子树</span><br><span class="line">    TreeNode* temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;right = invertTree(temp);</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-左叶子之和"><a href="#4-左叶子之和" class="headerlink" title="4.左叶子之和"></a>4.<strong>左叶子之和</strong></h3><p><strong>题目描述</strong><br>给定二叉树的根节点 root ，返回所有左叶子之和。</p>
<p><strong>输入描述</strong><br>一个节点序列<br><strong>输出描述</strong><br>返回其左叶子之和</p>
<p><strong>输入输出样例</strong></p>
<p>输入<br>root = [3,9,20,null,null,15,7]<br>输出<br>24<br>输入<br>root = [1]<br>输出<br>0</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">     </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建二叉树的函数</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">createTree</span><span class="params">(<span class="type">char</span>* input)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">"null"</span>) == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(input); i++) {</span><br><span class="line">        <span class="keyword">if</span> (input[i] == <span class="string">','</span>) {</span><br><span class="line">            size++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    TreeNode** queue = <span class="keyword">new</span> TreeNode * [size];</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    root-&gt;val = <span class="built_in">atoi</span>(<span class="built_in">strtok</span>(input, <span class="string">","</span>));</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    queue[rear++] = root;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; size) {</span><br><span class="line">        TreeNode* node = queue[front++];</span><br><span class="line">        <span class="type">char</span>* in = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(in, <span class="string">"null"</span>) != <span class="number">0</span>) {</span><br><span class="line">            node-&gt;left = <span class="keyword">new</span> TreeNode;</span><br><span class="line">            node-&gt;left-&gt;val = <span class="built_in">atoi</span>(in);</span><br><span class="line">            node-&gt;left-&gt;left = node-&gt;left-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">            queue[rear++] = node-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        in = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">","</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; size &amp;&amp; <span class="built_in">strcmp</span>(in, <span class="string">"null"</span>) != <span class="number">0</span>) {</span><br><span class="line">            node-&gt;right = <span class="keyword">new</span> TreeNode;</span><br><span class="line">            node-&gt;right-&gt;val = <span class="built_in">atoi</span>(in);</span><br><span class="line">            node-&gt;right-&gt;left = node-&gt;right-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">            queue[rear++] = node-&gt;right;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算左叶子之和的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子树是叶子节点，累加其值</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) {</span><br><span class="line">        sum += root-&gt;left-&gt;val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算左右子树的左叶子之和</span></span><br><span class="line">    sum += <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);</span><br><span class="line">    sum += <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">char</span> input[<span class="number">256</span>];</span><br><span class="line">    cin.<span class="built_in">getline</span>(input, <span class="built_in">sizeof</span>(input));</span><br><span class="line">    TreeNode* root = <span class="built_in">createTree</span>(input);</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sumOfLeftLeaves</span>(root);</span><br><span class="line">    cout  &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-二叉树最近的公共祖先"><a href="#5-二叉树最近的公共祖先" class="headerlink" title="5.二叉树最近的公共祖先"></a>5.二叉树最近的公共祖先</h3><p><strong>题目描述</strong><br>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>（一个节点也可以是它自己的祖先）。</p>
<p><strong>输入描述</strong><br>给一个二叉树<br><strong>输出描述</strong><br>输出它的最近公共近邻</p>
<p><strong>输入输出样例</strong><br>输入<br>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出<br>3</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义二叉树节点</span><br><span class="line">struct TreeNode {</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">   // TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span><br><span class="line">};</span><br><span class="line">//创建二叉树的函数</span><br><span class="line">TreeNode* createTree(char* input) {</span><br><span class="line">    if (strcmp(input, "null") == 0) {</span><br><span class="line">        return NULL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int size = 1;</span><br><span class="line">    for (int i = 0; i &lt; strlen(input); i++) {</span><br><span class="line">        if (input[i] == ',') {</span><br><span class="line">            size++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    TreeNode** queue = new TreeNode * [size];</span><br><span class="line">    int front = 0, rear = 0;</span><br><span class="line">    TreeNode* root = new TreeNode;</span><br><span class="line">    root-&gt;val = atoi(strtok(input, ","));</span><br><span class="line">    root-&gt;left = root-&gt;right = NULL;</span><br><span class="line">    queue[rear++] = root;</span><br><span class="line"></span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; size) {</span><br><span class="line">        TreeNode* node = queue[front++];</span><br><span class="line">        char* in = strtok(NULL, ",");</span><br><span class="line"></span><br><span class="line">        if (strcmp(in, "null") != 0) {</span><br><span class="line">            node-&gt;left = new TreeNode;</span><br><span class="line">            node-&gt;left-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;left-&gt;left = node-&gt;left-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        in = strtok(NULL, ",");</span><br><span class="line">        if (i &lt; size &amp;&amp; strcmp(in, "null") != 0) {</span><br><span class="line">            node-&gt;right = new TreeNode;</span><br><span class="line">            node-&gt;right-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;right-&gt;left = node-&gt;right-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;right;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">}</span><br><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {</span><br><span class="line">    // 如果当前节点为空，或者是 p 或 q 中的一个，直接返回当前节点</span><br><span class="line">    if (root == nullptr || root == p || root == q) {</span><br><span class="line">        return root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 递归查找左子树中是否包含 p 或 q</span><br><span class="line">    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line"></span><br><span class="line">    // 递归查找右子树中是否包含 p 或 q</span><br><span class="line">    TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">    // 如果左右子树分别包含 p 和 q，则当前节点就是最近公共祖先</span><br><span class="line">    if (left &amp;&amp; right) {</span><br><span class="line">        return root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 否则，返回左子树或右子树中包含 p 或 q 的节点（或者返回nullptr）</span><br><span class="line">    return left ? left : right;</span><br><span class="line">}</span><br><span class="line">TreeNode* findNodeWithValue(TreeNode* root, int value) {</span><br><span class="line">    // 如果当前节点为空，或者找到了节点值为目标值，直接返回当前节点</span><br><span class="line">    if (root == nullptr || root-&gt;val == value) {</span><br><span class="line">        return root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 递归查找左子树</span><br><span class="line">    TreeNode* leftResult = findNodeWithValue(root-&gt;left, value);</span><br><span class="line"></span><br><span class="line">    // 如果在左子树中找到了目标节点，直接返回结果</span><br><span class="line">    if (leftResult != nullptr) {</span><br><span class="line">        return leftResult;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 否则，递归查找右子树</span><br><span class="line">    return findNodeWithValue(root-&gt;right, value);</span><br><span class="line">}</span><br><span class="line">int main() {</span><br><span class="line">    // 在这里你需要提供输入二叉树的方式，创建二叉树，然后调用 lowestCommonAncestor 函数进行测试</span><br><span class="line">    // 示例：</span><br><span class="line">    char input[256];</span><br><span class="line">        cin.getline(input, sizeof(input));</span><br><span class="line">        TreeNode* root = createTree(input);</span><br><span class="line">        int p0, p1;</span><br><span class="line">        cin &gt;&gt; p0 &gt;&gt; p1;</span><br><span class="line">    // TreeNode* root = createTree("3,5,1,6,2,0,8,null,null,7,4");</span><br><span class="line">       TreeNode* p = findNodeWithValue(root, p0);</span><br><span class="line">       TreeNode* q = findNodeWithValue(root, p1);</span><br><span class="line">       TreeNode* result = lowestCommonAncestor(root, p, q);</span><br><span class="line">       cout &lt;&lt;result-&gt;val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-恢复二叉搜索树"><a href="#6-恢复二叉搜索树" class="headerlink" title="6.恢复二叉搜索树"></a>6.恢复二叉搜索树</h3><p><strong>题目描述</strong><br>给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。</p>
<p><strong>输入描述</strong><br>给一个二叉树<br><strong>输出描述</strong><br>恢复这棵树</p>
<p><strong>输入输出样例</strong><br>输入<br>root = [1,3,null,null,2]<br>输出<br>[3,1,null,null,2]</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode {</span><br><span class="line">	    int val;</span><br><span class="line">	    TreeNode* left;</span><br><span class="line">	    TreeNode* right;</span><br><span class="line">	   // TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span><br><span class="line">	};</span><br><span class="line">TreeNode* createTree(char* input) {</span><br><span class="line">    if (strcmp(input, "null") == 0) {</span><br><span class="line">        return NULL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int size = 1;</span><br><span class="line">    for (int i = 0; i &lt; strlen(input); i++) {</span><br><span class="line">        if (input[i] == ',') {</span><br><span class="line">            size++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    TreeNode** queue = new TreeNode * [size];</span><br><span class="line">    int front = 0, rear = 0;</span><br><span class="line">    TreeNode* root = new TreeNode;</span><br><span class="line">    root-&gt;val = atoi(strtok(input, ","));</span><br><span class="line">    root-&gt;left = root-&gt;right = NULL;</span><br><span class="line">    queue[rear++] = root;</span><br><span class="line"></span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; size) {</span><br><span class="line">        TreeNode* node = queue[front++];</span><br><span class="line">        char* in = strtok(NULL, ",");</span><br><span class="line"></span><br><span class="line">        if (strcmp(in, "null") != 0) {</span><br><span class="line">            node-&gt;left = new TreeNode;</span><br><span class="line">            node-&gt;left-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;left-&gt;left = node-&gt;left-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        in = strtok(NULL, ",");</span><br><span class="line">        if (i &lt; size &amp;&amp; strcmp(in, "null") != 0) {</span><br><span class="line">            node-&gt;right = new TreeNode;</span><br><span class="line">            node-&gt;right-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;right-&gt;left = node-&gt;right-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;right;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">}</span><br><span class="line">void inorder(TreeNode* root, vector&lt;int&gt;&amp; nums) {</span><br><span class="line">    if (root == nullptr) {</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line">    inorder(root-&gt;left, nums);</span><br><span class="line">    nums.push_back(root-&gt;val);</span><br><span class="line">    inorder(root-&gt;right, nums);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pair&lt;int, int&gt; findTwoSwapped(vector&lt;int&gt;&amp; nums) {</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    int index1 = -1, index2 = -1;</span><br><span class="line">    for (int i = 0; i &lt; n - 1; ++i) {</span><br><span class="line">        if (nums[i + 1] &lt; nums[i]) {</span><br><span class="line">            index2 = i + 1;</span><br><span class="line">            if (index1 == -1) {</span><br><span class="line">                index1 = i;</span><br><span class="line">            }</span><br><span class="line">            else {</span><br><span class="line">                break;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    int x = nums[index1], y = nums[index2];</span><br><span class="line">    return { x, y };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void recover(TreeNode* r, int count, int x, int y) {</span><br><span class="line">    if (r != nullptr) {</span><br><span class="line">        if (r-&gt;val == x || r-&gt;val == y) {</span><br><span class="line">            r-&gt;val = r-&gt;val == x ? y : x;</span><br><span class="line">            if (--count == 0) {</span><br><span class="line">                return;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        recover(r-&gt;left, count, x, y);</span><br><span class="line">        recover(r-&gt;right, count, x, y);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void recoverTree(TreeNode* root) {</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    inorder(root, nums);</span><br><span class="line">    pair&lt;int, int&gt; swapped = findTwoSwapped(nums);</span><br><span class="line">    recover(root, 2, swapped.first, swapped.second);</span><br><span class="line">}</span><br><span class="line">string levelOrderTraversal(TreeNode* root) {</span><br><span class="line">        if (root == NULL) {</span><br><span class="line">            return "";</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        string result;</span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        result += to_string(root-&gt;val) + ",";</span><br><span class="line">        while (!nodeQueue.empty()) {</span><br><span class="line">            TreeNode* node = nodeQueue.front();</span><br><span class="line">            nodeQueue.pop();</span><br><span class="line">    </span><br><span class="line">            if (node-&gt;left != NULL) {</span><br><span class="line">                nodeQueue.push(node-&gt;left);</span><br><span class="line">                result += to_string(node-&gt;left-&gt;val) + ",";</span><br><span class="line">            }</span><br><span class="line">            else if (node-&gt;right) result += "null,";</span><br><span class="line">            else {</span><br><span class="line">                result += "null,";</span><br><span class="line">                result += "null,";</span><br><span class="line">            }</span><br><span class="line">            if (node-&gt;right != NULL) {</span><br><span class="line">                nodeQueue.push(node-&gt;right);</span><br><span class="line">                result += to_string(node-&gt;right-&gt;val) + ",";</span><br><span class="line">            }</span><br><span class="line">            else if (node-&gt;left) result += "null,";</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        if (!result.empty()) {</span><br><span class="line">            result.pop_back();  // 去除最后一个逗号</span><br><span class="line">        }</span><br><span class="line">        while (result[result.size() - 1] == 'l') {</span><br><span class="line">            result.pop_back();</span><br><span class="line">            result.pop_back();</span><br><span class="line">            result.pop_back();</span><br><span class="line">            result.pop_back();</span><br><span class="line">            result.pop_back();</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">	char input[256];</span><br><span class="line">	cin.getline(input, sizeof(input));</span><br><span class="line">	TreeNode* root = createTree(input);</span><br><span class="line">    recoverTree(root);</span><br><span class="line">    string output = levelOrderTraversal(root);</span><br><span class="line">    cout &lt;&lt; output;</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-奇偶树"><a href="#7-奇偶树" class="headerlink" title="7.奇偶树"></a>7.奇偶树</h3><p>如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：<br>二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。<br>偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增<br>奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减<br>给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。</p>
<p><strong>输入描述</strong><br>给一个二叉树<br><strong>输出描述</strong><br>判断是否是奇偶树</p>
<p><strong>输入输出样例</strong><br>输入<br>root = [1,10,4,3,null,7,9,12,8,6,null,null,2]<br>输出<br>true</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">bool isEvenOddTree(TreeNode* root) {</span><br><span class="line">    queue&lt;TreeNode*&gt; qu;</span><br><span class="line">    qu.push(root);</span><br><span class="line">    int level = 0;</span><br><span class="line">    while (!qu.empty()) {</span><br><span class="line">        int size = qu.size();</span><br><span class="line">        int prev = level % 2 == 0 ? INT_MIN : INT_MAX;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) {</span><br><span class="line">            TreeNode* node = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            int value = node-&gt;val;</span><br><span class="line">            if (level % 2 == value % 2) {</span><br><span class="line">                return false;</span><br><span class="line">            }</span><br><span class="line">            if ((level % 2 == 0 &amp;&amp; value &lt;= prev) || (level % 2 == 1 &amp;&amp; value &gt;= prev)) {</span><br><span class="line">                return false;</span><br><span class="line">            }</span><br><span class="line">            prev = value;</span><br><span class="line">            if (node-&gt;left != nullptr) {</span><br><span class="line">                qu.push(node-&gt;left);</span><br><span class="line">            }</span><br><span class="line">            if (node-&gt;right != nullptr) {</span><br><span class="line">                qu.push(node-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        level++;</span><br><span class="line">    }</span><br><span class="line">    return true;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-二叉树的子树大小"><a href="#8-二叉树的子树大小" class="headerlink" title="8.二叉树的子树大小"></a>8.二叉树的子树大小</h3><p>描述</p>
<p>现在给出一棵二叉树，希望你输出它的每一个结点为根的子树大小</p>
<p>输入</p>
<p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。<br>接下来 n 行，每行两个正整数 li, ri ​ ，分别表示节点 i 的左右孩子的编号。如果不存在左 / 右孩子，则以 −1 表示。两个数之间用一个空格隔开。</p>
<p>输出</p>
<p>一行，n个数，分别表示i号结点为根的子树的子树大小</p>
<p>样例</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">-1 -1</span><br><span class="line">-1 -1</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span></span><br><span class="line">    <span class="type">int</span> leftChild;</span><br><span class="line">    <span class="type">int</span> rightChild;</span><br><span class="line">} TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归计算以指定节点为根的子树大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">calculateSubtreeSize</span><span class="params">(TreeNode tree[], <span class="type">int</span> node)</span> {</span><br><span class="line">    <span class="comment">// 如果节点为空，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="number">-1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算左右子树大小</span></span><br><span class="line">    <span class="type">int</span> leftSize = calculateSubtreeSize(tree, tree[node].leftChild);</span><br><span class="line">    <span class="type">int</span> rightSize = calculateSubtreeSize(tree, tree[node].rightChild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以当前节点为根的子树大小（包括当前节点）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + leftSize + rightSize;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建二叉树节点数组</span></span><br><span class="line">    TreeNode* tree = (TreeNode*)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取每个节点的左右孩子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;tree[i].leftChild, &amp;tree[i].rightChild);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并输出每个节点为根的子树大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="type">int</span> subtreeSize = calculateSubtreeSize(tree, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, subtreeSize);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="9-二叉树的子树和"><a href="#9-二叉树的子树和" class="headerlink" title="9.二叉树的子树和"></a>9.二叉树的子树和</h3><p>现在给出一棵二叉树，每个结点有一个权值，希望你依次输出每一个节点为根的子树的子树权值和</p>
<p>输入</p>
<p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。<br>第二行 n 个正整数，用一个空格分隔，第 i 个正整数vi，代表节点 i 的权值。<br>接下来 n 行，每行两个正整数 li, ri ​ ，分别表示节点 i 的左右孩子的编号。如果不存在左 / 右孩子，则以 −1 表示。两个数之间用一个空格隔开。</p>
<p>输出</p>
<p>一行，n个数，分别表示i号结点为根的子树的子树权值和</p>
<p>样例</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1000 1000</span><br><span class="line">2 3</span><br><span class="line">-1 -1</span><br><span class="line">-1 -1</span><br></pre></td></tr></tbody></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2001 1000 1000</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> leftChild;</span><br><span class="line">    <span class="type">int</span> rightChild;</span><br><span class="line">} TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归计算以指定节点为根的子树权值和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">calculateSubtreeSum</span><span class="params">(TreeNode tree[], <span class="type">int</span> node, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="comment">// 如果节点为空，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="number">-1</span> || node &gt; n) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算左右子树权值和</span></span><br><span class="line">    <span class="type">int</span> leftSum = calculateSubtreeSum(tree, tree[node].leftChild, n);</span><br><span class="line">    <span class="type">int</span> rightSum = calculateSubtreeSum(tree, tree[node].rightChild, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以当前节点为根的子树权值和（包括当前节点）</span></span><br><span class="line">    <span class="keyword">return</span> tree[node].value + leftSum + rightSum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建二叉树节点数组</span></span><br><span class="line">    TreeNode* tree = (TreeNode*)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取每个节点的权值和左右孩子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tree[i].value);</span><br><span class="line">       </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;tree[i].leftChild, &amp;tree[i].rightChild);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 计算并输出每个节点为根的子树权值和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="type">int</span> subtreeSum = calculateSubtreeSum(tree, i, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, subtreeSum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-确定树的形态"><a href="#10-确定树的形态" class="headerlink" title="10.确定树的形态"></a>10.确定树的形态</h3><p>现在给出一棵二叉树的前序遍历和后序遍历，输出树的后序遍历</p>
<p>输入</p>
<p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。<br>第二行 n 个正整数，用一个空格分隔，代表二叉树的前序遍历<br>第三行 n 个正整数，用一个空格分隔，代表二叉树的中序遍历</p>
<p>输出</p>
<p>一行，n个数，用一个空格分隔，表示二叉树的后序遍历</p>
<p>样例</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3 </span><br><span class="line">2 1 3</span><br></pre></td></tr></tbody></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2 3 1</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">} TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据前序遍历和中序遍历构建二叉树</span></span><br><span class="line">TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span> pre[], <span class="type">int</span> in[], <span class="type">int</span> startPre, <span class="type">int</span> endPre, <span class="type">int</span> startIn, <span class="type">int</span> endIn)</span> {</span><br><span class="line">    <span class="keyword">if</span> (startPre &gt; endPre || startIn &gt; endIn) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建根节点</span></span><br><span class="line">    TreeNode* root = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    root-&gt;data = pre[startPre];</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在中序遍历中找到根节点的位置</span></span><br><span class="line">    <span class="type">int</span> rootIndex;</span><br><span class="line">    <span class="keyword">for</span> (rootIndex = startIn; rootIndex &lt;= endIn; rootIndex++) {</span><br><span class="line">        <span class="keyword">if</span> (in[rootIndex] == pre[startPre]) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> leftSize = rootIndex - startIn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归构建左子树和右子树</span></span><br><span class="line">    root-&gt;left = buildTree(pre, in, startPre + <span class="number">1</span>, startPre + leftSize, startIn, rootIndex - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = buildTree(pre, in, startPre + leftSize + <span class="number">1</span>, endPre, rootIndex + <span class="number">1</span>, endIn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历输出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode* root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历左子树</span></span><br><span class="line">    postOrder(root-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历右子树</span></span><br><span class="line">    postOrder(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出根节点的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;data);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取前序遍历和中序遍历</span></span><br><span class="line">    <span class="type">int</span>* pre = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span>* in = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建二叉树</span></span><br><span class="line">    TreeNode* root = buildTree(pre, in, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出后序遍历</span></span><br><span class="line">    postOrder(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(pre);</span><br><span class="line">    <span class="built_in">free</span>(in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="11-哈夫曼树的带权路径长"><a href="#11-哈夫曼树的带权路径长" class="headerlink" title="11.哈夫曼树的带权路径长"></a>11.哈夫曼树的带权路径长</h3><p>现在给出一棵二叉树，每个结点有一个权值，希望你构造赫夫曼树，并输出其对应的带权路径长度</p>
<p>输入</p>
<p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n。<br>第二行 n 个正整数，用一个空格分隔，第 i 个正整数vi，代表节点 i 的权值。</p>
<p>输出</p>
<p>一个数，表示对应赫夫曼树的带权路径长度</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义二叉树节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> {</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TreeNode</span>* left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TreeNode</span>* right;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新的节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> weight)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TreeNode</span>* node = (<span class="keyword">struct</span> TreeNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">	node-&gt;weight = weight;</span><br><span class="line">	node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小堆的数据结构的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeap</span> {</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="type">int</span> capacity;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TreeNode</span>** array;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//创建一个新的最小堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeap</span>* <span class="built_in">createMinHeap</span>(<span class="type">int</span> capacity)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">MinHeap</span>* minHeap = (<span class="keyword">struct</span> MinHeap*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> MinHeap));</span><br><span class="line">	minHeap-&gt;size = <span class="number">0</span>;</span><br><span class="line">	minHeap-&gt;capacity = capacity;</span><br><span class="line">	minHeap-&gt;array = (<span class="keyword">struct</span> TreeNode**)<span class="built_in">malloc</span>(capacity * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode*));</span><br><span class="line">	<span class="keyword">return</span> minHeap;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 交换两个节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapNodes</span><span class="params">(<span class="keyword">struct</span> TreeNode** a, <span class="keyword">struct</span> TreeNode** b)</span> </span>{</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TreeNode</span>* t = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = t;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 最小堆的下沉操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">minHeapify</span><span class="params">(<span class="keyword">struct</span> MinHeap* minHeap, <span class="type">int</span> index)</span> </span>{</span><br><span class="line">    <span class="type">int</span> smallest = index;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; minHeap-&gt;size &amp;&amp; minHeap-&gt;array[left]-&gt;weight &lt; minHeap-&gt;array[smallest]-&gt;weight)</span><br><span class="line">        smallest = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &lt; minHeap-&gt;size &amp;&amp; minHeap-&gt;array[right]-&gt;weight &lt; minHeap-&gt;array[smallest]-&gt;weight)</span><br><span class="line">        smallest = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (smallest != index) {</span><br><span class="line">        <span class="built_in">swapNodes</span>(&amp;minHeap-&gt;array[smallest], &amp;minHeap-&gt;array[index]);</span><br><span class="line">        <span class="built_in">minHeapify</span>(minHeap, smallest);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为叶子节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLeaf</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> !(root-&gt;left) &amp;&amp; !(root-&gt;right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建最小堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeap</span>* <span class="built_in">buildMinHeap</span>(<span class="type">int</span> weights[], <span class="type">int</span> size) {</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MinHeap</span>* minHeap = <span class="built_in">createMinHeap</span>(size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) {</span><br><span class="line">        minHeap-&gt;array[i] = <span class="built_in">createNode</span>(weights[i]);</span><br><span class="line">    }</span><br><span class="line">    minHeap-&gt;size = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) {</span><br><span class="line">        <span class="built_in">minHeapify</span>(minHeap, i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minHeap;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最小堆中提取最小值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">extractMin</span>(<span class="keyword">struct</span> MinHeap* minHeap) {</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* temp = minHeap-&gt;array[<span class="number">0</span>];</span><br><span class="line">    minHeap-&gt;array[<span class="number">0</span>] = minHeap-&gt;array[minHeap-&gt;size - <span class="number">1</span>];</span><br><span class="line">    --minHeap-&gt;size;</span><br><span class="line">    <span class="built_in">minHeapify</span>(minHeap, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新节点到最小堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertMinHeap</span><span class="params">(<span class="keyword">struct</span> MinHeap* minHeap, <span class="keyword">struct</span> TreeNode* node)</span> </span>{</span><br><span class="line">    ++minHeap-&gt;size;</span><br><span class="line">    <span class="type">int</span> i = minHeap-&gt;size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; node-&gt;weight &lt; minHeap-&gt;array[(i - <span class="number">1</span>) / <span class="number">2</span>]-&gt;weight) {</span><br><span class="line">        minHeap-&gt;array[i] = minHeap-&gt;array[(i - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    minHeap-&gt;array[i] = node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建赫夫曼树</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">buildHuffmanTree</span>(<span class="type">int</span> weights[], <span class="type">int</span> size) {</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* left, * right, * top;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MinHeap</span>* minHeap = <span class="built_in">buildMinHeap</span>(weights, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (minHeap-&gt;size &gt; <span class="number">1</span>) {</span><br><span class="line">        left = <span class="built_in">extractMin</span>(minHeap);</span><br><span class="line">        right = <span class="built_in">extractMin</span>(minHeap);</span><br><span class="line"></span><br><span class="line">        top = <span class="built_in">createNode</span>(left-&gt;weight + right-&gt;weight);</span><br><span class="line">        top-&gt;left = left;</span><br><span class="line">        top-&gt;right = right;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">insertMinHeap</span>(minHeap, top);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">extractMin</span>(minHeap);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算带权路径长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculateWPL</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> depth)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isLeaf</span>(root))</span><br><span class="line">        <span class="keyword">return</span> root-&gt;weight * depth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">calculateWPL</span>(root-&gt;left, depth + <span class="number">1</span>) + <span class="built_in">calculateWPL</span>(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> weights[<span class="number">10000</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	{</span><br><span class="line">		cin &gt;&gt; weights[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TreeNode</span>* root = <span class="built_in">buildHuffmanTree</span>(weights, n);</span><br><span class="line">	<span class="type">int</span> wpl = <span class="built_in">calculateWPL</span>(root, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; wpl &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">实验 </span><br><span class="line">实验题目：排序</span><br><span class="line"></span><br><span class="line">实验目的：</span><br><span class="line">掌握各种排序方法的基本思想、排序过程、算法实现，能进行时间和空间性能的分析，根据实际问题的特点和要求选择合适的排序方法。</span><br><span class="line"></span><br><span class="line">实验要求：</span><br><span class="line">实现直接排序、冒泡、直接选择、快速、堆、归并排序算法。比较各种算法的运行速度。</span><br><span class="line"></span><br><span class="line">实验主要步骤：</span><br><span class="line"></span><br><span class="line">实验代码</span><br><span class="line"></span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include"stdio.h"</span><br><span class="line">#include"stdlib.h"</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define Max 100         //假设文件长度</span><br><span class="line">typedef struct {         //定义记录类型</span><br><span class="line">    int key;            //关键字项</span><br><span class="line">}RecType;</span><br><span class="line">typedef RecType SeqList[Max + 1]; //SeqList为顺序表，表中第0个元素作为哨兵</span><br><span class="line">int n;                 //顺序表实际的长度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//==========直接插入排序法======</span><br><span class="line">void InsertSort(SeqList R)</span><br><span class="line">{       //对顺序表R中的记录R[1‥n]按递增序进行插入排序</span><br><span class="line">    int i, j;</span><br><span class="line">    for (i = 2; i &lt;= n; ++i)</span><br><span class="line">        if (R[i].key &lt; R[i - 1].key)//将L.r[i]插入有序子表</span><br><span class="line">        {</span><br><span class="line">            R[0] = R[i]; // 复制为哨兵</span><br><span class="line">            R[i] = R[i - 1];</span><br><span class="line">            for (j = i - 2; R[0].key &lt; R[j].key; --j)</span><br><span class="line">                R[j + 1] = R[j]; // 记录后移 </span><br><span class="line">            R[j + 1] = R[0]; //插入到正确位置</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//==========冒泡排序======= </span><br><span class="line">typedef enum { FALSE, TRUE } Boolean;  //FALSE为0，TRUE为1</span><br><span class="line">void BubbleSort(SeqList R) {             //自下向上扫描对R做冒泡排序</span><br><span class="line">    int i, j,num;     Boolean exchange;     //交换标志</span><br><span class="line">    for (i = 1; i &lt; n; i++) {    //最多做n-1趟排序</span><br><span class="line">        exchange = FALSE;       //本趟排序开始前，交换标志应为假</span><br><span class="line">        for (j = n - 1; j &gt;= i; j--)       //对当前无序区R[i‥n] 自下向上扫描</span><br><span class="line">            if (R[j + 1].key &lt; R[j].key) {    //两两比较，满足条件交换记录</span><br><span class="line">                num = R[j].key;</span><br><span class="line">                R[j].key = R[j + 1].key;</span><br><span class="line">                R[j + 1].key = num;</span><br><span class="line">                    exchange = TRUE;         //发生了交换，故将交换标志置为真</span><br><span class="line">            }</span><br><span class="line">        if (!exchange)           //本趟排序未发生交换，提前终止算法</span><br><span class="line">            return;</span><br><span class="line">    }//	endfor（为循环）</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//1.========一次划分函数=====</span><br><span class="line">int Partition(SeqList R, int i, int j)</span><br><span class="line">{</span><br><span class="line">    int pivotkey = R[i].key;//   对R[i‥j]做一次划分，并返回基准记录的位置</span><br><span class="line">    RecType pivot = R[i];    //用第一个记录作为基准</span><br><span class="line">    while (i &lt; j) {  </span><br><span class="line">        while (i &lt; j &amp;&amp; R[j].key &gt;= pivotkey)  --j;</span><br><span class="line">       R[i] =R[j];</span><br><span class="line">        while (i &lt; j &amp;&amp; R[i].key &lt;= pivotkey)  ++i;</span><br><span class="line">        R[j] =R[i];</span><br><span class="line">        //从区间两端交替向中间扫描，直到i=j</span><br><span class="line">       </span><br><span class="line">    }</span><br><span class="line">    R[i] = pivot;    //此时，i=j，基准记录已被最后定位</span><br><span class="line">    return i;      //返回基准记录的位置</span><br><span class="line">}</span><br><span class="line">//2.=====快速排序===========</span><br><span class="line">void QuickSort(SeqList R, int low, int high)</span><br><span class="line">{                 //R[low..high]快速排序</span><br><span class="line">    int pivotpos;            //划分后基准记录的位置</span><br><span class="line">    if (low &lt; high) {           //仅当区间长度大于1时才排序</span><br><span class="line">        pivotpos = Partition(R, low, high);  //对R[low..high]做一次划分，得到基准记录的位置</span><br><span class="line">        QuickSort(R, low, pivotpos - 1);       //对左区间递归排序</span><br><span class="line">        QuickSort(R, pivotpos + 1, high);      //对右区间递归排序</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//======直接选择排序========</span><br><span class="line">void SelectSort(SeqList R)</span><br><span class="line">{</span><br><span class="line">    int i, j, k;</span><br><span class="line">    for (i = 1; i &lt; n; i++) {         //做第i趟排序（1≤i≤n-1）</span><br><span class="line">        k = i;</span><br><span class="line">        for (j = i + 1; j &lt;= n; j++)</span><br><span class="line">        {</span><br><span class="line">            if (R[j].key &lt; R[k].key)</span><br><span class="line">            {</span><br><span class="line">                k = j;</span><br><span class="line">            }</span><br><span class="line">        } </span><br><span class="line">        if (k != i)</span><br><span class="line">        {</span><br><span class="line">            int temp = R[i].key;</span><br><span class="line">            R[i].key = R[k].key;</span><br><span class="line">            R[k].key = temp;</span><br><span class="line"></span><br><span class="line">        }//endif</span><br><span class="line">    } //endfor</span><br><span class="line">}</span><br><span class="line">//==========大根堆调整函数=======</span><br><span class="line">void Heapify(SeqList R, int low, int high)</span><br><span class="line">{</span><br><span class="line">    int i = low;</span><br><span class="line">    int j = 2 * i;</span><br><span class="line">    RecType temp = R[i];</span><br><span class="line">    while (j &lt;= high)</span><br><span class="line">    {</span><br><span class="line">        if (j &lt; high &amp;&amp; R[j].key &lt; R[j + 1].key)</span><br><span class="line">        {</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        if (temp.key &gt;= R[j].key)</span><br><span class="line">        {</span><br><span class="line">            break;</span><br><span class="line">        }</span><br><span class="line">        R[i] = R[j];</span><br><span class="line">        i = j;</span><br><span class="line">        j = 2 * i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    R[i] = temp;</span><br><span class="line">}</span><br><span class="line">//==========构造大根堆==========</span><br><span class="line">void BuildHeap(SeqList R,int n)</span><br><span class="line">{</span><br><span class="line">    for (int i = n / 2; i &gt;= 1; i--)</span><br><span class="line">    {</span><br><span class="line">        Heapify(R, i, n);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">//==========堆排序===========</span><br><span class="line">void HeapSort(SeqList R)</span><br><span class="line">{</span><br><span class="line">    BuildHeap(R,n);</span><br><span class="line">    // 依次将堆顶元素与末尾元素交换并重新调整堆</span><br><span class="line">    for (int i = n; i &gt; 1; i--) {</span><br><span class="line">        swap(R[1], R[i]); // 将堆顶元素（最大值）与末尾元素交换</span><br><span class="line">        Heapify(R, 1, i - 1); // 调整堆</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//=====将两个有序的子序列R[low..m]和R[m+1..high]归并成有序的序列R[low..high]==</span><br><span class="line">void Merge(SeqList R, int low, int m, int high)</span><br><span class="line">{</span><br><span class="line">    int i = low, j = m + 1, k = 0;</span><br><span class="line">    SeqList temp;</span><br><span class="line">    while (i &lt;= m &amp;&amp; j &lt;= high)</span><br><span class="line">    {</span><br><span class="line">        if (R[i].key &lt;= R[j].key) {</span><br><span class="line">            temp[++k] = R[i++];</span><br><span class="line">        }</span><br><span class="line">        else {</span><br><span class="line">            temp[++k] = R[j++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    while (i &lt;= m) {</span><br><span class="line">        temp[++k] = R[i++];</span><br><span class="line">    }</span><br><span class="line">    while (j &lt;= high) {</span><br><span class="line">        temp[++k] = R[j++];</span><br><span class="line">    }</span><br><span class="line">    for (i = 1, j = low; i &lt;= k; ++i, ++j)</span><br><span class="line">    {</span><br><span class="line">        R[j] = temp[i];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">//=========对R[1..n]做一趟归并排序========</span><br><span class="line">void MergePass(SeqList R, int length)</span><br><span class="line">{</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 1; i + 2 * length - 1 &lt;= n; i += 2 * length)</span><br><span class="line">    {</span><br><span class="line">        Merge(R, i, i + length - 1, i + 2 * length - 1);</span><br><span class="line">    }</span><br><span class="line">    if (i + length - 1 &lt; n) {</span><br><span class="line">        Merge(R, i, i + length - 1, n);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">//========== 自底向上对R[1..n]做二路归并排序===============</span><br><span class="line">void MergeSort(SeqList R)</span><br><span class="line">{</span><br><span class="line">    int length;</span><br><span class="line">    for (length = 1; length &lt; n; length *= 2)     //做[lgn]趟排序</span><br><span class="line">        MergePass(R, length);     //有序长度≥n时终止</span><br><span class="line">}</span><br><span class="line">//==========输入顺序表========</span><br><span class="line">void input_int(SeqList R)</span><br><span class="line">{</span><br><span class="line">    int i;</span><br><span class="line">    printf("Please input num(int):");</span><br><span class="line">    scanf("%d", &amp;n);</span><br><span class="line">    printf("Plase input %d integer:", n);</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">        scanf("%d", &amp;R[i].key);</span><br><span class="line">}</span><br><span class="line">//==========输出顺序表========</span><br><span class="line">void output_int(SeqList R)</span><br><span class="line">{</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">        printf("%4d", R[i].key);</span><br><span class="line">}</span><br><span class="line">//==========主函数======</span><br><span class="line">void main()</span><br><span class="line">{</span><br><span class="line">    int i;</span><br><span class="line">    SeqList R;</span><br><span class="line">    input_int(R);</span><br><span class="line">    printf("\t******** Select **********\n");</span><br><span class="line">    printf("\t1: Insert Sort\n");</span><br><span class="line">    printf("\t2: Bubble Sort\n");</span><br><span class="line">    printf("\t3: Quick Sort\n");</span><br><span class="line">    printf("\t4: Straight Selection Sort\n");</span><br><span class="line">    printf("\t5: Heap Sort\n");</span><br><span class="line">    printf("\t6: Merge Sort\n");</span><br><span class="line">    printf("\t7: Exit\n");</span><br><span class="line">    printf("\t***************************\n");</span><br><span class="line">    scanf("%d", &amp;i);   //输入整数1-7，选择排序方式</span><br><span class="line">    switch (i) {</span><br><span class="line">    case 1: InsertSort(R); break;       //值为1，直接插入排序</span><br><span class="line">    case 2: BubbleSort(R); break;       //值为2，冒泡法排序</span><br><span class="line">    case 3: QuickSort(R, 1, n); break;    //值为3，快速排序</span><br><span class="line">    case 4: SelectSort(R); break;       //值为4，直接选择排序</span><br><span class="line">    case 5: HeapSort(R); break;         //值为5，堆排序</span><br><span class="line">    case 6: MergeSort(R); break;        //值为6，归并排序</span><br><span class="line">    case 7: exit(0);                    //值为7，结束程序</span><br><span class="line">    }</span><br><span class="line">    printf("Sort reult:");</span><br><span class="line">    output_int(R);</span><br><span class="line">}</span><br><span class="line">实验结果：</span><br><span class="line">1.直接插入排序  输入 15 2 13 33 3 5 9 14 11 22</span><br><span class="line"></span><br><span class="line">2.冒泡排序</span><br><span class="line"></span><br><span class="line">3.快速排序</span><br><span class="line"></span><br><span class="line">4.直接选择排序</span><br><span class="line"></span><br><span class="line">5.堆排序</span><br><span class="line"></span><br><span class="line">6.归并排序</span><br><span class="line"></span><br><span class="line">运行速度比较：</span><br><span class="line"></span><br><span class="line">1.直接插入排序</span><br><span class="line">时间复杂度为 o(n2)</span><br><span class="line">空间复杂度为 o(1)</span><br><span class="line"></span><br><span class="line">2.冒泡排序</span><br><span class="line">时间复杂度为 o(n2)</span><br><span class="line">空间复杂度为 o(1)</span><br><span class="line"></span><br><span class="line">3.快速排序</span><br><span class="line">时间效率：O(nlog2n) —每趟确定的元素呈指数增加</span><br><span class="line">空间效率：</span><br><span class="line">O（log2n）—递归要用到栈空间</span><br><span class="line"></span><br><span class="line">4.直接选择排序</span><br><span class="line">直接插入排序的平均时间复杂度为O(n2）</span><br><span class="line">因此空间复杂度为：O(1) </span><br><span class="line">5.堆排序</span><br><span class="line">时间效率：O(nlog2n) </span><br><span class="line">空间效率：O（1）</span><br><span class="line">6.归并排序</span><br><span class="line">时间复杂度O(nlog2n)</span><br><span class="line">空间复杂度O（n）</span><br></pre></td></tr></tbody></table></figure>



<h3 id="1-直接插入排序"><a href="#1-直接插入排序" class="headerlink" title="1.直接插入排序"></a>1.直接插入排序</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">void insertionSort(int arr[], int n) {</span><br><span class="line">    int i, key, j;</span><br><span class="line">    for (i = 1; i &lt; n; i++) {</span><br><span class="line">        key = arr[i];</span><br><span class="line">        j = i - 1;</span><br><span class="line"></span><br><span class="line">        // 将 arr[0...i-1] 中大于 key 的元素都向右移动一个位置</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {</span><br><span class="line">            arr[j + 1] = arr[j];</span><br><span class="line">            j = j - 1;</span><br><span class="line">        }</span><br><span class="line">        // 插入 key 到正确的位置</span><br><span class="line">        arr[j + 1] = key;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-折半排序"><a href="#2-折半排序" class="headerlink" title="2.折半排序"></a>2.折半排序</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">void binaryInsertionSort(int arr[], int n) {</span><br><span class="line">    int i, key, j, low, high, mid;</span><br><span class="line"></span><br><span class="line">    for (i = 1; i &lt; n; i++) {</span><br><span class="line">        key = arr[i];</span><br><span class="line">        low = 0;</span><br><span class="line">        high = i - 1;</span><br><span class="line"></span><br><span class="line">        // 使用二分查找找到插入位置</span><br><span class="line">        while (low &lt;= high) {</span><br><span class="line">            mid = (low + high) / 2;</span><br><span class="line">            if (arr[mid] &gt; key)</span><br><span class="line">                high = mid - 1;</span><br><span class="line">            else</span><br><span class="line">                low = mid + 1;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 移动元素，插入到正确位置</span><br><span class="line">        for (j = i - 1; j &gt;= low; j--)</span><br><span class="line">            arr[j + 1] = arr[j];</span><br><span class="line"></span><br><span class="line">        arr[low] = key;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h3 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3.希尔排序"></a>3.希尔排序</h3><p>1.分步骤，直接排</p>
<p>2.有间隔，用dk表示跳跃的间隔，最后dk一定为1</p>
<p>3.不稳定</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">void shellSort(int arr[], int n) {</span><br><span class="line">    for (int gap = n / 2; gap &gt; 0; gap /= 2) {</span><br><span class="line">        for (int i = gap; i &lt; n; i++) {</span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            int j;</span><br><span class="line">            for (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap)</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h3 id="4-交换排序"><a href="#4-交换排序" class="headerlink" title="4.交换排序"></a>4.交换排序</h3><h4 id="4-1冒泡排序（起泡排序）"><a href="#4-1冒泡排序（起泡排序）" class="headerlink" title="4.1冒泡排序（起泡排序）"></a>4.1冒泡排序（起泡排序）</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">void bubbleSort(int arr[], int n) {</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++) {</span><br><span class="line">        for (int j = 0; j &lt; n - i - 1; j++) {</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) {</span><br><span class="line">                // 交换 arr[j] 和 arr[j+1]</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>





<h3 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.快速排序"></a>5.快速排序</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int partition(int arr[], int low, int high) {</span><br><span class="line">    int pivot = arr[high];</span><br><span class="line">    int i = (low - 1);</span><br><span class="line"></span><br><span class="line">    for (int j = low; j &lt;= high - 1; j++) {</span><br><span class="line">        if (arr[j] &lt; pivot) {</span><br><span class="line">            i++;</span><br><span class="line">            // 交换 arr[i] 和 arr[j]</span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    // 交换 arr[i + 1] 和 arr[high]</span><br><span class="line">    int temp = arr[i + 1];</span><br><span class="line">    arr[i + 1] = arr[high];</span><br><span class="line">    arr[high] = temp;</span><br><span class="line">    return (i + 1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void quickSort(int arr[], int low, int high) {</span><br><span class="line">    if (low &lt; high) {</span><br><span class="line">        int pi = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">        quickSort(arr, low, pi - 1);</span><br><span class="line">        quickSort(arr, pi + 1, high);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-简单选择排序"><a href="#6-简单选择排序" class="headerlink" title="6.简单选择排序"></a>6.简单选择排序</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">void selectionSort(int arr[], int n) {</span><br><span class="line">    int i, j, minIndex;</span><br><span class="line">    for (i = 0; i &lt; n - 1; i++) {</span><br><span class="line">        minIndex = i;</span><br><span class="line">        for (j = i + 1; j &lt; n; j++)</span><br><span class="line">            if (arr[j] &lt; arr[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line"></span><br><span class="line">        // 交换 arr[i] 和 arr[minIndex]</span><br><span class="line">        int temp = arr[minIndex];</span><br><span class="line">        arr[minIndex] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h3 id="7-树形选择排序（锦标赛ghp-9yymKPfuZyP90Ic46ZIGEhZpjOTDP54cat4B"><a href="#7-树形选择排序（锦标赛ghp-9yymKPfuZyP90Ic46ZIGEhZpjOTDP54cat4B" class="headerlink" title="7.树形选择排序（锦标赛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"></a>7.树形选择排序（锦标赛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</h3><h3 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="8.堆排序"></a>8.堆排序</h3><p><strong>堆排序</strong>是一种树形选择排序，在排序过程中，将待排序的记录r[1..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序序列中选择关键字最大（或最小）的记录。</p>
<p>如果将序列看成一个完全二叉树，非叶子结点的值均小于（上面左边不等式）或大于（上面右边不等式）左右孩子结点的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312071626515.png" alt="image-20231207162654394"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">void heapify(int arr[], int n, int i) {</span><br><span class="line">    int largest = i;</span><br><span class="line">    int left = 2 * i + 1;</span><br><span class="line">    int right = 2 * i + 2;</span><br><span class="line"></span><br><span class="line">    if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line"></span><br><span class="line">    if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line"></span><br><span class="line">    if (largest != i) {</span><br><span class="line">        // 交换 arr[i] 和 arr[largest]</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line"></span><br><span class="line">        heapify(arr, n, largest);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void heapSort(int arr[], int n) {</span><br><span class="line">    for (int i = n / 2 - 1; i &gt;= 0; i--)</span><br><span class="line">        heapify(arr, n, i);</span><br><span class="line"></span><br><span class="line">    for (int i = n - 1; i &gt; 0; i--) {</span><br><span class="line">        // 交换 arr[0] 和 arr[i]</span><br><span class="line">        int temp = arr[0];</span><br><span class="line">        arr[0] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line"></span><br><span class="line">        heapify(arr, i, 0);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="9-外部排序"><a href="#9-外部排序" class="headerlink" title="9.外部排序"></a>9.外部排序</h3><h4 id="外排的基本方法"><a href="#外排的基本方法" class="headerlink" title="外排的基本方法"></a>外排的基本方法</h4><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\image-20231214082134736.png" alt="image-20231214082134736"></p>
<h4 id="胜者树ghp-Te68DICI21MITinvYONIbo4DB2ImNo3yPNHW"><a href="#胜者树ghp-Te68DICI21MITinvYONIbo4DB2ImNo3yPNHW" class="headerlink" title="胜者树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"></a>胜者树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</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140827871.png" alt="image-20231214082755792"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140828711.png" alt="image-20231214082841635"></p>
<h4 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140828894.png" alt="image-20231214082857798"></p>
<h3 id="置换选择排序"><a href="#置换选择排序" class="headerlink" title="置换选择排序"></a>置换选择排序</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140829406.png" alt="image-20231214082947332"></p>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140830118.png" alt="image-20231214083002042"></p>
<h4 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140832733.png" alt="image-20231214083216645"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140835160.png" alt="image-20231214083515080"></p>
<h3 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140841982.png" alt="image-20231214084145898"></p>
<p>不稳定：希尔排序，快速排序，堆排序</p>
<p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140849845.png" alt="image-20231214084947762"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140850880.png" alt="image-20231214085000801"></p>
<h2 id="查找题库"><a href="#查找题库" class="headerlink" title="查找题库"></a>查找题库</h2><h3 id="1-找最小值"><a href="#1-找最小值" class="headerlink" title="1.找最小值"></a>1.找最小值</h3><p>用的直接比较</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	int min = 1e5;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	int arr[10000];</span><br><span class="line">	int number;</span><br><span class="line">	int m = 0;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	{</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	}</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	{</span><br><span class="line">		if (min &gt; arr[i])</span><br><span class="line">		{</span><br><span class="line">			min = arr[i];</span><br><span class="line"></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; min;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	int n,m;</span><br><span class="line">	cin &gt;&gt; n&gt;&gt;m;</span><br><span class="line">	int arr[120];</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	{</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	}</span><br><span class="line">	int inquire[120];</span><br><span class="line">	int len = 0;</span><br><span class="line">	for (int i = 0; i&lt;m; i++)</span><br><span class="line">	{</span><br><span class="line">		cin &gt;&gt; inquire[i];</span><br><span class="line">		len++;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; len; i++)</span><br><span class="line">	{</span><br><span class="line">		int flag = -1;</span><br><span class="line">		for (int j = 0; j &lt; n; j++)</span><br><span class="line">		{</span><br><span class="line">			if (inquire[i] == arr[j])</span><br><span class="line">			{</span><br><span class="line">				flag = j+1;</span><br><span class="line">				break;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; flag&lt;&lt;" ";</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-A-B数对"><a href="#3-A-B数对" class="headerlink" title="3.A-B数对"></a>3.A-B数对</h3><p>描述<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P1102">P1102 A-B 数对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>给出一串单调不下降的数以及一个数字 C，要求计算出所有A−B=C 的数对的个数（不同位置的数字一样的数对算不同的数对）。</p>
<p>输入</p>
<p>输入共两行。</p>
<p>第一行，两个整数 N,C。</p>
<p>第二行，N个整数，作为要求处理的那串数。</p>
<p>输出</p>
<p>一行，表示该串数中包含的满足A−B=C 的数对的个数。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">    #include &lt;map&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">    typedef long long LL;</span><br><span class="line">    LL a[200001];</span><br><span class="line">    map&lt;LL,LL&gt; m;//建立一个数字到出现次数的映射 map&lt;num,times&gt;</span><br><span class="line">    //A-B=C --&gt; A-C=B</span><br><span class="line">    int main() {</span><br><span class="line">        int n;</span><br><span class="line">        LL c;</span><br><span class="line">        LL ans=0;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">        for(int i=1;i&lt;=n;i++) {</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            m[a[i]]++;</span><br><span class="line">            a[i]-=c;    </span><br><span class="line">        } </span><br><span class="line">        for(int i=1;i&lt;=n;i++) ans+=m[a[i]];</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-普通二叉树"><a href="#4-普通二叉树" class="headerlink" title="4.普通二叉树"></a>4.普通二叉树</h3><p>您需要写一种数据结构，来维护一些数（都是 1e9 以内的数字）的集合，最开始时集合是空的。其中需要提供以下操作，操作次数 q 不超过 104：</p>
<ol>
<li>查询值为x的数的排名（排名定义为比当前数小的数的个数 +1。若有多个相同的数，应输出最小的排名）。</li>
<li>查询排名为 x 的数。</li>
<li>求 x 的前驱（前驱定义为小于 x，且最大的数）。若未找到则输出−2147483647。</li>
<li>求 x 的后继（后继定义为大于 x，且最小的数）。若未找到则输出 2147483647。</li>
<li>插入一个数 x。</li>
</ol>
<p>输入</p>
<p>第一行是一个整数 q，表示操作次数。</p>
<p>接下来 q 行，每行两个整数 op,x，分别表示操作序号以及操作的参数 x。</p>
<p>输出</p>
<p>输出有若干行。对于操作 1,2,3,4输出一个整数，表示该操作的结果。</p>
<p>样例</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">7</span><br><span class="line">5 1</span><br><span class="line">5 3</span><br><span class="line">5 5</span><br><span class="line">1 3</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 3</span><br></pre></td></tr></tbody></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n = 2147483647;</span><br><span class="line">struct TreeNode {</span><br><span class="line">    int val;</span><br><span class="line">    int count; // 记录当前节点的重复次数</span><br><span class="line">    int leftCount; // 记录左子树节点数量</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(int x) : val(x), count(1), leftCount(0), left(nullptr), right(nullptr) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">// 向二叉搜索树中插入节点</span><br><span class="line">TreeNode* insert(TreeNode* root, int x) {</span><br><span class="line">    if (!root) {</span><br><span class="line">        return new TreeNode(x);</span><br><span class="line">    }</span><br><span class="line">    if (x == root-&gt;val) {</span><br><span class="line">        root-&gt;count++; // 如果值相同，增加当前节点的重复次数</span><br><span class="line">    }</span><br><span class="line">    else if (x &lt; root-&gt;val) {</span><br><span class="line">        root-&gt;leftCount++; // 更新左子树节点数量</span><br><span class="line">        root-&gt;left = insert(root-&gt;left, x);</span><br><span class="line">    }</span><br><span class="line">    else {</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, x);</span><br><span class="line">    }</span><br><span class="line">    return root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取节点排名</span><br><span class="line">int getRank(TreeNode* root, int x) {</span><br><span class="line">    int rank = 0;</span><br><span class="line">    while (root) {</span><br><span class="line">        if (x == root-&gt;val) {</span><br><span class="line">            return rank + root-&gt;leftCount + 1; // 当前节点的排名为左子树节点数量加上重复次数加1</span><br><span class="line">        }</span><br><span class="line">        else if (x &lt; root-&gt;val) {</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        else {</span><br><span class="line">            rank += root-&gt;leftCount + root-&gt;count; // 更新排名</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return rank;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 根据排名获取节点值</span><br><span class="line">int getValueByRank(TreeNode* root, int rank) {</span><br><span class="line">    while (root) {</span><br><span class="line">        int leftSubtreeSize = root-&gt;leftCount;</span><br><span class="line">        int currentNodeCount = root-&gt;count;</span><br><span class="line">        int totalLeftNodes = leftSubtreeSize + currentNodeCount;</span><br><span class="line"></span><br><span class="line">        if (rank &lt;= leftSubtreeSize) {</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        else if (rank &gt; totalLeftNodes) {</span><br><span class="line">            rank -= totalLeftNodes;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        }</span><br><span class="line">        else {</span><br><span class="line">            return root-&gt;val;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return (-n); // 如果未找到，返回-1或其他适当的值</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取前驱节点值</span><br><span class="line">int getPredecessor(TreeNode* root, int x) {</span><br><span class="line">    int predecessor = -2147483647;</span><br><span class="line">    while (root) {</span><br><span class="line">        if (x &lt;= root-&gt;val) {</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        else {</span><br><span class="line">            predecessor = root-&gt;val;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return predecessor;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取后继节点值</span><br><span class="line">int getSuccessor(TreeNode* root, int x) {</span><br><span class="line">    int successor = 2147483647;</span><br><span class="line">    while (root) {</span><br><span class="line">        if (x &gt;= root-&gt;val) {</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        }</span><br><span class="line">        else {</span><br><span class="line">            successor = root-&gt;val;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return successor;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    TreeNode* root = nullptr;</span><br><span class="line">    int q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    for (int i = 0; i &lt; q; i++) {</span><br><span class="line">        int op, x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        switch (op) {</span><br><span class="line">        case 1:</span><br><span class="line">            cout &lt;&lt; getRank(root, x) &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            cout &lt;&lt; getValueByRank(root, x) &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            cout &lt;&lt; getPredecessor(root, x) &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            cout &lt;&lt; getSuccessor(root, x) &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        case 5:</span><br><span class="line">            root = insert(root, x);</span><br><span class="line">            break;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-队列安排"><a href="#5-队列安排" class="headerlink" title="5.队列安排"></a>5.队列安排</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">一个学校里老师要将班上 N 个同学排成一列，同学被编号为1∼N，他采取如下的方法：</span><br><span class="line"></span><br><span class="line">先将 1 号同学安排进队列，这时队列中只有他一个人；</span><br><span class="line"></span><br><span class="line">2-N 号同学依次入列，编号为 i 的同学入列方式为：老师指定编号为 i 的同学站在编号为 1∼(i−1) 中某位同学（即之前已经入列的同学）的左边或右边；</span><br><span class="line"></span><br><span class="line">最后，从队列中去掉 M(M&lt;N） 个同学，其他同学位置顺序不变。</span><br><span class="line"></span><br><span class="line">在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第 1 行为一个正整数 N，表示了有 N 个整数。</span><br><span class="line">第 2∼N行，第 i 行包含两个整数 k,p，其中 k 为小于i 的正整数，p 为 0 或者 1。若 p 为0，则表示将 i 号同学插入到 k 号同学的左边，p 为 1 则表示插入到右边。</span><br><span class="line">第 N+1 行为一个正整数 M，表示去掉的同学数目。</span><br><span class="line">接下来 M行，每行一个正整数 x，表示将 x 号同学从队列中移去，如果 x 号同学已经不在队列中则忽略这一条指令。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">1 行，包含最多 N 个空格隔开的正整数，表示了队列从左到右所有同学的编号，行末换行且无空格。</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mx=1e5+10;</span><br><span class="line">int n,m;</span><br><span class="line">struct T{</span><br><span class="line">    int l,r;        //每个同学的“左右手” </span><br><span class="line">	int d;          //表示同学是否输出 </span><br><span class="line">}t[mx]={0};</span><br><span class="line">void add(int i,int k,int f)       //新增同学 </span><br><span class="line">{</span><br><span class="line">    if(f==1)         //左 </span><br><span class="line">    {</span><br><span class="line">        t[k].r=t[i].r;</span><br><span class="line">        t[k].l=i; </span><br><span class="line">        t[i].r=k;</span><br><span class="line">        t[t[k].r].l=k;</span><br><span class="line">    }</span><br><span class="line">    else             //右 </span><br><span class="line">    {</span><br><span class="line">        t[k].r=i;</span><br><span class="line">        t[k].l=t[i].l;</span><br><span class="line">        t[i].l=k;</span><br><span class="line">        t[t[k].l].r=k;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    int x,k,f;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    t[0].r=0,t[0].l=0;</span><br><span class="line">    add(0,1,1);</span><br><span class="line">    for (int i=2;i&lt;=n;i++)</span><br><span class="line">    {</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;f;</span><br><span class="line">        add(x,i,f);</span><br><span class="line">    }</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    while(m--)</span><br><span class="line">    {</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        t[x].d=1;         //将该同学标记为不输出 </span><br><span class="line">    }</span><br><span class="line">    for (int i=t[0].r;i;i=t[i].r)</span><br><span class="line">    {</span><br><span class="line">        if (t[i].d==0)    //输出未标记的 </span><br><span class="line">          cout&lt;&lt;i&lt;&lt;" ";</span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-明明的随机数"><a href="#6-明明的随机数" class="headerlink" title="6.明明的随机数"></a>6.明明的随机数</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 N个 1到 1000 之间的随机整数 （N&lt;=100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">输入有两行，第 1 行为 1 个正整数，表示所生成的随机数的个数 N。</span><br><span class="line">第 2 行有 N个用空格隔开的正整数，为所产生的随机数。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">输出也是两行，第 1 行为 1 个正整数 M，表示不相同的随机数的个数。</span><br><span class="line">第 2 行为 M 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。</span><br><span class="line"></span><br><span class="line">样例</span><br><span class="line">输入</span><br><span class="line"></span><br><span class="line">10</span><br><span class="line">20 40 32 67 40 20 89 300 400 15</span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">15 20 32 40 67 89 300 400</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;//头文件</span><br><span class="line">using namespace std;</span><br><span class="line">int main() {</span><br><span class="line">	bool a[1001]={0};//定义一个桶</span><br><span class="line">	int n,i,x;</span><br><span class="line">	cin&gt;&gt;n;//输入数量</span><br><span class="line">	for(i=1;i&lt;=n;i++){</span><br><span class="line">		cin&gt;&gt;x;//读入数据</span><br><span class="line">		a[x]=1;//统计数据+去重</span><br><span class="line">	}</span><br><span class="line">	n=0;</span><br><span class="line">	for(i=1;i&lt;=1000;i++){</span><br><span class="line">		if(a[i]==1)n++;//统计数量</span><br><span class="line">	}</span><br><span class="line">	cout&lt;&lt;n&lt;&lt;endl;//输出数量</span><br><span class="line">	for(i=1;i&lt;=1000;i++){</span><br><span class="line">		if(a[i]==1)cout&lt;&lt;i&lt;&lt;" ";//最后的输出</span><br><span class="line">	}</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>桶排序</p>
<h3 id="7-奖学金"><a href="#7-奖学金" class="headerlink" title="7.奖学金"></a>7.奖学金</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前 5 名学生发奖学金。期末，每个学生都有 3 门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学 排在前面，这样，每个学生的排序是唯一确定的。</span><br><span class="line">任务：先根据输入的 3 门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前 5 名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分) 是:</span><br><span class="line">7 279</span><br><span class="line">5 279</span><br><span class="line">这两行数据的含义是:总分最高的两个同学的学号依次是 7 号、5 号。这两名同学的总分都是 279 (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为 7 的学生语文成绩更高一些。如果你的前两名的输出数据是:</span><br><span class="line">5 279</span><br><span class="line">7 279</span><br><span class="line">则按输出错误处理，不能得分。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">共 n+1行。</span><br><span class="line">第 1 行为一个正整数n（n≤300)，表示该校参加评选的学生人数。</span><br><span class="line">第 2 到 n+1 行，每行有 3 个用空格隔开的数字，每个数字都在 0 到 100之间。第 j行的 3 个数字依次表示学号为 j-1 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 1~n（恰好是输入数据的行号减 1）。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">共 5 行，每行是两个用空格隔开的正整数，依次表示前 5 名学生的学号和总分。</span><br><span class="line"></span><br><span class="line">样例</span><br><span class="line">输入1</span><br><span class="line"></span><br><span class="line">6</span><br><span class="line">90 67 80</span><br><span class="line">87 66 91</span><br><span class="line">78 89 91</span><br><span class="line">88 99 77</span><br><span class="line">67 89 64</span><br><span class="line">78 89 98</span><br><span class="line">输出1</span><br><span class="line"></span><br><span class="line">6 265</span><br><span class="line">4 264</span><br><span class="line">3 258</span><br><span class="line">2 244</span><br><span class="line">1 237</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct stu</span><br><span class="line">{</span><br><span class="line">    int num;//编号</span><br><span class="line">    int c,m,e; </span><br><span class="line">    int sum;</span><br><span class="line">}student[310];</span><br><span class="line">bool cmp(stu a,stu b)</span><br><span class="line">{</span><br><span class="line">    if(a.sum&gt;b.sum) return 1;</span><br><span class="line">    else if(a.sum&lt;b.sum) return 0;</span><br><span class="line">    else</span><br><span class="line">    {</span><br><span class="line">        if(a.c&gt;b.c) return 1;</span><br><span class="line">        else if(a.c&lt;b.c) return 0;</span><br><span class="line">        else</span><br><span class="line">        {</span><br><span class="line">            if(a.num&gt;b.num) return 0;</span><br><span class="line">            else return 1;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    {</span><br><span class="line">        student[i].num=i;//录入编号</span><br><span class="line">        cin&gt;&gt;student[i].c&gt;&gt;student[i].m&gt;&gt;student[i].e;//输入</span><br><span class="line">        student[i].sum=student[i].c+student[i].m+student[i].e;//计算总分</span><br><span class="line">    }</span><br><span class="line">    sort(student+1,student+1+n,cmp);</span><br><span class="line">    for(int i=1;i&lt;=5;i++)</span><br><span class="line">        cout&lt;&lt;student[i].num&lt;&lt;' '&lt;&lt;student[i].sum&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-纪念品分组"><a href="#8-纪念品分组" class="headerlink" title="8.纪念品分组"></a>8.纪念品分组</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得 的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品， 并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。</span><br><span class="line"></span><br><span class="line">你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">共 n+2行：</span><br><span class="line">第一行包括一个整数 w，为每组纪念品价格之和的上限。</span><br><span class="line">第二行为一个整数 n，表示购来的纪念品的总件数 G。</span><br><span class="line">第 3 ∼n+2 行每行包含一个正整数 Pi 表示所对应纪念品的价格。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">一个整数，即最少的分组数目。</span><br><span class="line"></span><br><span class="line">样例</span><br><span class="line">输入</span><br><span class="line"></span><br><span class="line">100 </span><br><span class="line">9 </span><br><span class="line">90 </span><br><span class="line">20 </span><br><span class="line">20 </span><br><span class="line">30 </span><br><span class="line">50 </span><br><span class="line">60 </span><br><span class="line">70 </span><br><span class="line">80 </span><br><span class="line">90</span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">6</span><br></pre></td></tr></tbody></table></figure>

<p>题意</p>
<p>输入一个有N个数字的数组，你要将它们分组（每组只能由两数组成），使各组两数之和（两数之和&lt;=W）接近。输出满足上述条件的最小组数。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int p[100005];</span><br><span class="line">int w, n;</span><br><span class="line">int main (){</span><br><span class="line">    cin &gt;&gt;w&gt;&gt;n;</span><br><span class="line">    for(int i = 0; i &lt; n; i++){</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">    }</span><br><span class="line">    sort(p, p + n);</span><br><span class="line">    int  j = 0;</span><br><span class="line">    int sum =0;</span><br><span class="line">    for(int i = n - 1; i &gt;= j; i--){</span><br><span class="line">        if(p[i] + p[j] &lt;= w){</span><br><span class="line">            sum++;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        else{</span><br><span class="line">            sum++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    return 0;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h3 id="9-统计数字"><a href="#9-统计数字" class="headerlink" title="9.统计数字"></a>9.统计数字</h3><p>[P1097 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P1097">NOIP2007 提高组] 统计数字 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">某次科研调查时得到了n个自然数，每个数均不超过1500000000(1.5×109</span><br><span class="line">)。已知不相同的数不超过10000个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">共n+1行。</span><br><span class="line"></span><br><span class="line">第一行是整数n，表示自然数的个数；</span><br><span class="line"></span><br><span class="line">第2至n+1每行一个自然数。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">共m行（m为n个自然数中不相同数的个数），按照自然数从小到大的顺序输出。</span><br><span class="line"></span><br><span class="line">每行输出2个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    int n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    // 使用map来存储自然数及其出现次数</span><br><span class="line">    std::map&lt;int, int&gt; countMap;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) {</span><br><span class="line">        int num;</span><br><span class="line">        std::cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">        // 更新map中自然数的出现次数</span><br><span class="line">        countMap[num]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 遍历map，按照自然数从小到大的顺序输出统计结果</span><br><span class="line">    for (auto it = countMap.begin(); it != countMap.end(); ++it) {</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; " " &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-分数线划定"><a href="#10-分数线划定" class="headerlink" title="10.分数线划定"></a>10.分数线划定</h3><p>[P1068 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1068">NOIP2009 普及组] 分数线划定 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A 市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 150% 划定，即如果计划录取 m 名志愿者，则面试分数线为排名第 m ×150%（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。</span><br><span class="line"></span><br><span class="line">现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第一行，两个整数 n,m(5≤n≤5000,3≤m≤n)，中间用一个空格隔开，其中 n 表示报名参加笔试的选手总数，m 表示计划录取的志愿者人数。输入数据保证 m ×150% 向下取整后小于等于 n。</span><br><span class="line">第二行到第 n+1行，每行包括两个整数，中间用一个空格隔开，分别是选手的报名号 k(1000≤k≤9999)和该选手的笔试成绩 s(1≤s≤100)。数据保证选手的报名号各不相同。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">第一行，有 2 个整数，用一个空格隔开，第一个整数表示面试分数线；第二个整数为进入面试的选手的实际人数。</span><br><span class="line"></span><br><span class="line">从第二行开始，每行包含 2 个整数，中间用一个空格隔开，分别表示进入面试的选手的报名号和笔试成绩，按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。</span><br><span class="line"></span><br><span class="line">样例</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;//万能头文件</span><br><span class="line">using namespace std;</span><br><span class="line">int i,n,m,f,k[5001],s[5001],sub[5001];//f是分数线，sub是下标</span><br><span class="line">bool cmp(int a,int b){//sort规则</span><br><span class="line">    if(s[a]==s[b])return k[a]&lt;k[b];//成绩相等比编号</span><br><span class="line">    return s[a]&gt;s[b];//否则比成绩</span><br><span class="line">}</span><br><span class="line">int main(){</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(i=1;i&lt;=n;i++)cin&gt;&gt;k[sub[i]=i]&gt;&gt;s[i];//输入编号和成绩，同时初始化下标</span><br><span class="line">    sort(sub+1,sub+n+1,cmp);//对下标排序</span><br><span class="line">    f=s[sub[int(m*1.5)]];//算分数线</span><br><span class="line">    for(i=1;s[sub[i]]&gt;=f;i++);//算录取人数</span><br><span class="line">    cout&lt;&lt;f&lt;&lt;" "&lt;&lt;i-1&lt;&lt;endl;</span><br><span class="line">    for(i=1;s[sub[i]]&gt;=f;i++)cout&lt;&lt;k[sub[i]]&lt;&lt;" "&lt;&lt;s[sub[i]]&lt;&lt;endl;//输出</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="11-合并果子"><a href="#11-合并果子" class="headerlink" title="11.合并果子"></a>11.合并果子</h3><p>[P1090 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1090">NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</span><br><span class="line"></span><br><span class="line">每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</span><br><span class="line"></span><br><span class="line">因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</span><br><span class="line"></span><br><span class="line">例如有 3 种果子，数目依次为 1 ， 2 ， 9 。可以先将 1 、 2 堆合并，新堆数目为 3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为 12 。所以多多总共耗费体力 =3+12=15 。可以证明 15 为最小的体力耗费值。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">共两行。</span><br><span class="line">第一行是一个整数 n(1≤n≤10000) ，表示果子的种类数。</span><br><span class="line">第二行包含 n 个整数，用空格分隔，第 i 个整数ai(1≤ai≤20000) 是第 i 种果子的数目。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2e31</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,x,ans;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;</span><br><span class="line">int main(){</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) cin&gt;&gt;x,q.push(x);</span><br><span class="line">	while(q.size()&gt;=2){</span><br><span class="line">		int a=q.top(); q.pop();</span><br><span class="line">		int b=q.top(); q.pop();</span><br><span class="line">		ans+=a+b;</span><br><span class="line">		q.push(a+b);</span><br><span class="line">	}</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="1-合并两个有序链表"><a href="#1-合并两个有序链表" class="headerlink" title="1.合并两个有序链表"></a>1.合并两个有序链表</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"> 合并两个有序链表</span><br><span class="line">描述</span><br><span class="line">将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</span><br><span class="line">输入</span><br><span class="line">输入两个顺序表l1，l2，l1和l2均按非递减顺序排列，两个链表的节点数目范围是 [0, 50]，-100 &lt;= Node.val &lt;= 100</span><br><span class="line">-1表示链表结束符</span><br><span class="line">输出</span><br><span class="line">输出合并后的顺序表</span><br><span class="line">输入样例</span><br><span class="line"></span><br><span class="line">1 2 4 -1</span><br><span class="line">1 3 4 -1</span><br><span class="line">输出样例</span><br><span class="line"></span><br><span class="line">1 1 2 3 4 4</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode {</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode* next;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {</span><br><span class="line">    if (l1 == NULL) {</span><br><span class="line">        return l2;</span><br><span class="line">    }</span><br><span class="line">    if (l2 == NULL) {</span><br><span class="line">        return l1;</span><br><span class="line">    }</span><br><span class="line">    if (l1-&gt;val &lt;= l2-&gt;val) {</span><br><span class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        return l1;</span><br><span class="line">    }</span><br><span class="line">    l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">    return l2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建新节点</span><br><span class="line">struct ListNode* createNode(int val) {</span><br><span class="line">    struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">    if (newNode != NULL) {</span><br><span class="line">        newNode-&gt;val = val;</span><br><span class="line">        newNode-&gt;next = NULL;</span><br><span class="line">    }</span><br><span class="line">    return newNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 插入节点到链表末尾</span><br><span class="line">void insertNode(struct ListNode** head, int val) {</span><br><span class="line">    struct ListNode* newNode = createNode(val);</span><br><span class="line">    if (*head == NULL) {</span><br><span class="line">        *head = newNode;</span><br><span class="line">    }</span><br><span class="line">    else {</span><br><span class="line">        struct ListNode* current = *head;</span><br><span class="line">        while (current-&gt;next != NULL) {</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        current-&gt;next = newNode;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 用于输出链表</span><br><span class="line">void printList(struct ListNode* head) {</span><br><span class="line">    while (head != NULL) {</span><br><span class="line">        printf("%d ", head-&gt;val);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    }</span><br><span class="line">   // 表示链表结束</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    // 创建链表1: 1 -&gt; 2 -&gt; 4</span><br><span class="line"></span><br><span class="line">    struct ListNode* l1 = NULL;</span><br><span class="line">    for (int i = 0;; i++)</span><br><span class="line">    {</span><br><span class="line">        int a = 0;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        if (a == -1)</span><br><span class="line">        {</span><br><span class="line">            break;</span><br><span class="line">        }</span><br><span class="line">        insertNode(&amp;l1, a);</span><br><span class="line">    }</span><br><span class="line">    struct ListNode* l2 = NULL;</span><br><span class="line">    for (int i = 0;; i++)</span><br><span class="line">    {</span><br><span class="line">        int a = 0;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        if (a == -1)</span><br><span class="line">        {</span><br><span class="line">            break;</span><br><span class="line">        }</span><br><span class="line">        insertNode(&amp;l2, a);</span><br><span class="line">    }</span><br><span class="line">    // 合并两个有序链表</span><br><span class="line">    struct ListNode* mergedList = mergeTwoLists(l1, l2);</span><br><span class="line">    // 输出合并后的链表</span><br><span class="line">    printList(mergedList);</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-删除排序链表中的重复元素"><a href="#2-删除排序链表中的重复元素" class="headerlink" title="2.删除排序链表中的重复元素"></a>2.删除排序链表中的重复元素</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回已排序的链表 </span><br><span class="line">输入</span><br><span class="line">输入已排序的链表，链表中节点数目在范围 [0, 300] 内，-100 &lt;= Node.val &lt;= 100，题目数据保证链表已经按升序排列</span><br><span class="line">-1表示链表结束符</span><br><span class="line">输出</span><br><span class="line">输出已排序的链表</span><br><span class="line">输入样例</span><br><span class="line"></span><br><span class="line">1 1 2 3 3 -1</span><br><span class="line">输出样例</span><br><span class="line"></span><br><span class="line">1 2 3</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode {</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode* next;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">// Function to delete duplicates from a sorted linked list</span><br><span class="line">struct ListNode* deleteDuplicates(struct ListNode* head) {</span><br><span class="line">    if (head == nullptr || head-&gt;next == nullptr) {</span><br><span class="line">        return head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    struct ListNode* current = head;</span><br><span class="line"></span><br><span class="line">    while (current != nullptr &amp;&amp; current-&gt;next != nullptr) {</span><br><span class="line">        if (current-&gt;val == current-&gt;next-&gt;val) {</span><br><span class="line">            // Duplicate found, skip the next node</span><br><span class="line">            struct ListNode* temp = current-&gt;next;</span><br><span class="line">            current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">        } else {</span><br><span class="line">            // Move to the next node</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Function to insert a node at the end of the linked list</span><br><span class="line">void insertNode(struct ListNode** head, int val) {</span><br><span class="line">    struct ListNode* newNode = new ListNode;</span><br><span class="line">    newNode-&gt;val = val;</span><br><span class="line">    newNode-&gt;next = nullptr;</span><br><span class="line"></span><br><span class="line">    if (*head == nullptr) {</span><br><span class="line">        *head = newNode;</span><br><span class="line">    } else {</span><br><span class="line">        struct ListNode* current = *head;</span><br><span class="line">        while (current-&gt;next != nullptr) {</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        current-&gt;next = newNode;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Function to print the linked list</span><br><span class="line">void printList(struct ListNode* head) {</span><br><span class="line">    while (head != nullptr) {</span><br><span class="line">        cout &lt;&lt; head-&gt;val &lt;&lt; " ";</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    struct ListNode* head = nullptr;</span><br><span class="line"></span><br><span class="line">    // Create a sorted linked list</span><br><span class="line">    int value;</span><br><span class="line">    while (true) {</span><br><span class="line">        cin &gt;&gt; value;</span><br><span class="line">        if (value == -1) {</span><br><span class="line">            break;</span><br><span class="line">        }</span><br><span class="line">        insertNode(&amp;head, value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // Delete duplicates</span><br><span class="line">    head = deleteDuplicates(head);</span><br><span class="line"></span><br><span class="line">    // Print the resulting linked list</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







<h2 id="总结-板子"><a href="#总结-板子" class="headerlink" title="总结  板子"></a>总结  板子</h2><h3 id="1-定义链表"><a href="#1-定义链表" class="headerlink" title="1.定义链表"></a>1.定义链表</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">struct ListNode {</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode* next;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-创建链表"><a href="#2-创建链表" class="headerlink" title="2.创建链表"></a>2.创建链表</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">struct ListNode* createNode(int val) {</span><br><span class="line">    struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">    if (newNode != NULL) {</span><br><span class="line">        newNode-&gt;val = val;</span><br><span class="line">        newNode-&gt;next = NULL;</span><br><span class="line">    }</span><br><span class="line">    return newNode;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-插入尾节点"><a href="#3-插入尾节点" class="headerlink" title="3.插入尾节点"></a>3.插入尾节点</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">void insertNode(struct ListNode** head, int val) {</span><br><span class="line">    struct ListNode* newNode = createNode(val);</span><br><span class="line">    if (*head == NULL) {</span><br><span class="line">        *head = newNode;</span><br><span class="line">    }</span><br><span class="line">    else {</span><br><span class="line">        struct ListNode* current = *head;</span><br><span class="line">        while (current-&gt;next != NULL) {</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        current-&gt;next = newNode;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-输出链表"><a href="#4-输出链表" class="headerlink" title="4.输出链表"></a>4.输出链表</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">void printList(struct ListNode* head) {</span><br><span class="line">    while (head != NULL) {</span><br><span class="line">        printf("%d ", head-&gt;val);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    // 表示链表结束</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-反转链表"><a href="#5-反转链表" class="headerlink" title="5.反转链表"></a>5.反转链表</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) {</span><br><span class="line">    ListNode* prev = nullptr;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    while (current != nullptr) {</span><br><span class="line">        ListNode* nextTemp = current-&gt;next;</span><br><span class="line">        current-&gt;next = prev;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = nextTemp;</span><br><span class="line">    }</span><br><span class="line">    return prev;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-反转链表2"><a href="#6-反转链表2" class="headerlink" title="6. 反转链表2"></a>6. 反转链表2</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">struct ListNode* reverseLists(struct ListNode* head,int left,int right) {</span><br><span class="line">    if (head == NULL || left == right) {</span><br><span class="line">        return head;</span><br><span class="line">    }</span><br><span class="line">    struct ListNode* dummy = new ListNode();</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    struct ListNode* pre = dummy;</span><br><span class="line">    for (int i = 0; i &lt; left-1; i++) {</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    struct ListNode* cur = pre-&gt;next;</span><br><span class="line">    struct ListNode* next = NULL;</span><br><span class="line">    for (int i = 0; i &lt; right - left; ++i) {</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-删除值为val的节点"><a href="#7-删除值为val的节点" class="headerlink" title="7.删除值为val的节点"></a>7.删除值为val的节点</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">struct ListNode* deleteLists(struct ListNode* l, int val) {</span><br><span class="line">    struct ListNode dummy;//创建一个名为 dummy 的虚拟头节点，其 next 指针指向原始链表的头部。这样做的目的是简化边界情况的处理，因为无论原始链表是否为空，我们都能够使用 dummy.next 访问到链表的头部。</span><br><span class="line">    dummy.next = l;</span><br><span class="line">    struct ListNode* current = &amp;dummy;</span><br><span class="line"></span><br><span class="line">    while (current-&gt;next != NULL)</span><br><span class="line">    {</span><br><span class="line">        if (current-&gt;next-&gt;val == val) {</span><br><span class="line">            struct ListNode* temp = current-&gt;next;</span><br><span class="line">            current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">        }</span><br><span class="line">        else</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return dummy.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-删除最后第N个节点"><a href="#8-删除最后第N个节点" class="headerlink" title="8.删除最后第N个节点"></a>8.删除最后第N个节点</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">struct ListNode* deleteLists(struct ListNode* l, int num) {</span><br><span class="line">    l = reverseList(l);</span><br><span class="line">    struct ListNode dummy;//创建一个名为 dummy 的虚拟头节点，其 next 指针指向原始链表的头部。这样做的目的是简化边界情况的处理，因为无论原始链表是否为空，我们都能够使用 dummy.next 访问到链表的头部。</span><br><span class="line">    dummy.next = l;</span><br><span class="line">    struct ListNode* current = &amp;dummy;</span><br><span class="line">    int number = 1;</span><br><span class="line">    while (current-&gt;next != NULL)</span><br><span class="line">    {</span><br><span class="line">        if (number==num) {</span><br><span class="line">            struct ListNode* temp = current-&gt;next;</span><br><span class="line">            current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">            break;</span><br><span class="line">        }</span><br><span class="line">        else</span><br><span class="line">        {</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        number++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return reverseList(dummy.next);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="9-合并有序链表（递归）"><a href="#9-合并有序链表（递归）" class="headerlink" title="9.合并有序链表（递归）"></a>9.合并有序链表（递归）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {</span><br><span class="line">    if (l1 == NULL) {</span><br><span class="line">        return l2;</span><br><span class="line">    }</span><br><span class="line">    if (l2 == NULL) {</span><br><span class="line">        return l1;</span><br><span class="line">    }</span><br><span class="line">    if (l1-&gt;val &lt;= l2-&gt;val) {</span><br><span class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        return l1;</span><br><span class="line">    }</span><br><span class="line">    l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">    return l2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-链表孪生和"><a href="#10-链表孪生和" class="headerlink" title="10.链表孪生和"></a>10.链表孪生和</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int pairSum(ListNode* head) {</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head-&gt;next;</span><br><span class="line">    while (fast-&gt;next) {</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    // 反转链表</span><br><span class="line">    ListNode* last = slow-&gt;next;</span><br><span class="line">    while (last-&gt;next) {</span><br><span class="line">        ListNode* cur = last-&gt;next;</span><br><span class="line">        last-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = cur;</span><br><span class="line">    }</span><br><span class="line">    int ans = 0;</span><br><span class="line">    ListNode* x = head;</span><br><span class="line">    ListNode* y = slow-&gt;next;</span><br><span class="line">    while (y) {</span><br><span class="line">        ans = max(ans, x-&gt;val + y-&gt;val);</span><br><span class="line">        x = x-&gt;next;</span><br><span class="line">        y = y-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    return ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="11-两数相加"><a href="#11-两数相加" class="headerlink" title="11.两数相加"></a>11.两数相加</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {</span><br><span class="line">    if (l1 == NULL) {</span><br><span class="line">        return l2;</span><br><span class="line">    }</span><br><span class="line">    if (l2 == NULL) {</span><br><span class="line">        return l1;</span><br><span class="line">    }</span><br><span class="line">    struct ListNode* result = NULL;</span><br><span class="line">    struct ListNode* current = NULL;</span><br><span class="line">    int carry = 0;</span><br><span class="line">    while (l1 != NULL || l2 != NULL || carry != 0) {</span><br><span class="line">        int val1 = (l1 != NULL) ? l1-&gt;val : 0;</span><br><span class="line">        int val2 = (l2 != NULL) ? l2-&gt;val : 0;</span><br><span class="line"></span><br><span class="line">        int sum = val1 + val2 + carry;</span><br><span class="line">        carry = sum / 10;</span><br><span class="line"></span><br><span class="line">        struct ListNode* newNode = createNode(sum % 10);</span><br><span class="line"></span><br><span class="line">        if (result == NULL) {</span><br><span class="line">            result = newNode;</span><br><span class="line">            current = result;</span><br><span class="line">        }</span><br><span class="line">        else {</span><br><span class="line">            current-&gt;next = newNode;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if (l1 != NULL) l1 = l1-&gt;next;</span><br><span class="line">        if (l2 != NULL) l2 = l2-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // Reverse the result list before returning</span><br><span class="line">    return reverseLists(result);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Love</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/10/31/%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95-%E9%A2%98%E5%BA%93/">http://example.com/2023/10/31/力扣面试-题库/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">避风港</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/gou.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/07/%E5%AF%86%E7%A0%81/" title="密码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">密码</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/26/%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="力扣面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">力扣面试题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/gou.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">Love</div><div class="author-info__description">归途也还可爱</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/nice020310/nice020310.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/nice020310" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_72757552" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:1490166708@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%9A%E9%A2%98%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">力扣面试+数据结构作业题库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text">1.合并有序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.</span> <span class="toc-text">2.移除元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF"><span class="toc-number">1.2.1.</span> <span class="toc-text">错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.2.2.</span> <span class="toc-text">双指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.3.</span> <span class="toc-text">双指针优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">1.3.</span> <span class="toc-text">3.删除有序数组中的重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.双指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E4%BA%8C"><span class="toc-number">1.4.</span> <span class="toc-text">4.删除有序数组中的重复项二</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-number">1.5.</span> <span class="toc-text">5.多数元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">1.方法一：哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%8E%AF%E7%8A%B6%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">2.方法二：环状替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E6%95%B0%E7%BB%84%E7%BF%BB%E8%BD%AC"><span class="toc-number">1.5.0.3.</span> <span class="toc-text">3.方法三：数组翻转</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">1.6.</span> <span class="toc-text">买卖股票的最佳时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9A%B4%E5%8A%9B%E6%B3%95%EF%BC%88%E9%81%8D%E5%8E%86n-n-1-x2F-2%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.暴力法（遍历n*(n-1)/2找最大值）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%E6%B3%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.一次遍历法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2"><span class="toc-number">1.7.</span> <span class="toc-text">买卖股票的最佳时机2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.8.</span> <span class="toc-text">方法一：动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%AE%80%E5%8D%95%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">1.9.</span> <span class="toc-text">方法二：简单一次遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.10.</span> <span class="toc-text">反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">1.10.1.</span> <span class="toc-text">1.迭代法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">1.10.2.</span> <span class="toc-text">2.递归法</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#for%E5%9C%A8c-%E7%9A%84%E4%BA%94%E7%A7%8D%E7%94%A8%E6%B3%95%E5%92%8Cstring%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">for在c++的五种用法和string的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E9%A2%98%E5%BA%931-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%EF%BC%88%E7%94%A8%E9%A1%BA%E5%BA%8F%E6%A0%88%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">作业题库1 括号匹配（用顺序栈）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E9%A2%98%E5%BA%932-%E5%9B%9E%E6%96%87%E5%BA%8F%E5%88%97%EF%BC%88%E7%94%A8%E9%93%BE%E6%A0%88%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">作业题库2 回文序列（用链栈）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%BA%933%E5%85%A5%E6%A0%88%E5%92%8C%E5%87%BA%E6%A0%88"><span class="toc-number">2.3.</span> <span class="toc-text">题库3入栈和出栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%BA%934-%E7%82%B9%E5%87%BB%E6%B6%88%E9%99%A4"><span class="toc-number">2.4.</span> <span class="toc-text">题库4     点击消除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%BA%935-%E5%91%A8%E6%9C%AB%E8%88%9E%E4%BC%9A"><span class="toc-number">2.5.</span> <span class="toc-text">题库5 周末舞会</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%BA%936-%E6%97%A0%E6%B3%95%E5%90%83%E5%8D%88%E9%A4%90%E7%9A%84%E5%AD%A6%E7%94%9F%E6%95%B0%E9%87%8F"><span class="toc-number">2.6.</span> <span class="toc-text">题库6  无法吃午餐的学生数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%BA%937-%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.7.</span> <span class="toc-text">题库7  栈的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%BA%93-8-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="toc-number">2.8.</span> <span class="toc-text">题库 8 栈的压入、弹出序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%BA%939-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-number">2.9.</span> <span class="toc-text">题库9  最长有效括号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D-%E4%B8%8D%E7%94%A8%E6%A0%88%EF%BC%8C%E7%94%A8count%E8%A1%A8%E7%A4%BA%E5%B7%A6%E6%8B%AC%E5%8F%B7"><span class="toc-number">2.9.1.</span> <span class="toc-text">第一种  不用栈，用count表示左括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E7%94%A8%E6%A0%88"><span class="toc-number">2.9.2.</span> <span class="toc-text">第二种用栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%BA%93-11-%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E8%83%9C%E5%88%A9%E8%80%85"><span class="toc-number">2.10.</span> <span class="toc-text">题库 11  找出游戏胜利者</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E9%A2%98%E5%BA%93-%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">作业题库 数组和串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E4%B8%8E%E4%B8%B2-%E5%B0%8F%E9%B1%BC%E6%AF%94%E5%8F%AF%E7%88%B1"><span class="toc-number">3.1.</span> <span class="toc-text">1.数组与串-小鱼比可爱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E4%B8%8E%E4%B8%B2-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-number">3.2.</span> <span class="toc-text">2.数组与串-杨辉三角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%E4%B8%8E%E4%B8%B2-%E5%86%B0%E9%9B%B9%E7%8C%9C%E6%83%B3"><span class="toc-number">3.3.</span> <span class="toc-text">3.数组与串-冰雹猜想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E4%B8%8E%E4%B8%B2-%E6%B6%B2%E6%99%B6%E5%B1%8F"><span class="toc-number">3.4.</span> <span class="toc-text">5.数组与串-液晶屏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.</span> <span class="toc-text">6.n皇后问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E9%A2%98%E5%BA%93%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.6.</span> <span class="toc-text">作业题库：二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="toc-number">3.6.1.</span> <span class="toc-text">1.相同的树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.6.2.</span> <span class="toc-text">2.二叉树的中序遍历**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.6.3.</span> <span class="toc-text">3.翻转二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number">3.6.4.</span> <span class="toc-text">4.左叶子之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">3.6.5.</span> <span class="toc-text">5.二叉树最近的公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">3.6.6.</span> <span class="toc-text">6.恢复二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A5%87%E5%81%B6%E6%A0%91"><span class="toc-number">3.6.7.</span> <span class="toc-text">7.奇偶树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.6.8.</span> <span class="toc-text">8.二叉树的子树大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91%E5%92%8C"><span class="toc-number">3.6.9.</span> <span class="toc-text">9.二叉树的子树和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%A1%AE%E5%AE%9A%E6%A0%91%E7%9A%84%E5%BD%A2%E6%80%81"><span class="toc-number">3.6.10.</span> <span class="toc-text">10.确定树的形态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF"><span class="toc-number">3.6.11.</span> <span class="toc-text">11.哈夫曼树的带权路径长</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">3.7.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">3.7.1.</span> <span class="toc-text">1.直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8A%98%E5%8D%8A%E6%8E%92%E5%BA%8F"><span class="toc-number">3.7.2.</span> <span class="toc-text">2.折半排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">3.7.3.</span> <span class="toc-text">3.希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">3.7.4.</span> <span class="toc-text">4.交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88%E8%B5%B7%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">3.7.4.1.</span> <span class="toc-text">4.1冒泡排序（起泡排序）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">3.7.5.</span> <span class="toc-text">5.快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">3.7.6.</span> <span class="toc-text">6.简单选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%A0%91%E5%BD%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88%E9%94%A6%E6%A0%87%E8%B5%9Bghp-9yymKPfuZyP90Ic46ZIGEhZpjOTDP54cat4B"><span class="toc-number">3.7.7.</span> <span class="toc-text">7.树形选择排序（锦标赛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</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">3.7.8.</span> <span class="toc-text">8.堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">3.7.9.</span> <span class="toc-text">9.外部排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E6%8E%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.9.1.</span> <span class="toc-text">外排的基本方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%9C%E8%80%85%E6%A0%91ghp-Te68DICI21MITinvYONIbo4DB2ImNo3yPNHW"><span class="toc-number">3.7.9.2.</span> <span class="toc-text">胜者树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</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A5%E8%80%85%E6%A0%91"><span class="toc-number">3.7.9.3.</span> <span class="toc-text">败者树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">3.7.10.</span> <span class="toc-text">置换选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.7.10.1.</span> <span class="toc-text">操作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="toc-number">3.7.10.2.</span> <span class="toc-text">最佳归并树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-number">3.7.11.</span> <span class="toc-text">排序算法比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E9%A2%98%E5%BA%93"><span class="toc-number">3.8.</span> <span class="toc-text">查找题库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%89%BE%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">3.8.1.</span> <span class="toc-text">1.找最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9F%A5%E6%89%BE"><span class="toc-number">3.8.2.</span> <span class="toc-text">2.查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-A-B%E6%95%B0%E5%AF%B9"><span class="toc-number">3.8.3.</span> <span class="toc-text">3.A-B数对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.8.4.</span> <span class="toc-text">4.普通二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%98%9F%E5%88%97%E5%AE%89%E6%8E%92"><span class="toc-number">3.8.5.</span> <span class="toc-text">5.队列安排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%98%8E%E6%98%8E%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">3.8.6.</span> <span class="toc-text">6.明明的随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A5%96%E5%AD%A6%E9%87%91"><span class="toc-number">3.8.7.</span> <span class="toc-text">7.奖学金</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%BA%AA%E5%BF%B5%E5%93%81%E5%88%86%E7%BB%84"><span class="toc-number">3.8.8.</span> <span class="toc-text">8.纪念品分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97"><span class="toc-number">3.8.9.</span> <span class="toc-text">9.统计数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%88%86%E6%95%B0%E7%BA%BF%E5%88%92%E5%AE%9A"><span class="toc-number">3.8.10.</span> <span class="toc-text">10.分数线划定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90"><span class="toc-number">3.8.11.</span> <span class="toc-text">11.合并果子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">3.9.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">3.9.1.</span> <span class="toc-text">1.合并两个有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-number">3.9.2.</span> <span class="toc-text">2.删除排序链表中的重复元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-%E6%9D%BF%E5%AD%90"><span class="toc-number">3.10.</span> <span class="toc-text">总结  板子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E9%93%BE%E8%A1%A8"><span class="toc-number">3.10.1.</span> <span class="toc-text">1.定义链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8"><span class="toc-number">3.10.2.</span> <span class="toc-text">2.创建链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E5%B0%BE%E8%8A%82%E7%82%B9"><span class="toc-number">3.10.3.</span> <span class="toc-text">3.插入尾节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BE%93%E5%87%BA%E9%93%BE%E8%A1%A8"><span class="toc-number">3.10.4.</span> <span class="toc-text">4.输出链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">3.10.5.</span> <span class="toc-text">5.反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A82"><span class="toc-number">3.10.6.</span> <span class="toc-text">6. 反转链表2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%88%A0%E9%99%A4%E5%80%BC%E4%B8%BAval%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">3.10.7.</span> <span class="toc-text">7.删除值为val的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%88%A0%E9%99%A4%E6%9C%80%E5%90%8E%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">3.10.8.</span> <span class="toc-text">8.删除最后第N个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="toc-number">3.10.9.</span> <span class="toc-text">9.合并有序链表（递归）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E9%93%BE%E8%A1%A8%E5%AD%AA%E7%94%9F%E5%92%8C"><span class="toc-number">3.10.10.</span> <span class="toc-text">10.链表孪生和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-number">3.10.11.</span> <span class="toc-text">11.两数相加</span></a></li></ol></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/" title="操作系统学习笔记.md">操作系统学习笔记.md</a><time datetime="2024-11-12T02:34:52.000Z" title="发表于 2024-11-12 10:34:52">2024-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/10/%E5%90%88%E8%82%A5%E7%AB%9911-10-md/" title="合肥站11/10.md">合肥站11/10.md</a><time datetime="2024-11-10T09:07:52.000Z" title="发表于 2024-11-10 17:07:52">2024-11-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/01/NSGA2%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="NSGA2遗传算法笔记">NSGA2遗传算法笔记</a><time datetime="2024-03-01T14:55:37.000Z" title="发表于 2024-03-01 22:55:37">2024-03-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/20/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/" title="傅里叶变换">傅里叶变换</a><time datetime="2024-01-20T02:37:02.000Z" title="发表于 2024-01-20 10:37:02">2024-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/07/%E6%95%B0%E7%94%B5/" title="数电">数电</a><time datetime="2023-12-07T12:25:25.000Z" title="发表于 2023-12-07 20:25:25">2023-12-07</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2024 By Love</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>