<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>傅里叶变换</title>
      <link href="/2024/01/20/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
      <url>/2024/01/20/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.fft <span class="keyword">import</span> fft2, ifft2, fftshift</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入原图像并显示</span></span><br><span class="line">img = plt.imread(<span class="string">&#x27;am.jpg&#x27;</span>)</span><br><span class="line">im = np.mean(img, axis=-<span class="number">1</span>)  <span class="comment"># 转为灰度图</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">plt.imshow(im, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行二维傅立叶变换并显示频谱图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">imf = fftshift(fft2(im))</span><br><span class="line">imf2 = np.log(<span class="number">1</span> + np.<span class="built_in">abs</span>(imf))</span><br><span class="line">fm = np.<span class="built_in">max</span>(imf2)</span><br><span class="line">plt.imshow(imf2 / fm, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Fourier&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造低通滤波器并显示</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">x, y = np.meshgrid(np.arange(-<span class="number">256</span>, <span class="number">256</span>), np.arange(-<span class="number">256</span>, <span class="number">256</span>))</span><br><span class="line">z = np.sqrt(x**<span class="number">2</span> + y**<span class="number">2</span>)</span><br><span class="line">c = (z &lt; <span class="number">20</span>).astype(<span class="built_in">float</span>)</span><br><span class="line">plt.imshow(c, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;low pass filter&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行低通滤波器的傅立叶逆变换并显示</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">imc = ifft2(c)</span><br><span class="line">fa = np.<span class="built_in">abs</span>(imc)</span><br><span class="line">fm = np.<span class="built_in">max</span>(fa)</span><br><span class="line">plt.imshow(fa / fm, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;low pass filter ifft2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对原图像进行频域滤波并显示</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">imf = imf * c</span><br><span class="line">imf2 = np.log(<span class="number">1</span> + np.<span class="built_in">abs</span>(imf))</span><br><span class="line">fm = np.<span class="built_in">max</span>(imf2)</span><br><span class="line">plt.imshow(imf2 / fm, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;low passed Spatial of Fourier&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行频域滤波的逆变换并显示</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">im = ifft2(imf)</span><br><span class="line">fa = np.<span class="built_in">abs</span>(im)</span><br><span class="line">fm = np.<span class="built_in">max</span>(fa)</span><br><span class="line">plt.imshow(fa / fm, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Low passed Spatial of Fourier ifft2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>低频转换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from scipy.fft import fft2, ifft2, fftshift</span><br><span class="line"></span><br><span class="line"># 读入原图</span><br><span class="line">img = plt.imread(&#x27;am.jpg&#x27;)</span><br><span class="line">im = np.mean(img, axis=-1)  # 转为灰度图</span><br><span class="line"></span><br><span class="line"># 绘制原图</span><br><span class="line">plt.subplot(2, 3, 1)</span><br><span class="line">plt.imshow(im, cmap=&#x27;gray&#x27;)</span><br><span class="line">plt.title(&#x27;Original&#x27;)</span><br><span class="line"></span><br><span class="line"># 二维傅立叶变换</span><br><span class="line">plt.subplot(2, 3, 4)</span><br><span class="line">imf = fftshift(fft2(im))</span><br><span class="line">imf2 = np.log(1 + np.abs(imf))</span><br><span class="line">fm = np.max(imf2)</span><br><span class="line">plt.imshow(imf2 / fm, cmap=&#x27;gray&#x27;)</span><br><span class="line">plt.title(&#x27;Fourier&#x27;)</span><br><span class="line"></span><br><span class="line"># 构造低通滤波器</span><br><span class="line">plt.subplot(2, 3, 5)</span><br><span class="line">x, y = np.meshgrid(np.arange(-256, 256), np.arange(-256, 256))</span><br><span class="line">z = np.sqrt(x**2 + y**2)</span><br><span class="line">c = (z &gt; 15).astype(int)</span><br><span class="line">plt.imshow(c, cmap=&#x27;gray&#x27;)</span><br><span class="line">plt.title(&#x27;Low pass filter&#x27;)</span><br><span class="line"></span><br><span class="line"># 高通滤波器傅立叶逆变换</span><br><span class="line">plt.subplot(2, 3, 2)</span><br><span class="line">imc = ifft2(c)</span><br><span class="line">fa = np.abs(imc)</span><br><span class="line">fm = np.max(fa)</span><br><span class="line">plt.imshow(fa / fm, cmap=&#x27;gray&#x27;)</span><br><span class="line">plt.title(&#x27;High pass filter ifft2&#x27;)</span><br><span class="line"></span><br><span class="line"># 图像滤波</span><br><span class="line">plt.subplot(2, 3, 6)</span><br><span class="line">imf_filtered = imf * c</span><br><span class="line">imf2_filtered = np.log(1 + np.abs(imf_filtered))</span><br><span class="line">fm_filtered = np.max(imf2_filtered)</span><br><span class="line">plt.imshow(imf2_filtered / fm_filtered, cmap=&#x27;gray&#x27;)</span><br><span class="line">plt.title(&#x27;High passed Spatial of Fourier&#x27;)</span><br><span class="line"></span><br><span class="line"># 图像滤波逆变换 ifft2</span><br><span class="line">plt.subplot(2, 3, 3)</span><br><span class="line">im_filtered = ifft2(imf_filtered)</span><br><span class="line">fa_filtered = np.abs(im_filtered)</span><br><span class="line">fm_filtered = np.max(fa_filtered)</span><br><span class="line">plt.imshow(fa_filtered / fm_filtered, cmap=&#x27;gray&#x27;)</span><br><span class="line">plt.title(&#x27;High passed Spatial of Fourier ifft2&#x27;)</span><br><span class="line"></span><br><span class="line"># 显示图形</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>高频转换</p><p>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</p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202401201039374.png" alt="image-20240120103949280"></p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数电</title>
      <link href="/2023/12/07/%E6%95%B0%E7%94%B5/"/>
      <url>/2023/12/07/%E6%95%B0%E7%94%B5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312072039550.png" alt="2"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312072040816.png" alt="1695114629162"></p><h2 id="数值与码值ghp-DA9YkX49i4eMGN9gaWpXQqsbrNlIyD0VrdRR"><a href="#数值与码值ghp-DA9YkX49i4eMGN9gaWpXQqsbrNlIyD0VrdRR" class="headerlink" title="数值与码值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"></a>数值与码值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</h2><h3 id="常用数制"><a href="#常用数制" class="headerlink" title="常用数制"></a>常用数制</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202401131039504.png" alt="image-20240113103920432"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202401131043090.png" alt="image-20240113104323016"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202401131045409.png" alt="image-20240113104528319"></p><h3 id="原码补码反码"><a href="#原码补码反码" class="headerlink" title="原码补码反码"></a>原码补码反码</h3><p>原码是有符号和无符号数</p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202401131100076.png" alt="image-20240113110033993"></p><p>补码最高位被舍弃</p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202401131102316.png" alt="image-20240113110208246"></p><p>反码+1为补码，正数三个是相同的</p><h3 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h3><p>二进制码转格雷码:最高位保留不变，从左到右，逐一将相邻两位相加作为格雷码的下一位。</p><p><img src="https://pic4.zhimg.com/80/v2-5bb65a01cbb360f1955df06a222384ef_720w.webp" alt="img"></p><p>格雷码转二进制码:最高位保留不变，将产生的每一位二进制码与下一位相邻的格雷码相加，作为二进制码的下一位。</p><p><img src="https://pic1.zhimg.com/80/v2-51c177b9c0eebb7dd797fffadb181eac_720w.webp" alt="img"></p><h1 id="数电方法"><a href="#数电方法" class="headerlink" title="数电方法"></a>数电方法</h1><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312072039186.png" alt="1694919781030"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1694919792789.png" alt="1694919792789"></p><p><img src="https://pic1.zhimg.com/v2-1747880e37d068c391bb9daf0df036fd_r.jpg?source=1940ef5c" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-8dc1606574d995edbc843fb019b38fad_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-61355c6b4a7dba5e2e887c17d8e480a8_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-55a64baa868c2fd6676c3369c66ea3ff_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-939bf95fd46b11c990a59657ff7bc67f_720w.webp" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20210225185001381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoZW53YW5zYW5fZ3o=,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="门控SR触发器"><a href="#门控SR触发器" class="headerlink" title="门控SR触发器"></a>门控SR触发器</h2><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312072055672.png" alt="image-20231207205158216"></p><h2 id="脉冲SR触发器"><a href="#脉冲SR触发器" class="headerlink" title="脉冲SR触发器"></a>脉冲SR触发器</h2><p>CLK时钟信号</p><p>这个脉冲由两个SR电平触发器组成</p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082014976.png" alt="image-20231208201408772"></p><p>上升沿就是CLK由0-&gt;1，不变</p><p>下降沿由1-&gt;0,不变</p><p>Q1*由整个高电平期间SR输入决定</p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082022865.png" alt="image-20231208202231737"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082024334.png" alt="image-20231208202457202"></p><h3 id="S-x3D-0-R-x3D-0"><a href="#S-x3D-0-R-x3D-0" class="headerlink" title="S&#x3D;0,R&#x3D;0"></a>S&#x3D;0,R&#x3D;0</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082026244.png" alt="image-20231208202646153"></p><h3 id="S-x3D-0-R-x3D-1"><a href="#S-x3D-0-R-x3D-1" class="headerlink" title="S&#x3D;0,R&#x3D;1"></a>S&#x3D;0,R&#x3D;1</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082028048.png" alt="image-20231208202831961"></p><h3 id="S-x3D-1-R-x3D-0"><a href="#S-x3D-1-R-x3D-0" class="headerlink" title="S&#x3D;1,R&#x3D;0"></a>S&#x3D;1,R&#x3D;0</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082029726.png" alt="image-20231208202914639"></p><h3 id="S-x3D-1-R-x3D-1"><a href="#S-x3D-1-R-x3D-1" class="headerlink" title="S&#x3D;1,R&#x3D;1"></a>S&#x3D;1,R&#x3D;1</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082030805.png" alt="image-20231208203038694"></p><h3 id="特性表与特性方程"><a href="#特性表与特性方程" class="headerlink" title="特性表与特性方程"></a>特性表与特性方程</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082034480.png" alt="image-20231208203449359"></p><h3 id="图形符号"><a href="#图形符号" class="headerlink" title="图形符号"></a>图形符号</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082036116.png" alt="image-20231208203628026"></p><p>不加圈就是高电平有效，正脉冲触发</p><p>加圈低电平有效，负脉冲触发</p><h3 id="主触发器的翻转特性"><a href="#主触发器的翻转特性" class="headerlink" title="主触发器的翻转特性"></a>主触发器的翻转特性</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082040299.png" alt="image-20231208204045145"></p><p>只考虑是错误，这就是脉冲触发和边沿触发的区别</p><h2 id="脉冲触发的JK触发器"><a href="#脉冲触发的JK触发器" class="headerlink" title="脉冲触发的JK触发器"></a>脉冲触发的JK触发器</h2><h3 id="电路结构"><a href="#电路结构" class="headerlink" title="电路结构"></a>电路结构</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082049949.png" alt="image-20231208204925825"></p><p>为区别之前的输入端用J和K表示，故叫JK触发器</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="J-x3D-0-K-x3D-1-Q-x3D-0"><a href="#J-x3D-0-K-x3D-1-Q-x3D-0" class="headerlink" title="J&#x3D;0,K&#x3D;1,Q&#x3D;0"></a>J&#x3D;0,K&#x3D;1,Q&#x3D;0</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082053123.png" alt="image-20231208205324010"></p><h4 id="J-x3D-0-K-x3D-1-Q-x3D-1"><a href="#J-x3D-0-K-x3D-1-Q-x3D-1" class="headerlink" title="J&#x3D;0,K&#x3D;1,Q&#x3D;1"></a>J&#x3D;0,K&#x3D;1,Q&#x3D;1</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082054314.png" alt="image-20231208205429194"></p><h4 id="J-x3D-1-K-x3D-0-Q-x3D-0"><a href="#J-x3D-1-K-x3D-0-Q-x3D-0" class="headerlink" title="J&#x3D;1,K&#x3D;0,Q&#x3D;0"></a>J&#x3D;1,K&#x3D;0,Q&#x3D;0</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082056810.png" alt="image-20231208205640702"></p><h4 id="J-x3D-1-K-x3D-0-Q-x3D-1"><a href="#J-x3D-1-K-x3D-0-Q-x3D-1" class="headerlink" title="J&#x3D;1,K&#x3D;0,Q&#x3D;1"></a>J&#x3D;1,K&#x3D;0,Q&#x3D;1</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082057426.png" alt="image-20231208205754312"></p><h4 id="J-x3D-1-K-x3D-1-Q-x3D-0"><a href="#J-x3D-1-K-x3D-1-Q-x3D-0" class="headerlink" title="J&#x3D;1,K&#x3D;1,Q&#x3D;0"></a>J&#x3D;1,K&#x3D;1,Q&#x3D;0</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082059285.png" alt="image-20231208205942172"></p><h4 id="J-x3D-1-K-x3D-1-Q-x3D-1"><a href="#J-x3D-1-K-x3D-1-Q-x3D-1" class="headerlink" title="J&#x3D;1,K&#x3D;1,Q&#x3D;1"></a>J&#x3D;1,K&#x3D;1,Q&#x3D;1</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082101434.png" alt="image-20231208210115333"></p><h3 id="特性表与特性方程-1"><a href="#特性表与特性方程-1" class="headerlink" title="特性表与特性方程"></a>特性表与特性方程</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082103230.png" alt="image-20231208210357124"></p><h3 id="主触发器翻转特性"><a href="#主触发器翻转特性" class="headerlink" title="主触发器翻转特性"></a>主触发器翻转特性</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082132558.png" alt="image-20231208213234431"></p><p>下降沿发生变化</p><h3 id="例题（重点）"><a href="#例题（重点）" class="headerlink" title="例题（重点）"></a>例题（重点）</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082139886.png" alt="image-20231208213901740"></p><h2 id="满足这些就是SR触发器"><a href="#满足这些就是SR触发器" class="headerlink" title="满足这些就是SR触发器"></a>满足这些就是SR触发器</h2><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082143042.png" alt="image-20231208214334911"></p><h2 id="满足这些就是SR触发器-1"><a href="#满足这些就是SR触发器-1" class="headerlink" title="满足这些就是SR触发器"></a>满足这些就是SR触发器</h2><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082144242.png" alt="image-20231208214412133"></p><h2 id="满足这些就是D触发器"><a href="#满足这些就是D触发器" class="headerlink" title="满足这些就是D触发器"></a>满足这些就是D触发器</h2><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082145968.png" alt="image-20231208214526874"></p><h2 id="满足这些就是T触发器"><a href="#满足这些就是T触发器" class="headerlink" title="满足这些就是T触发器"></a>满足这些就是T触发器</h2><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082146963.png" alt="image-20231208214610855"></p><h2 id="已知触发器输入波形，求输出波形"><a href="#已知触发器输入波形，求输出波形" class="headerlink" title="已知触发器输入波形，求输出波形"></a>已知触发器输入波形，求输出波形</h2><h3 id="1-直接给出输入信号波形"><a href="#1-直接给出输入信号波形" class="headerlink" title="1.直接给出输入信号波形"></a>1.直接给出输入信号波形</h3><p>可根据触发器特性表和触发方式直接求出波形</p><h3 id="2-输入信号经过输入端附加电路"><a href="#2-输入信号经过输入端附加电路" class="headerlink" title="2.输入信号经过输入端附加电路"></a>2.输入信号经过输入端附加电路</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082151688.png" alt="image-20231208215115587"></p><h3 id="3-带异步置位、复位输入"><a href="#3-带异步置位、复位输入" class="headerlink" title="3.带异步置位、复位输入"></a>3.带异步置位、复位输入</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082153804.png" alt="image-20231208215331723"></p><h3 id="例子1-关于题型2上升沿的D触发器"><a href="#例子1-关于题型2上升沿的D触发器" class="headerlink" title="例子1 关于题型2上升沿的D触发器"></a>例子1 关于题型2上升沿的D触发器</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312082154335.png" alt="image-20231208215417224"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111451897.png" alt="image-20231211145139788"></p><h3 id="例题7-JK触发器"><a href="#例题7-JK触发器" class="headerlink" title="例题7 JK触发器"></a>例题7 JK触发器</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111458246.png" alt="image-20231211145809186"></p><p>观察得j1&#x3D;q’,k1&#x3D;q2;j2&#x3D;q1,k2&#x3D;q1’,还有一个异步r‘d&#x3D;q1;</p><p>进行列表</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\image-20231211151000961.png" alt="image-20231211151000961"></p><h2 id="触发器的动态特性"><a href="#触发器的动态特性" class="headerlink" title="触发器的动态特性"></a>触发器的动态特性</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\image-20231211151338867.png" alt="image-20231211151338867"></p><h3 id="1-建立时间"><a href="#1-建立时间" class="headerlink" title="1.建立时间"></a>1.建立时间</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\image-20231211151635003.png" alt="image-20231211151635003"></p><h3 id="2-保持时间"><a href="#2-保持时间" class="headerlink" title="2.保持时间"></a>2.保持时间</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\image-20231211151829966.png" alt="image-20231211151829966"></p><h3 id="3-传输延迟时间"><a href="#3-传输延迟时间" class="headerlink" title="3.传输延迟时间"></a>3.传输延迟时间</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\image-20231211152128072.png" alt="image-20231211152128072"></p><h3 id="4-最高时钟频率fmax"><a href="#4-最高时钟频率fmax" class="headerlink" title="4.最高时钟频率fmax"></a>4.最高时钟频率fmax</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111525644.png" alt="image-20231211152502573"></p><h2 id="寄存器和存储器"><a href="#寄存器和存储器" class="headerlink" title="寄存器和存储器"></a>寄存器和存储器</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111526517.png" alt="image-20231211152627453"></p><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111530946.png" alt="image-20231211153044876"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111531152.png" alt="image-20231211153157081"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111534844.png" alt="image-20231211153435782"></p><h3 id="静态随机存储器-SRAM）"><a href="#静态随机存储器-SRAM）" class="headerlink" title="静态随机存储器(SRAM）"></a>静态随机存储器(SRAM）</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111536929.png" alt="image-20231211153612869"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111540516.png" alt="image-20231211154059449"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111545406.png" alt="image-20231211154535335"></p><h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111548401.png" alt="image-20231211154858338"></p><h3 id="CMOS"><a href="#CMOS" class="headerlink" title="CMOS"></a>CMOS</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111549382.png" alt="image-20231211154934323"></p><h3 id="动态随机存储器（DRAM）"><a href="#动态随机存储器（DRAM）" class="headerlink" title="动态随机存储器（DRAM）"></a>动态随机存储器（DRAM）</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111550402.png" alt="image-20231211155037335"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111551984.png" alt="image-20231211155156917"></p><h3 id="二极管ROM电路结构"><a href="#二极管ROM电路结构" class="headerlink" title="二极管ROM电路结构"></a>二极管ROM电路结构</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312111553076.png" alt="image-20231211155325014"></p><h3 id="ROM的分类"><a href="#ROM的分类" class="headerlink" title="ROM的分类"></a>ROM的分类</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151558527.png" alt="image-20231215155829390"></p><h2 id="时序逻辑电路"><a href="#时序逻辑电路" class="headerlink" title="时序逻辑电路"></a>时序逻辑电路</h2><h3 id="1-逻辑电路的分类"><a href="#1-逻辑电路的分类" class="headerlink" title="1.逻辑电路的分类"></a>1.逻辑电路的分类</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151612616.png" alt="image-20231215161247549"></p><h3 id="时序电路一般结构"><a href="#时序电路一般结构" class="headerlink" title="时序电路一般结构"></a>时序电路一般结构</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151613939.png" alt="image-20231215161343874"></p><h3 id="描述方法"><a href="#描述方法" class="headerlink" title="描述方法"></a>描述方法</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151615269.png" alt="image-20231215161538200"></p><h3 id="时序电路触发器进行细分"><a href="#时序电路触发器进行细分" class="headerlink" title="时序电路触发器进行细分"></a>时序电路触发器进行细分</h3><h4 id="1-同步时序逻辑电路"><a href="#1-同步时序逻辑电路" class="headerlink" title="1.同步时序逻辑电路"></a>1.同步时序逻辑电路</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151617678.png" alt="image-20231215161707617"></p><h4 id="2-异步时序逻辑电路"><a href="#2-异步时序逻辑电路" class="headerlink" title="2.异步时序逻辑电路"></a>2.异步时序逻辑电路</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151618558.png" alt="image-20231215161800494"></p><h3 id="时序逻辑电路输出信号特点分类"><a href="#时序逻辑电路输出信号特点分类" class="headerlink" title="时序逻辑电路输出信号特点分类"></a>时序逻辑电路输出信号特点分类</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151621112.png" alt="image-20231215162114039"></p><h3 id="常用时序逻辑电路"><a href="#常用时序逻辑电路" class="headerlink" title="常用时序逻辑电路"></a>常用时序逻辑电路</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151621566.png" alt="image-20231215162141508"></p><h3 id="同步时序逻辑电路的分析"><a href="#同步时序逻辑电路的分析" class="headerlink" title="同步时序逻辑电路的分析"></a>同步时序逻辑电路的分析</h3><h4 id="1-分析方法"><a href="#1-分析方法" class="headerlink" title="1.分析方法"></a>1.分析方法</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151933985.png" alt="image-20231215193343918"></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151934500.png" alt="image-20231215193409435"></p><p>悬空等于1，高电平，这里K&#x3D;1；</p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151942172.png" alt="image-20231215194238087"></p><p>输出方程 Y&#x3D;Q2Q3</p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151946346.png" alt="image-20231215194629275"></p><h4 id="2-状态转换表"><a href="#2-状态转换表" class="headerlink" title="2.状态转换表"></a>2.状态转换表</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151949880.png" alt="image-20231215194900813"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151952980.png" alt="image-20231215195258907"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312151959380.png" alt="image-20231215195924279"></p><h4 id="3-状态转换图"><a href="#3-状态转换图" class="headerlink" title="3.状态转换图"></a>3.状态转换图</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312152002134.png" alt="image-20231215200220067"></p><p>下面那个Y是状态1的输出</p><p>表转化成图</p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312152008638.png" alt="image-20231215200840560"></p><h4 id="4-时序图"><a href="#4-时序图" class="headerlink" title="4.时序图"></a>4.时序图</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312152009945.png" alt="image-20231215200943871"></p><h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312152134473.png" alt="image-20231215213423376"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312152136644.png" alt="image-20231215213646570"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312152138404.png" alt="image-20231215213807338"></p><p>D触发器Q*&#x3D;D</p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312152151362.png" alt="image-20231215215127265"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312152153475.png" alt="image-20231215215315398"></p><h3 id="移位寄存器"><a href="#移位寄存器" class="headerlink" title="移位寄存器"></a>移位寄存器</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312202230543.png" alt="image-20231220222957403"></p><h3 id="2-移位寄存器电路结构"><a href="#2-移位寄存器电路结构" class="headerlink" title="2.移位寄存器电路结构"></a>2.移位寄存器电路结构</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312202231510.png" alt="image-20231220223131407"></p><h3 id="3-移位寄存器的工作原理"><a href="#3-移位寄存器的工作原理" class="headerlink" title="3.移位寄存器的工作原理"></a>3.移位寄存器的工作原理</h3><p>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</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\image-20231220224353779.png" alt="image-20231220224353779"></p><h3 id="状态转换表"><a href="#状态转换表" class="headerlink" title="状态转换表"></a>状态转换表</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\image-20231220224724160.png" alt="image-20231220224724160"></p><h3 id="4-3、4双向移位寄存器实例74LS194A"><a href="#4-3、4双向移位寄存器实例74LS194A" class="headerlink" title="4.       3、4双向移位寄存器实例74LS194A"></a>4.       3、4双向移位寄存器实例74LS194A</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312202249723.png" alt="image-20231220224938640"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312211623403.png" alt="image-20231221161507405"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312211625550.png" alt="image-20231221162508472"></p><p>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</p><p>S1&#x3D;1,看成左移left</p><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312211630784.png" alt="image-20231221163010696"></p><h2 id="计数器简介"><a href="#计数器简介" class="headerlink" title="计数器简介"></a>计数器简介</h2><h3 id="1-计数器分类"><a href="#1-计数器分类" class="headerlink" title="1.计数器分类"></a>1.计数器分类</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312211631063.png" alt="image-20231221163139998"></p><h3 id="加法计数原理"><a href="#加法计数原理" class="headerlink" title="加法计数原理"></a>加法计数原理</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312211635850.png" alt="image-20231221163556787"></p><h3 id="T触发器实现输出的翻转"><a href="#T触发器实现输出的翻转" class="headerlink" title="T触发器实现输出的翻转"></a>T触发器实现输出的翻转</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312211638025.png" alt="image-20231221163835947"></p><h3 id="控制输入状态实现加法计数"><a href="#控制输入状态实现加法计数" class="headerlink" title="控制输入状态实现加法计数"></a>控制输入状态实现加法计数</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312211643668.png" alt="image-20231221164313582"></p><h3 id="4位二进制加法电路"><a href="#4位二进制加法电路" class="headerlink" title="4位二进制加法电路"></a>4位二进制加法电路</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312211703755.png" alt="image-20231221170341639"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312211720836.png" alt="image-20231221172009747"></p><h3 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312211724134.png" alt="image-20231221172422043"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\image-20231221172605438.png" alt="image-20231221172605438"></p><h3 id="4位同步二进制加法计数器74161"><a href="#4位同步二进制加法计数器74161" class="headerlink" title="4位同步二进制加法计数器74161"></a>4位同步二进制加法计数器74161</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312211729539.png" alt="image-20231221172919448"></p><p>全为1，加法正常</p><h3 id="同步二进制减法及可逆计数器"><a href="#同步二进制减法及可逆计数器" class="headerlink" title="同步二进制减法及可逆计数器"></a>同步二进制减法及可逆计数器</h3>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数电 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSGA2遗传算法笔记</title>
      <link href="/2023/11/08/NSGA2%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/08/NSGA2%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="NSGA-II–遗传算法（带精英策略的非支配排序遗传算法）"><a href="#NSGA-II–遗传算法（带精英策略的非支配排序遗传算法）" class="headerlink" title="NSGA-II–遗传算法（带精英策略的非支配排序遗传算法）"></a>NSGA-II–遗传算法（带精英策略的非支配排序遗传算法）</h1><p>即带有精英保留策略的快速非支配多目标优化算法，是一种基于Pareto最优解的多目标优化算法。</p><h3 id="Pareto（柏拉图）支配"><a href="#Pareto（柏拉图）支配" class="headerlink" title="Pareto（柏拉图）支配"></a><strong>Pareto（柏拉图）支配</strong></h3><p>MOP问题中支配是一个重要的概念</p><p>MOP多目标优化问题</p><p>支配的描述为：有两个解x1和x2，x1支配x2的充要条件是对于任意的i(i&#x3D;1,2, 3…m)，均有fi(x1)&lt;&#x3D;fi(x2)，且对于任意的i(i&#x3D;1, 2, 3…m)，存在fi(x1)&lt;fi(x2)。记为x1≺x2。（和离散数学里的偏序关系相似）</p><h3 id="Pareto最优解（Pareto-Optimal-Solution）"><a href="#Pareto最优解（Pareto-Optimal-Solution）" class="headerlink" title="Pareto最优解（Pareto Optimal Solution）"></a><strong>Pareto最优解（Pareto Optimal Solution）</strong></h3><p>某个解x’是最优解，当且仅当x’不被任何其他解支配。<br><strong>x’只是不被其他解支配，而不是支配了其他所有解</strong>，就能称为最优解了。</p><h3 id="Pareto集（Pareto-Set）"><a href="#Pareto集（Pareto-Set）" class="headerlink" title="Pareto集（Pareto Set）"></a><strong>Pareto集（Pareto Set）</strong></h3><p>如果一组解集（也就是多个x）中的任意两个解都不能支配对方，那么这个集合称为Pareto集，简称PS</p><h3 id="Pareto前沿（Pareto-Front）"><a href="#Pareto前沿（Pareto-Front）" class="headerlink" title="Pareto前沿（Pareto Front）"></a><strong>Pareto前沿（Pareto Front）</strong></h3><p>PS中，每个解对应的目标函数值组成的集合称为pareto前沿，简称PF。</p><h3 id="进化算法是如何解决MOP问题的呢？"><a href="#进化算法是如何解决MOP问题的呢？" class="headerlink" title="进化算法是如何解决MOP问题的呢？"></a><strong>进化算法</strong>是如何解决MOP问题的呢？</h3><p>主要是3个应用：变异、交叉、多样性。</p><h4 id="1-变异（类似生物变异，优胜劣汰）"><a href="#1-变异（类似生物变异，优胜劣汰）" class="headerlink" title="1.变异（类似生物变异，优胜劣汰）"></a>1.变异（类似生物变异，优胜劣汰）</h4><ol><li>取某一个解x0，让x0随机地变化，比如增加0.1得x1，减少0.1得x2之类，看看变化之后和原来有什么不同。<br>要是变化之后，发现了更左下的点？就说明发现了更优的解，这时可以保留左下的点、淘汰右上的点。<br>需要注意的是：变异不是一定能够产生更左下的点的，但是只要出现了，我们就能把它保留下来！</li></ol><h4 id="2-交叉"><a href="#2-交叉" class="headerlink" title="2.交叉"></a>2.交叉</h4><p>叫做交配更好理解。假如有两个解x1和x2，分别对应左上的p1和右下的p2，那么我们可以想办法融合x1和x2的优良性状，这就是交叉。<br>比如，我们可以取x3&#x3D;(x1+x2)&#x2F;2，看看x3相对于x1和x2的位置，要是x3是更优的解，同样可以保留x3。<br>和变异相同，交叉也不是一定能产生更左下的点的。</p><h4 id="3-多样性"><a href="#3-多样性" class="headerlink" title="3.多样性"></a>3.多样性</h4><p>多样性就是：保持找到尽可能多的解的可能性。</p><h3 id="NSGA：进化思想"><a href="#NSGA：进化思想" class="headerlink" title="NSGA：进化思想"></a>NSGA：进化思想</h3><p>NSGA-Ⅱ中还包含了一个选择个体的方法：拥挤度比较</p><p><img src="https://pic1.zhimg.com/80/v2-b21f6709d52fa069cf2fd8f9f43b7e14_720w.webp" alt="img"></p><p>i的拥挤度和i-1点和i+1点的位置有关，上图i点的拥挤度就是方形的周长（也就是虚线的总长度）。最左边和最右边的点的拥挤度设置为无限大。</p><p>我们喜欢拥挤度大的点（<strong>拥挤度大实际上是和周围的点相隔远</strong>），因为它们更能保持种群多样性，更容易发展出新种群。</p><p>左上和右下的点是无法比较的，但是拥挤度提供了一个比较的思路。</p><h2 id="NSGA流程"><a href="#NSGA流程" class="headerlink" title="NSGA流程"></a>NSGA流程</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1699004285675.png" alt="1699004285675"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1699004329590.png" alt="1699004329590"></p><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h3><h3 id="2-交叉变异"><a href="#2-交叉变异" class="headerlink" title="2.交叉变异"></a>2.交叉变异</h3><h3 id="3-非支配排序"><a href="#3-非支配排序" class="headerlink" title="3.非支配排序"></a>3.非支配排序</h3><p>Pareto等级：在一组解中，非支配解Pareto等级定义为1，将非支配解从解的集合中删除，剩下解的Pareto等级定义为2，依次类推，可以得到该解集合中所有解的Pareto等级。</p><p>把种群分成几个PS并赋予等级，越往左下的PS等级越高（因为越优）。rank越小，等级越高</p><h4 id="3-1选择"><a href="#3-1选择" class="headerlink" title="3.1选择"></a>3.1选择</h4><p>选择等级高的个体，rank&#x3D;1和rank&#x3D;2的个体，总共3个被保留</p><p><strong>迭代</strong><br>选择完了又回到第2步，直到进化到了一定的次数，结束算法</p>]]></content>
      
      
      <categories>
          
          <category> 大创 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码</title>
      <link href="/2023/11/07/%E5%AF%86%E7%A0%81/"/>
      <url>/2023/11/07/%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="BUUCTF-Crypto"><a href="#BUUCTF-Crypto" class="headerlink" title="BUUCTF  Crypto"></a>BUUCTF  Crypto</h2><h3 id="1-世上无难事1，11-07"><a href="#1-世上无难事1，11-07" class="headerlink" title="1.世上无难事1，11.07"></a>1.世上无难事1，11.07</h3><p>以下是某国现任总统外发的一段指令，经过一种奇异的加密方式，毫无规律，看来只能分析了。请将这段语句还原成通顺语句，并从中找到key作为答案提交，答案是32位，包含小写字母。 注意：得到的 flag 请包上 flag{} 提交</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VIZZB IFIUOJBWO NVXAP OBC XZZ UKHVN IFIUOJBWO HB XVIXW XAW VXFI X QIXN VBD KQ IFIUOJBWO WBKAH NBWXO VBD XJBCN NKG QLKEIU DI XUI VIUI DKNV QNCWIANQ XN DXPIMKIZW VKHV QEVBBZ KA XUZKAHNBA FKUHKAKX XAW DI VXFI HBN QNCWIANQ NCAKAH KA MUBG XZZ XEUBQQ XGIUKEX MUBG PKAWIUHXUNIA NVUBCHV 12NV HUXWI XAW DI XUI SCQN QB HZXW NVXN XZZ EBCZW SBKA CQ NBWXO XAW DI DXAN NB NVXAP DXPIMKIZW MBU JIKAH QCEV XA BCNQNXAWKAH VBQN HKFI OBCUQIZFIQ X JKH UBCAW BM XLLZXCQI XAW NVI PIO KQ 640I11012805M211J0XJ24MM02X1IW09</span><br></pre></td></tr></table></figure><p>观察后面640I11012805M211J0XJ24MM02X1IW09为32位恰巧为答案的个数</p><p>key is  xxxx；猜测pio&#x3D;key，用<a href="https://quipqiup.com/">quipqiup - cryptoquip and cryptogram solver</a>，解题工具，得到flag</p><h3 id="2-大帝的秘密武器1"><a href="#2-大帝的秘密武器1" class="headerlink" title="2.大帝的秘密武器1"></a>2.大帝的秘密武器1</h3><p>根据提示，将文件改为zip，得到密文和题目</p><p>题目：</p><p>公元前一百年，在罗马出生了一位对世界影响巨大的人物，他生前是罗马三巨头之一。他率先使用了一种简单的加密函，因此这种加密方法以他的名字命名。<br>以下密文被解开后可以获得一个有意义的单词：FRPHEVGL<br>你可以用这个相同的加密向量加密附件中的密文，作为答案进行提交。</p><p>密文：ComeChina</p><p>使用凯撒密码进行解码，当移位13位时，得到一个具有意义的单词security</p><p>使用13位加密ComeChina，注意大小写</p><h2 id="3-Windows系统密码1"><a href="#3-Windows系统密码1" class="headerlink" title="3.Windows系统密码1"></a>3.Windows系统密码1</h2><p>打开之后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">ctf:1002:06af9108f2e1fecf144e2e8adef09efd:a7fcb22a88038f35a8f39d503e7f0062:::</span><br><span class="line">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">SUPPORT_388945a0:1001:aad3b435b51404eeaad3b435b51404ee:bef14eee40dffbc345eeb3f58e290d56:::</span><br></pre></td></tr></table></figure><p>看到ctf，后面有两串，先试第一个，利用MD5解码器，没有得到，在用第二个解码，得到了</p><h2 id="4-传统知识-古典密码"><a href="#4-传统知识-古典密码" class="headerlink" title="4.传统知识+古典密码"></a>4.传统知识+古典密码</h2><p>小明某一天收到一封密信，信中写了几个不同的年份<br>          辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳。<br>          信的背面还写有“+甲子”，请解出这段密文。</p><p>key值：CTF{XXX}</p><p>甲子年表可以找到对应，然后在加甲子就是+60，然后ASCII编码得到，字符，在进行栅栏编码，得到两个，在凯撒密码解码</p><h2 id="5-丢失的MD5"><a href="#5-丢失的MD5" class="headerlink" title="5.丢失的MD5"></a>5.丢失的MD5</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib   </span><br><span class="line">for i in range(32,127):</span><br><span class="line">    for j in range(32,127):</span><br><span class="line">        for k in range(32,127):</span><br><span class="line">            m=hashlib.md5()</span><br><span class="line">            m.update(&#x27;TASC&#x27;+chr(i)+&#x27;O3RJMV&#x27;+chr(j)+&#x27;WDJKX&#x27;+chr(k)+&#x27;ZM&#x27;)</span><br><span class="line">            des=m.hexdigest()</span><br><span class="line">            if &#x27;e9032&#x27; in des and &#x27;da&#x27; in des and &#x27;911513&#x27; in des:</span><br><span class="line">                print des</span><br></pre></td></tr></table></figure><p>这个代码运行是错误的</p><p>需要掌握一定Python基础</p><p>进行修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">for i in range(32, 127):</span><br><span class="line">    for j in range(32, 127):</span><br><span class="line">        for k in range(32, 127):</span><br><span class="line">            m = hashlib.md5()</span><br><span class="line">            m.update((&#x27;TASC&#x27; + chr(i) + &#x27;O3RJMV&#x27; + chr(j) + &#x27;WDJKX&#x27; + chr(k) + &#x27;ZM&#x27;).encode(&#x27;utf-8&#x27;))</span><br><span class="line">            des = m.hexdigest()</span><br><span class="line">            if &#x27;e9032&#x27; in des and &#x27;da&#x27; in des and &#x27;911513&#x27; in des:</span><br><span class="line">                print(des)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="6-新时代的步伐"><a href="#6-新时代的步伐" class="headerlink" title="6.新时代的步伐"></a>6.新时代的步伐</h2><h2 id="信息化时代的步伐"><a href="#信息化时代的步伐" class="headerlink" title="信息化时代的步伐"></a>信息化时代的步伐</h2><p>也许中国可以早早进入信息化时代，但是被清政府拒绝了。附件中是数十年后一位伟人说的话的密文。请翻译出明文(答案为一串中文！) 注意：得到的 flag 请包上 flag{} 提交</p><p><a href="https://files.buuoj.cn/files/25dad53083126fcb4a7cc92aafbaed80/a9bbf4f5-ef36-4c64-969d-12457c2ea25d.zip"> a9bbf4f5-ef36-4c64-969d-12457c2ea25d.zip</a></p><p>先尝试了ASCII编码，不行，在从信息化时代联想电码，答案又是一串中文，中国电码进行尝试</p><p>出现了中文计算机要从娃娃抓起</p><h2 id="RSA1"><a href="#RSA1" class="headerlink" title="RSA1"></a>RSA1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math is cool! Use the RSA algorithm to decode the secret message, c, p, q, and e are parameters for the RSA algorithm.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p =  9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483</span><br><span class="line">q =  11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407</span><br><span class="line">e =  65537</span><br><span class="line">c =  83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034</span><br><span class="line"></span><br><span class="line">Use RSA to find the secret message</span><br></pre></td></tr></table></figure><p>用工具得到d，在用py代码解答</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p =  <span class="number">9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483</span></span><br><span class="line">q =  <span class="number">11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407</span></span><br><span class="line">e =  <span class="number">65537</span></span><br><span class="line">c =  <span class="number">83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034</span></span><br><span class="line">d=<span class="number">56632047571190660567520341028861194862411428416862507034762587229995138605649836960220619903456392752115943299335385163216233744624623848874235303309636393446736347238627793022725260986466957974753004129210680401432377444984195145009801967391196615524488853620232925992387563270746297909112117451398527453977</span></span><br><span class="line">m=<span class="built_in">pow</span>(c,d,p*q)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到flag</p><h2 id="求解RSA加密算法"><a href="#求解RSA加密算法" class="headerlink" title="求解RSA加密算法"></a>求解RSA加密算法</h2><h4 id="已知dp，n，e，c求m"><a href="#已知dp，n，e，c求m" class="headerlink" title="已知dp，n，e，c求m"></a>已知dp，n，e，c求m</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2 as gp</span><br><span class="line"></span><br><span class="line">e = 65537</span><br><span class="line">n = gp.mpz(248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113)</span><br><span class="line">dp = gp.mpz(905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657)</span><br><span class="line"></span><br><span class="line">c = gp.mpz(140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751)</span><br><span class="line"></span><br><span class="line">for x in range(1, e):</span><br><span class="line">    if(e*dp%x==1):</span><br><span class="line">        p=(e*dp-1)//x+1</span><br><span class="line">        if(n%p!=0):</span><br><span class="line">            continue</span><br><span class="line">        q=n//p</span><br><span class="line">        phin=(p-1)*(q-1)</span><br><span class="line">        d=gp.invert(e, phin)</span><br><span class="line">        m=gp.powmod(c, d, n)</span><br><span class="line">        if(len(hex(m)[2:])%2==1):</span><br><span class="line">            continue</span><br><span class="line">        print(&#x27;--------------&#x27;)</span><br><span class="line">        print(m)</span><br><span class="line">        print(hex(m)[2:])</span><br><span class="line">        print(bytes.fromhex(hex(m)[2:]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-已知n-dp-dq-c求d和明文m"><a href="#2-已知n-dp-dq-c求d和明文m" class="headerlink" title="2.已知n,dp,dq,c求d和明文m"></a>2.已知n,dp,dq,c求d和明文m</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2 as gp</span><br><span class="line"></span><br><span class="line">p = gp.mpz()</span><br><span class="line">q = gp.mpz()</span><br><span class="line">dp = gp.mpz()</span><br><span class="line">dq = gp.mpz()</span><br><span class="line">c = gp.mpz()</span><br><span class="line"></span><br><span class="line">n = p*q</span><br><span class="line">phin = (p-1)*(q-1)</span><br><span class="line">dd = gp.gcd(p-1, q-1)</span><br><span class="line">d=(dp-dq)//dd * gp.invert((q-1)//dd, (p-1)//dd) * (q-1) +dq</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">m = gp.powmod(c, d, n)</span><br><span class="line">print(&#x27;-------------------&#x27;)</span><br><span class="line">print(m)</span><br><span class="line">print(hex(m)[2:])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-已知n，e，c求m"><a href="#3-已知n，e，c求m" class="headerlink" title="3.已知n，e，c求m"></a>3.已知n，e，c求m</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">def Decrypt(c,e,p,q):</span><br><span class="line">L=(p-1)*(q-1)</span><br><span class="line">d=gmpy2.invert(e,L)</span><br><span class="line">n=p*q</span><br><span class="line">m=gmpy2.powmod(c,d,n)</span><br><span class="line">flag=str(m)</span><br><span class="line">print(&quot;flag&#123;&quot;+flag+&quot;&#125;&quot;)</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">p =  9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483</span><br><span class="line">q =  11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407</span><br><span class="line">e =  65537</span><br><span class="line">c =  83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034</span><br><span class="line">Decrypt(c,e,p,q)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-已知ne求d"><a href="#4-已知ne求d" class="headerlink" title="4.已知ne求d"></a>4.已知ne求d</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util import number</span><br><span class="line">p = 473398607161</span><br><span class="line">q = 4511491</span><br><span class="line">e = 17</span><br><span class="line">d = gmpy2.invert(e,(p-1)*(q-1))</span><br><span class="line">print (d)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-已知n，e求d和key"><a href="#5-已知n，e求d和key" class="headerlink" title="5.已知n，e求d和key"></a>5.已知n，e求d和key</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import rsa</span><br><span class="line"></span><br><span class="line">p = 285960468890451637935629440372639283459</span><br><span class="line">q = 304008741604601924494328155975272418463</span><br><span class="line">e = 65537</span><br><span class="line">n = 86934482296048119190666062003494800588905656017203025617216654058378322103517</span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e,(q-1)*(p-1))</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">d = 81176168860169991027846870170527607562179635470395365333547868786951080991441</span><br><span class="line"></span><br><span class="line">key = rsa.PrivateKey(n,e,d,p,q)</span><br><span class="line">print(key)</span><br><span class="line"></span><br><span class="line">with open(&quot;flag.enc&quot;,&quot;rb&quot;) as f:</span><br><span class="line">print(rsa.decrypt(f.read(),key).decode())</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/31/%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95-%E9%A2%98%E5%BA%93/"/>
      <url>/2023/10/31/%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95-%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>title: 力扣面试+题库.md</p><p>date: 2023-10-31 23:25:04<br>tags: 算法<br>categories: 面试</p><h1 id="力扣面试-数据结构作业题库"><a href="#力扣面试-数据结构作业题库" class="headerlink" title="力扣面试+数据结构作业题库"></a>力扣面试+数据结构作业题库</h1><h2 id="1-合并有序数组"><a href="#1-合并有序数组" class="headerlink" title="1.合并有序数组"></a>1.合并有序数组</h2><p>两种思路，第一个交换</p><p><img src="https://pic.leetcode-cn.com/29ab5c730deb7ffec1d7854bbfdc1552a6829a6ac5da4e64e591150f08757e68-%E5%9B%BE%E7%89%87.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">    int i = nums1.size() - 1;</span><br><span class="line">    m--;</span><br><span class="line">    n--;</span><br><span class="line">    while (n &gt;= 0) &#123;</span><br><span class="line">        while (m &gt;= 0 &amp;&amp; nums1[m] &gt; nums2[n]) &#123;</span><br><span class="line">            swap(nums1[i--], nums1[m--]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums1[i--], nums2[n--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种，直接覆盖，在排列</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">            nums1[m + i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法三：双指针<br>算法</p><p>  已经被排序的性质。为了利用这一性质，我们可以使用双指针方法。这一方法将两个数组看作队列，每次从两个数组头部取出比较小的数字放到结果中。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sorted[m + n];</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == m) &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == n) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            sorted[p1 + p2 - <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != m + n; ++i) &#123;</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-移除元素"><a href="#2-移除元素" class="headerlink" title="2.移除元素"></a>2.移除元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(nums[i]==val)</span><br><span class="line">         &#123;</span><br><span class="line">             nums[i]=<span class="number">0</span>;</span><br><span class="line">             j++;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>()-j;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>由于题目要求删除数组中等于 val的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置。</p><p>如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</p><p>如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位。</p><p>整个过程保持不变的性质是：区间 [0,left) 中的元素都不等于 val。当左右指针遍历完输入数组以后，left 的值就是输出数组的长度。</p><p>这样的算法在最坏情况下（输入数组中没有元素等于 val），左右指针各遍历了数组一次。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != val) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度O（n)z至多遍历2次</p><p>空间复杂度O(1)</p><h3 id="双指针优化"><a href="#双指针优化" class="headerlink" title="双指针优化"></a>双指针优化</h3><p>如果要移除的元素恰好在数组的开头，例如序列 [1,2,3,4,5][1,2,3,4,5][1,2,3,4,5]，当 val为 111 时，我们需要把每一个元素都左移一位。注意到题目中说：「元素的顺序可以改变」。实际上我们可以直接将最后一个元素 555 移动到序列开头，取代元素 111，得到序列 [5,2,3,4][5,2,3,4][5,2,3,4]，同样满足题目要求。这个优化在序列中 val 元素的数量较少时非常有效。</p><p>实现方面，我们依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。</p><p>算法</p><p>如果左指针 left指向的元素等于 val，此时将右指针 right 指向的元素复制到左指针 left 的位置，然后右指针 right 左移一位。如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 val 为止。</p><p>当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素。</p><p>这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>;<span class="type">int</span> right=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]==val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[left]=nums[right<span class="number">-1</span>];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">                 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-删除有序数组中的重复项"><a href="#3-删除有序数组中的重复项" class="headerlink" title="3.删除有序数组中的重复项"></a>3.删除有序数组中的重复项</h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1.双指针"></a>1.双指针</h3><p>i为慢指针，指向答案位置</p><p>j为快指针，用来扫描</p><p>当nums[j]!&#x3D;nums[i],找到不重复项，复制到答案位置，i指针前进一步</p><h2 id="4-删除有序数组中的重复项二"><a href="#4-删除有序数组中的重复项二" class="headerlink" title="4.删除有序数组中的重复项二"></a>4.删除有序数组中的重复项二</h2><p>简单修改3就可</p><h2 id="5-多数元素"><a href="#5-多数元素" class="headerlink" title="5.多数元素"></a>5.多数元素</h2><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最简单的暴力方法是，枚举数组中的每个元素，再遍历一遍数组统计其出现次数。该方法的时间复杂度是 O(n2)O(n^2)O(n<br>2<br> )，会超出时间限制，因此我们需要找出时间复杂度小于 O(n2)O(n^2)O(n<br>2<br> ) 的优秀做法。</p><h4 id="1-方法一：哈希表"><a href="#1-方法一：哈希表" class="headerlink" title="1.方法一：哈希表"></a>1.方法一：哈希表</h4><p><a href="https://so.csdn.net/so/search?q=%E6%95%A3%E5%88%97%E8%A1%A8&spm=1001.2101.3001.7020">散列表</a>（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p><ul><li><p>哈希表也叫散列表</p></li><li><p>哈希表是一个数据结构</p></li><li><p>散列表是数组结构</p></li><li><pre><code class="c++">class Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int,int&gt;counts;        int majority =0,cnt =0;        for(int num:nums)        &#123;            ++counts[num];               if(counts[num]&gt;cnt)       &#123;           majority =num;           cnt =counts[num];       &#125;        &#125;return majority;    &#125;&#125;;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  首先创建一个哈希表counts，然后遍历数组nums</span><br><span class="line"></span><br><span class="line">  ![1695388913246](C:\Users\Nice\AppData\Roaming\Typora\typora-user-images\1695388913246.png)</span><br><span class="line"></span><br><span class="line">  用for的另外用法，对应的数的数组加一，进行打擂台形式选择最大项</span><br><span class="line"></span><br><span class="line">#### 2.摩根投票</span><br><span class="line"></span><br><span class="line">核心理念为 **票数正负抵消** 。此方法时间和空间复杂度分别为 O(N)和 O(1)，为本题的最佳解法。</span><br><span class="line"></span><br><span class="line">设输入数组 nums 的众数为 x ，数组长度为 n 。</span><br><span class="line"></span><br><span class="line">推论一： 若记 众数 的票数为 +1，非众数 的票数为 −1，则一定有所有数字的 票数和 &gt;0 。</span><br><span class="line"></span><br><span class="line">推论二： 若数组的前 a个数字的 票数和 =0，则 数组剩余 (n−a)个数字的 票数和一定仍 &gt;0，即后 (n−a) 个数字的 众数仍为 x 。</span><br><span class="line"></span><br><span class="line">。</span><br><span class="line"></span><br><span class="line">![Picture1.png](https://pic.leetcode-cn.com/1603612327-bOQxzq-Picture1.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 6.轮转数组</span><br><span class="line"></span><br><span class="line">给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 1.方法一</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;int&gt; newArr(n);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            newArr[(i + k) % n] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nums.assign(newArr.begin(), newArr.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>我们可以使用额外的数组来将每个元素放至正确的位置。用 n 表示数组的长度，我们遍历原数组，将原数组下标为 i 的元素放至新数组下标为 (i+k)mod n 的位置，最后将新数组拷贝至原数组即可。</p><ul><li>时间复杂度： O(n)，其中 n 为数组的长度。</li><li>空间复杂度： O(n</li></ul><p>(i+k)%n  轮转相当于对k进行模</p><h4 id="2-方法二：环状替换"><a href="#2-方法二：环状替换" class="headerlink" title="2.方法二：环状替换"></a>2.方法二：环状替换</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="type">int</span> count = <span class="built_in">gcd</span>(k, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; count; ++start) &#123;</span><br><span class="line">            <span class="type">int</span> current = start;</span><br><span class="line">            <span class="type">int</span> prev = nums[start];</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">int</span> next = (current + k) % n;</span><br><span class="line">                <span class="built_in">swap</span>(nums[next], prev);</span><br><span class="line">                current = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (start != current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法一中使用额外数组的原因在于如果我们直接将每个数字放至它最后的位置，这样被放置位置的元素会被覆盖从而丢失。因此，从另一个角度，我们可以将被替换的元素保存在变量 temp中，从而避免了额外数组的开销。</p><p>我们从位置0开始，最初令temp &#x3D; nums [0] 。根据规则，位置0的元素会放至(0＋ k) mod n的位置，令x&#x3D;(0＋k) mod n，此时交换temp和nums[x]，完成位置x的更新。然后，我们考察位置x，并交换temp和nums[(a ＋k) mod n]，从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置0。</p><p>容易发现，当回到初始位置 0 时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？我们不妨先考虑这样一个问题：从 0开始不断遍历，最终回到起点 0 的过程中，我们遍历了多少个元素？</p><p>由于最终回到了起点，故该过程恰好走了整数数量的圈，不妨设为 a 圈；再设该过程总共遍历了 b 个元素。因此，我们有 an&#x3D;bk即 an 一定为 n,k 的公倍数。又因为我们在第一次回到起点时就结束，因此 a要尽可能小，故 an 就是 n,k的最小公倍数 lcm(n,k)，因此 b 就为 lcm(n,k)&#x2F;k</p><p>这说明单次遍历会访问到 lcm(n,k)&#x2F;k 个元素。为了访问到所有的元素，我们需要进行遍历的次数为</p><p><img src="/.com//test-blog\source_posts\力扣面试题\1.png" alt="1"></p><p>其中 gcd 指的是最大公约数。</p><p>我们用下面的例子更具体地说明这个过程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums = [1, 2, 3, 4, 5, 6]</span><br><span class="line">k = 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/f0493a97cdb7bc46b37306ca14e555451496f9f9c21effcad8517a81a26f30d6-image.png" alt="image.png"></p><p>时间复杂度：O(n)，其中 n 为数组的长度。每个元素只会被遍历一次。</p><p>空间复杂度：O(1))。我们只需常数空间存放若干变量</p><h4 id="3-方法三：数组翻转"><a href="#3-方法三：数组翻转" class="headerlink" title="3.方法三：数组翻转"></a>3.方法三：数组翻转</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[start], nums[end]);</span><br><span class="line">            start += <span class="number">1</span>;</span><br><span class="line">            end -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, k, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该方法基于如下的事实：当我们将数组的元素向右移动 k 次后，尾部 k mod n 个元素会移动至数组头部，其余元素向后移动 k mod n 个位置。</p><p>该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的 k mod n个元素就被移至数组头部，然后我们再翻转[0,k mod n-1] 区间的元素和 [k mod n,n−1] 区间的元素即能得到最后的答案。</p><p>我们以 n&#x3D;7，k&#x3D;3为例进行如下展示：</p><p><img src="/.com//test-blog\source_posts\力扣面试题\2.png" alt="2"></p><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><h3 id="1-暴力法（遍历n-n-1-x2F-2找最大值）"><a href="#1-暴力法（遍历n-n-1-x2F-2找最大值）" class="headerlink" title="1.暴力法（遍历n*(n-1)&#x2F;2找最大值）"></a>1.暴力法（遍历n*(n-1)&#x2F;2找最大值）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> a =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                a=<span class="built_in">max</span>(a,prices[j]-prices[i]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度：O(n2)<br> )。循环运行 n(n−1)&#x2F;2</p><p>  次。<br>空间复杂度：O(1)。只使用了常数个变量。</p><h3 id="2-一次遍历法"><a href="#2-一次遍历法" class="headerlink" title="2.一次遍历法"></a>2.一次遍历法<img src="/.com//test-blog\source_posts\力扣面试题\3.png" alt="3"></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">        <span class="type">int</span> minprice = inf, maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price: prices) &#123;</span><br><span class="line">            maxprofit = <span class="built_in">max</span>(maxprofit, price - minprice);</span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。</p><p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。</p><ul><li>时间复杂度：O(n)，只需要遍历一次。</li><li>空间复杂度：O(1)，只使用了常数个变量。</li><li>差值最大却不在最低点买入的情况，这一定发生在到达股票最低点日子之前，记录 maxprofit 。 之后即使到了最低点，更改了 minprice, 但 maxprofit 却不会改变了。仍然是正确值</li></ul><h2 id="买卖股票的最佳时机2"><a href="#买卖股票的最佳时机2" class="headerlink" title="买卖股票的最佳时机2"></a>买卖股票的最佳时机2</h2><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="方法二：简单一次遍历"><a href="#方法二：简单一次遍历" class="headerlink" title="方法二：简单一次遍历"></a>方法二：简单一次遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> profit=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(prices[i]&gt;prices[i<span class="number">-1</span>])</span><br><span class="line">               &#123;</span><br><span class="line">                   profit+=prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="1-迭代法"><a href="#1-迭代法" class="headerlink" title="1.迭代法"></a>1.迭代法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>* <span class="built_in">ReverseList</span>(<span class="keyword">struct</span> ListNode* pHead ) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *curr = pHead;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        next = curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反转链表：<br>head    pre   next<br>1  -&gt;  2  -&gt;  3  -&gt;  4  -&gt;  5<br>head   pre    next<br>1  &lt;-  2      3  -&gt;  4  -&gt;  5<br>head    pre    next<br>1  &lt;-  2  &lt;-  3      4  -&gt;  5<br>head    pre    next<br>1  &lt;-  2  &lt;-  3  &lt;-  4      5<br>head    pre    next<br>1  &lt;-  2  &lt;-  3  &lt;-  4  &lt;-  5</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 将 curr 的下一个节点指向 prev：这一步是为了将当前节点 curr 的 next 指针指向它的前一个节点 prev。这样做的目的是为了使链表反转，将当前节点的指针方向改变，指向前一个节点。</span><br><span class="line"></span><br><span class="line">2. 将 prev 移动到 curr：这一步是为了将 prev 指针向右移动一位，使它指向 curr。这样做的目的是为了在下一次循环中，curr 的下一个节点仍然能够访问到它。</span><br><span class="line"></span><br><span class="line">3. 将 curr 移动到 next：这一步是为了将 curr 指针向右移动一位，使它指向 next。这样做的目的是为了在下一次循环中，将 curr 的下一个节点指向它的前一个节点。</span><br><span class="line"></span><br><span class="line">4. 将 next 移动到 curr 的下一个节点：这一步是为了将 next 指针向右移动一位，使它指向 curr 的下一个节点。这样做的目的是为了在下一次循环中，访问到 curr 的下一个节点。</span><br><span class="line"></span><br><span class="line">这些步骤综合起来，实际上就是在不断地将链表的指针方向进行反转，使得链表从原来的顺序变成相反的顺序。最后 prev 就会指向反转后链表的表头。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-递归法"><a href="#2-递归法" class="headerlink" title="2.递归法"></a>2.递归法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if (!head || !head-&gt;next) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = nullptr;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="for在c-的五种用法和string的用法"><a href="#for在c-的五种用法和string的用法" class="headerlink" title="for在c++的五种用法和string的用法"></a>for在c++的五种用法和string的用法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int nArray[] = &#123; 0, 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">vector&lt;int&gt; vecNum(nArray, nArray + 6);</span><br><span class="line">CString strText;</span><br><span class="line"> </span><br><span class="line">// 第一种用法：最原始的语法(用下标)</span><br><span class="line">for (size_t i = 0; i &lt; vecNum.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    strText.Format(&quot;%d&quot;, nArray[i]);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 第二种用法：最原始的语法(用迭代器)</span><br><span class="line">for (auto it = vecNum.begin(); it != vecNum.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    strText.Format(&quot;%d&quot;, *it);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 第三种用法：简化数组遍历语法(从vs2008开始支持)</span><br><span class="line">for each(auto item in vecNum)</span><br><span class="line">&#123;</span><br><span class="line">    strText.Format(&quot;%d&quot;, item);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 第四种用法：STL函数</span><br><span class="line">std::for_each(vecNum.begin(), vecNum.end(), [](int item)&#123;</span><br><span class="line">    CString strText;</span><br><span class="line">    strText.Format(&quot;%d&quot;, item);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// 第五种用法：C++11新增加的(VS2012支持)</span><br><span class="line">for(auto item : vecNum)</span><br><span class="line">&#123;</span><br><span class="line">    strText.Format(&quot;%d&quot;, item);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C++string类常用方法</span><br><span class="line">1、string(const char *s) ：将 string 对象初始化为 s 指向的字符串</span><br><span class="line"></span><br><span class="line">string str(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">string(size_type n,char c) ：创建一个包含 n 个元素的 string 对象，其中每个元素都被初始化为字符 c</span><br><span class="line"></span><br><span class="line">string str(10, &#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line">string(const string &amp;str) ：将一个 string 对象初始化为 string 对象 str（复制构造函数）</span><br><span class="line"></span><br><span class="line">string str(&quot;abcde&quot;);</span><br><span class="line">string str2(str);</span><br><span class="line">string() ：创建一个默认的 string 对象，长度为 0（默认构造函数）</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">使用C语言风格字符串处理string对象</span><br><span class="line"></span><br><span class="line">string str = &quot;hello!&quot;;</span><br><span class="line">获取string对象的长度，C语言中使用strlen()来获取字符串长度，C++中使用str.size()或str.length().</span><br><span class="line"></span><br><span class="line">string str(&quot;hello!&quot;);</span><br><span class="line">int len1 = str.size();</span><br><span class="line">int len2 = str.length();</span><br><span class="line"></span><br><span class="line">将一个 string 对象赋值给另一个 string 对象</span><br><span class="line"></span><br><span class="line">string str(&quot;hello!&quot;);</span><br><span class="line">string str2;</span><br><span class="line">str2 = str;</span><br><span class="line"></span><br><span class="line">8、string 对象的拼接</span><br><span class="line">C 语言中使用 strcat、strncat 函数来进行字符串拼接操作，C++中可以采用以下方式：</span><br><span class="line"></span><br><span class="line">string str1(&quot;hello&quot;);</span><br><span class="line">string str2(&quot;world&quot;);</span><br><span class="line">string str3 = str1 + str2;</span><br><span class="line"></span><br><span class="line">9、使用 += 来在一个 string 对象后面附加一个 string 对象、字符以及 C 风格的字符串</span><br><span class="line"></span><br><span class="line">string str(&quot;hello&quot;);</span><br><span class="line">string str2(&quot;world&quot;);</span><br><span class="line">str += str2;</span><br><span class="line">str += &#x27;a&#x27;;</span><br><span class="line">str += &quot;abcd&quot;;</span><br><span class="line"></span><br><span class="line">10、string.append() 函数，在string对象后添加一个string对象或c风格字符串。</span><br><span class="line"></span><br><span class="line">string str(&quot;hello&quot;);</span><br><span class="line">string str2(&quot;world&quot;);</span><br><span class="line">str.append(str2);</span><br><span class="line">str.append(&quot;abcd&quot;);</span><br><span class="line"></span><br><span class="line">11、string.push_back() 函数来在一个 string 对象后面附加一个字符</span><br><span class="line"></span><br><span class="line">string str(&quot;hello&quot;);</span><br><span class="line">char ch = &#x27;a&#x27;;</span><br><span class="line">str.push_back(ch);</span><br><span class="line"></span><br><span class="line">12、对于string对象的比较，可以直接使用关系运算符。</span><br><span class="line"></span><br><span class="line">string str1(&quot;abcd&quot;);</span><br><span class="line">string str2(&quot;abcd&quot;);</span><br><span class="line">if(str1 == str2)</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">13、string对象的比较也可以使用string.compare() 方法</span><br><span class="line"></span><br><span class="line">int compare(const string&amp;str) const;</span><br><span class="line">int compare(size_t pos，size_t len，const string&amp;str)const;</span><br><span class="line">int compare(size_t pos，size_t len，const string&amp;str, size_t subpos，size_t sublen)const;</span><br><span class="line">int compare(const char * s)const;</span><br><span class="line">int compare(size_t pos，size_t len，const char * s)const;</span><br><span class="line">int compare(size_t pos，size_t len，const char * s，size_t n)const;</span><br><span class="line"></span><br><span class="line">// example</span><br><span class="line">string str1(&quot;hello world&quot;);</span><br><span class="line">string str2(&quot;hello boy&quot;);</span><br><span class="line">str1.compare(6, 3, str2, 6, 3);</span><br><span class="line"></span><br><span class="line">14、使用 string.substr() 函数来获取子串</span><br><span class="line"></span><br><span class="line">string str(&quot;hello&quot;);</span><br><span class="line">string str2 = str.substr(3,2)</span><br><span class="line"></span><br><span class="line">15、访问 string 字符串的元素</span><br><span class="line"></span><br><span class="line">string str(&quot;hello&quot;);</span><br><span class="line">cout &lt;&lt; str[2] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str.at(2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">16、使用 string.find() 方法查找字符</span><br><span class="line"></span><br><span class="line">//  从字符串的 pos 位置开始（若不指定 pos 的值，则默认从索引 0 处开始），查找子字符串 str。</span><br><span class="line">//  如果找到，则返回该子字符串首次出现时其首字符的索引；否则，返回 string::npos：</span><br><span class="line">//  string 类将 npos 定义为保证大于任何有效下标的值。</span><br><span class="line">size_type find (const string&amp; str, size_type pos = 0) const;</span><br><span class="line">size_type find (const char *s, size_type pos = 0) const;</span><br><span class="line">size_type find (const char *s, size_type pos, size_type n);</span><br><span class="line">size_type find (char ch, size_type pos = 0) const;</span><br><span class="line"></span><br><span class="line">17、string.rfind() 与 string.find() 方法类似，只是查找顺序不一样， string.rfind() 是从指定位置 pos （默认为字符串末尾）开始向前查找，直到字符串的首部，并返回第一次查找到匹配项时匹配项首字符的索引。换句话说，就是查找子字符串或字符最后一次出现的位置。</span><br><span class="line"></span><br><span class="line">18、string.find_first_of() 方法在字符串中从指定位置开始向后（默认为索引 0 处）查找参数中任何一个字符首次出现的位置</span><br><span class="line"></span><br><span class="line">string str(&quot;hello world&quot;);</span><br><span class="line">int pos = str.find_first_of(&quot;abcde&quot;);</span><br><span class="line">int pos = str.find_first_of(&quot;abcde&quot;, 1);  // 第二个参数为位置</span><br><span class="line"></span><br><span class="line">19、string.find_last_of() 方法在字符串中查找参数中任何一个字符最后一次出现的位置</span><br><span class="line"></span><br><span class="line">20、string.find_first_not_of() 方法在字符串中查找第一个不包含在参数中的字符</span><br><span class="line"></span><br><span class="line">21、string.find_last_not_of() 方法在字符串中查找最后一个不包含在参数中的字符</span><br><span class="line"></span><br><span class="line">22、使用 string.insert() 进行插入操作</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，const string＆str）;　　　</span><br><span class="line">// 在位置 pos 处插入字符串 str</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，const string＆str，size_t subpos，size_t sublen）;　</span><br><span class="line">// 在位置 pos 处插入字符串 str 的从位置 subpos 处开始的 sublen 个字符</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，const char * s）;　　　　</span><br><span class="line">// 在位置 pos 处插入字符串 s</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，const char * s，size_t n）;　</span><br><span class="line">// 在位置 pos 处插入字符串 s 的前 n 个字符</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，size_t n，char c）;　　　　　 </span><br><span class="line">// 在位置 pos 处插入 n 个字符 c</span><br><span class="line"></span><br><span class="line">iterator insert (const_iterator p, size_t n, char c);　</span><br><span class="line">// 在 p 处插入 n 个字符 c，并返回插入后迭代器的位置</span><br><span class="line"></span><br><span class="line">iterator insert (const_iterator p, char c);　　　　　　 </span><br><span class="line">// 在 p 处插入字符 c，并返回插入后迭代器的位置</span><br><span class="line"></span><br><span class="line">23、使用 string.erase() 进行元素删除操作</span><br><span class="line"></span><br><span class="line">string&amp; erase (size_t pos = 0, size_t len = npos);　　　// 删除从 pos 处开始的 n 个字符</span><br><span class="line">iterator erase (const_iterator p);　　　　　　　　　　　　// 删除 p 处的一个字符，并返回删除后迭代器的位置</span><br><span class="line">iterator erase (const_iterator first, const_iterator last);　// 删除从 first 到last 之间的字符，并返回删除后迭代器的位置</span><br><span class="line"></span><br><span class="line">24、使用 getline() 函数来获取 string 输入</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">getline(cin, str);</span><br><span class="line"></span><br><span class="line">25、使用 string.empty() 函数判断字符串是否为空</span><br><span class="line"></span><br><span class="line">26、使用 string.swap() 函数交换两个字符串</span><br><span class="line"></span><br><span class="line">string str1 = &quot;hello&quot;;</span><br><span class="line">string str2 = &quot;HELLO&quot;;</span><br><span class="line">str1.swap(str2);</span><br><span class="line"></span><br><span class="line">27、string.back()获取或修改字符串最后一个字符</span><br><span class="line"></span><br><span class="line">string str(&quot;abcd&quot;);</span><br><span class="line">char b = str.back();</span><br><span class="line">str.back() = &#x27;e&#x27;;</span><br><span class="line"></span><br><span class="line">28、string.front()获取或修改字符串第一个字符</span><br><span class="line"></span><br><span class="line">29、string.pop_back()删除字符串最后一个元素</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作业题库1-括号匹配（用顺序栈）"><a href="#作业题库1-括号匹配（用顺序栈）" class="headerlink" title="作业题库1 括号匹配（用顺序栈）"></a>作业题库1 括号匹配（用顺序栈）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ElemType char</span><br><span class="line">#define MaxSize 50</span><br><span class="line"></span><br><span class="line">typedef struct//自定义名为SqStack的栈</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    int top;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line">bool StackEmpty(SqStack S)//判断是否为空栈</span><br><span class="line">&#123;</span><br><span class="line">    if (S.top == -1)</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Pop(SqStack&amp; S, ElemType&amp; x)//出栈</span><br><span class="line">&#123;</span><br><span class="line">    if (S.top == -1)</span><br><span class="line">        return false;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    S.top--;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Push(SqStack&amp; S, ElemType x)//入栈</span><br><span class="line">&#123;</span><br><span class="line">    if (S.top == MaxSize - 1)</span><br><span class="line">        return false;</span><br><span class="line">    S.top++;</span><br><span class="line">    S.data[S.top] = x;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool GetPop(SqStack S, ElemType&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    if (S.top == -1)</span><br><span class="line">        return false;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void initStack(SqStack&amp; S)</span><br><span class="line">&#123;</span><br><span class="line">    S.top = -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    initStack(S);</span><br><span class="line">    string v;</span><br><span class="line">    getline(cin, v);</span><br><span class="line">    vector&lt;char&gt; c;</span><br><span class="line">    for (int i = 0; i &lt; v.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (v[i] == &#x27;(&#x27; || v[i] == &#x27;)&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            c.push_back(v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int b = 0;</span><br><span class="line">    char a;</span><br><span class="line">    int flag = 1;</span><br><span class="line">    while (b &lt; c.size() &amp;&amp; flag != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        a = c[b];</span><br><span class="line">        if (a == &#x27;(&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(S, a);</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            char getpop;</span><br><span class="line">            GetPop(S, getpop);</span><br><span class="line">            if (getpop == &#x27;(&#x27; &amp;&amp; a == &#x27;)&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                char pop;</span><br><span class="line">                Pop(S, pop);</span><br><span class="line">                b++;</span><br><span class="line">                flag = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                flag = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (StackEmpty(S) &amp;&amp; flag == 1)</span><br><span class="line">        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作业题库2-回文序列（用链栈）"><a href="#作业题库2-回文序列（用链栈）" class="headerlink" title="作业题库2 回文序列（用链栈）"></a>作业题库2 回文序列（用链栈）</h2><p>“回文”指正读反读均相同的字符序列，如“abcdcba”和“abba”均是回文，使用栈这种数据结构判断给定字符序列是否为回文，要求使用链栈实现。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;//stl容器</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">bool isPalindrome(string str) &#123;</span><br><span class="line">    stack&lt;char&gt; st;</span><br><span class="line">    int len = str.length();</span><br><span class="line"></span><br><span class="line">    // 将字符序列依次入栈</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        st.push(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 依次比较栈顶和栈底指针指向的字符</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        char topChar = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line"></span><br><span class="line">        if (topChar != str[i]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">    if (isPalindrome(str)) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;true&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;false&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题库3入栈和出栈"><a href="#题库3入栈和出栈" class="headerlink" title="题库3入栈和出栈"></a>题库3入栈和出栈</h2><p>给定一个正整数数列（以0表示输入结束），从第一个数开始，将每一个数入栈，入栈的同时获得一个分数，即该数的数值乘以入栈后栈的大小，请计算将所有元素入栈后的分数和，然后将栈内元素依次输出，要求使用顺序栈。元素个数&lt;100，每个元素&lt;100。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>;; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; str[i];</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum += (i+<span class="number">1</span>) * str[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = i;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="comment">// 将字符序列依次入栈</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;i ; j++) &#123;</span><br><span class="line">st.<span class="built_in">push</span>(str[j]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; st.<span class="built_in">top</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_SIZE = 100; // 栈的最大容量</span><br><span class="line"></span><br><span class="line">class Stack &#123;</span><br><span class="line">private:</span><br><span class="line">    int* data; // 栈的数组</span><br><span class="line">    int top; // 栈顶指针</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Stack() &#123;</span><br><span class="line">        data = new int[MAX_SIZE];</span><br><span class="line">        top = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Stack() &#123;</span><br><span class="line">        delete[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isEmpty() &#123;</span><br><span class="line">        return top == -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isFull() &#123;</span><br><span class="line">        return top == MAX_SIZE - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Stack is full. Cannot push more elements.&quot; &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        data[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Stack is empty. Cannot pop any element.&quot; &lt;&lt; endl;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int value = data[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getSize() &#123;</span><br><span class="line">        return top + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Stack stack;</span><br><span class="line">    int num, scoreSum = 0;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    while (num != 0) &#123;</span><br><span class="line">        stack.push(num);</span><br><span class="line">        int score = stack.getSize() * num; // 计算分数</span><br><span class="line">        scoreSum += score;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">    &#125;</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        int value = stack.pop();</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题库4-点击消除"><a href="#题库4-点击消除" class="headerlink" title="题库4     点击消除"></a>题库4     点击消除</h2><p>给定一个字符串，每次“点击”，可以把字符串中相邻两个相同字母消除，例如，字符串”abbc”点击后可以生成”ac”。但相同而不相邻、不相同的相邻字母都是不可以被消除的。<br>通过点击足够多次之后可以把字符串变得尽可能短，编程实现输出给定字符串足够多次点击后的最终形态。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ol><li>初始化一个空栈。</li><li>依次遍历字符串中的每个字符：<ul><li>如果栈为空，将当前字符入栈。</li><li>如果栈不为空且当前字符与栈顶字符相同，将栈顶字符出栈。</li><li>如果栈不为空且当前字符与栈顶字符不相同，将当前字符入栈。</li></ul></li><li>栈中剩余的字符即为点击足够多次后的最终形态。</li></ol><h2 id="题库5-周末舞会"><a href="#题库5-周末舞会" class="headerlink" title="题库5 周末舞会"></a>题库5 周末舞会</h2><p>假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头上各出一人配成舞伴。规定每个舞曲能有一对跳舞者。若两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。现要求写一个程序，模拟上述舞伴配对问题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxqsize 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dancePartner</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; males;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; females;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        males.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        females.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (males.<span class="built_in">empty</span>() || females.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> male = males.<span class="built_in">front</span>();</span><br><span class="line">        males.<span class="built_in">push</span>(male);</span><br><span class="line">        males.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> female = females.<span class="built_in">front</span>();</span><br><span class="line">        females.<span class="built_in">pop</span>();</span><br><span class="line">        females.<span class="built_in">push</span>(female);</span><br><span class="line">        cout &lt;&lt; male &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; female &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n, k;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">        cin&gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dancePartner</span>(m, n, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>采用STL库里的queue队列库，将其变成循环队列就好</p><h2 id="题库6-无法吃午餐的学生数量"><a href="#题库6-无法吃午餐的学生数量" class="headerlink" title="题库6  无法吃午餐的学生数量"></a>题库6  <strong>无法吃午餐的学生数量</strong></h2><p>学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：<br>1.如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。<br>否则，这名学生会 放弃这个三明治 并回到队列的尾部。<br>2.这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。</p><p>输入两个整数数组 students 和 sandwiches ，其中 sandwiches[i] 是栈里面第 i个三明治的类型（i &#x3D; 0 是栈的顶部）， students[j] 是初始队列里第 j名学生对三明治的喜好（j &#x3D; 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#define maxqsize 1000</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">void Partner(int *a,int *b, int len) &#123;</span><br><span class="line">    queue&lt;int&gt; studentsqueue;</span><br><span class="line">    stack&lt;int&gt; sandwichesstack;</span><br><span class="line">    int  unhappyCount = 0;</span><br><span class="line">    for (int i = 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        studentsqueue.push(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = len-1; i&gt;=0; i--) &#123;</span><br><span class="line">        sandwichesstack.push(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (!studentsqueue.empty() &amp;&amp; !sandwichesstack.empty()) &#123;</span><br><span class="line">        int frontStudent = studentsqueue.front();</span><br><span class="line">        int topSandwich = sandwichesstack.top();</span><br><span class="line"></span><br><span class="line">        if (frontStudent == topSandwich) &#123;</span><br><span class="line">            // 学生喜欢栈顶的三明治，拿走它并离开队列</span><br><span class="line">            studentsqueue.pop();</span><br><span class="line">            sandwichesstack.pop();</span><br><span class="line">            unhappyCount = 0; // 重置无法吃午餐的学生数量</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 学生不喜欢栈顶的三明治，放弃它并排到队尾</span><br><span class="line">            studentsqueue.pop();</span><br><span class="line">            studentsqueue.push(frontStudent);</span><br><span class="line">            unhappyCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查队列中剩余学生的喜好是否与栈顶的三明治类型相同</span><br><span class="line">        if (unhappyCount == studentsqueue.size()) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; studentsqueue.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int students[100];</span><br><span class="line">    int sandwiches[100];</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    for ( i = 0;; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; students[i];</span><br><span class="line"></span><br><span class="line">        if (students[i] == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (j = 0;; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; sandwiches[j];</span><br><span class="line"></span><br><span class="line">        if (sandwiches[j] == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Partner(students,sandwiches,i);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>队列是先进先出，栈是先进后出，不满意口味的当unhappystudents数量等于目前队列长度则跳出循环</p><h2 id="题库7-栈的操作"><a href="#题库7-栈的操作" class="headerlink" title="题库7  栈的操作"></a>题库7  栈的操作</h2><p>请你实现一个栈。<br>可以完成操作：<br>push x：将 x入栈，保证 x为 int 型整数。<br>pop：输出栈顶，并让栈顶出栈<br>top：输出栈顶，栈顶不出栈</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;str;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">string a;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getline</span>(cin, a);</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">string b;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">5</span>; j &lt; a.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line">b[sum] = a[j];</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">stoi</span>(b);</span><br><span class="line">str.<span class="built_in">push</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">str.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt;str.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题库-8-栈的压入、弹出序列"><a href="#题库-8-栈的压入、弹出序列" class="headerlink" title="题库 8 栈的压入、弹出序列"></a><strong>题库 8 栈的压入、弹出序列</strong></h2><p>对输入的两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p><ol><li>栈中数据的数量≤1000<br>\2. push 的所有数字均不相同</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">bool isPopOrderPossible(const vector&lt;int&gt;&amp; pushOrder, const vector&lt;int&gt;&amp; popOrder) &#123;</span><br><span class="line">    stack&lt;int&gt; stack;//辅助栈</span><br><span class="line">    int pushIndex = 0;//初始化了一个指针pushIndex，用于遍历压入序列。</span><br><span class="line">    //循环来遍历弹出序列中的每个元素</span><br><span class="line">    for (int popIndex = 0; popIndex &lt; popOrder.size(); ++popIndex) &#123;</span><br><span class="line">        while (stack.empty() || stack.top() != popOrder[popIndex]) &#123;</span><br><span class="line">            if (pushIndex == pushOrder.size()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(pushOrder[pushIndex]);</span><br><span class="line">            ++pushIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return stack.empty() &amp;&amp; pushIndex == pushOrder.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; pushOrder;</span><br><span class="line">    vector&lt;int&gt; popOrder;//压入序列和弹出序列</span><br><span class="line">    int num ;</span><br><span class="line">    while (cin &gt;&gt; num &amp;&amp; num != -1) &#123;</span><br><span class="line">        pushOrder.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输入栈的弹出顺序</span><br><span class="line">    while (cin &gt;&gt; num &amp;&amp; num != -1) &#123;</span><br><span class="line">        popOrder.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; boolalpha;  // Print &quot;true&quot; or &quot;false&quot; instead of &quot;1&quot; or &quot;0&quot;</span><br><span class="line">   cout  &lt;&lt; isPopOrderPossible(pushOrder, popOrder) &lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>判断第二个序列是否可能为该栈的弹出顺序的原理基于以下观察：</p><ol><li><p>对于一个元素进栈后，它只能出栈一次。</p></li><li><p>如果一个元素出栈，那么它之前所有比它先进栈的元素都应该已经出栈了。</p></li><li><p>首先，我们定义了一个<code>isPopOrderPossible</code>函数，该函数接受两个参数：<code>pushOrder</code>和<code>popOrder</code>，分别表示压入序列和弹出序列。</p></li><li><p>在函数内部，我们创建了一个辅助栈<code>stack</code>，用于模拟栈的压入和弹出操作。同时，我们初始化了一个指针<code>pushIndex</code>，用于遍历压入序列。</p></li><li><p>接下来，我们使用一个循环来遍历弹出序列中的每个元素。</p></li><li><p>在循环中，我们首先检查辅助栈是否为空或栈顶元素是否与当前弹出元素相等。如果不相等，则说明该元素要么还未进栈，要么已经出栈但不在栈顶。此时，我们需要将压入序列中的元素进栈，直到找到与当前弹出元素相等的元素为止，或者压入序列中的所有元素都进栈了。</p></li><li><p>如果压入序列的指针<code>pushIndex</code>已经遍历完所有元素，但栈顶元素仍然不等于当前弹出元素，说明无法找到与当前弹出元素相等的元素，即第二个序列不可能是该栈的弹出序列。因此，我们返回<code>false</code>。</p></li><li><p>如果栈顶元素等于当前弹出元素，我们将栈顶元素出栈，并移动弹出序列的指针。</p></li><li><p>循环结束后，我们需要检查辅助栈是否为空且压入序列的指针是否已经遍历完所有元素。如果这两个条件都满足，说明第二个序列可能是该栈的弹出序列，我们返回<code>true</code>；否则，返回<code>false</code>。</p></li></ol><h2 id="题库9-最长有效括号"><a href="#题库9-最长有效括号" class="headerlink" title="题库9  最长有效括号"></a>题库9  最长有效括号</h2><p>给你一个只包含 ‘(’ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度</p><h3 id="第一种-不用栈，用count表示左括号"><a href="#第一种-不用栈，用count表示左括号" class="headerlink" title="第一种  不用栈，用count表示左括号"></a>第一种  不用栈，用count表示左括号</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> longest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">                len += <span class="number">2</span>;</span><br><span class="line">                longest = <span class="built_in">max</span>(longest, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遇到右括号且没有与之匹配的左括号，重新开始计算长度</span></span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">longestValidParentheses</span>(str);</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="第二种用栈"><a href="#第二种用栈" class="headerlink" title="第二种用栈"></a>第二种用栈</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string str;</span><br><span class="line">getline(cin, str);</span><br><span class="line">stack&lt;char&gt;strstack;</span><br><span class="line">int num = 0;</span><br><span class="line">char a;</span><br><span class="line">int len = 0;</span><br><span class="line">while (num &lt; str.size())</span><br><span class="line">&#123;</span><br><span class="line">a = str[num];</span><br><span class="line">if (a == &#x27;(&#x27;)</span><br><span class="line">&#123;</span><br><span class="line">strstack.push(a);</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">/*if (strstack.empty() &amp;&amp; a == &#x27;)&#x27;)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;*/</span><br><span class="line">if (!strstack.empty())</span><br><span class="line">&#123;</span><br><span class="line">if (strstack.top() == &#x27;(&#x27; &amp;&amp; a == &#x27;)&#x27;)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">strstack.pop();</span><br><span class="line">num++;</span><br><span class="line">len += 2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题库-11-找出游戏胜利者"><a href="#题库-11-找出游戏胜利者" class="headerlink" title="题库 11  找出游戏胜利者"></a>题库 11  找出游戏胜利者</h2><p>共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 &lt;&#x3D; i &lt; n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。<br>游戏遵循如下规则：</p><ul><li>从第 1 名小伙伴所在位置 开始 。</li><li>沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li><li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li><li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行</li><li>否则，圈子中最后一名小伙伴赢得游戏。</li></ul><p>给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int findTheWinner(int n, int k) &#123;</span><br><span class="line">    std::queue&lt;int&gt; circle;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        circle.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (circle.size() &gt; 1) &#123;</span><br><span class="line">        for (int i = 1; i &lt; k; ++i) &#123;</span><br><span class="line">            circle.push(circle.front());</span><br><span class="line">            circle.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        // 将被淘汰的人移出队列</span><br><span class="line">        circle.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return circle.front();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    int k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    int winner = findTheWinner(n, k);</span><br><span class="line">    cout &lt;&lt; winner &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 &lt;&#x3D; i &lt; n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。<br>游戏遵循如下规则：</p><ul><li>从第 1 名小伙伴所在位置 开始 。</li><li>沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li><li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li><li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行</li><li>否则，圈子中最后一名小伙伴赢得游戏。</li></ul><p>给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。</p><h1 id="作业题库-数组和串"><a href="#作业题库-数组和串" class="headerlink" title="作业题库 数组和串"></a>作业题库 数组和串</h1><h2 id="1-数组与串-小鱼比可爱"><a href="#1-数组与串-小鱼比可爱" class="headerlink" title="1.数组与串-小鱼比可爱"></a>1.<strong>数组与串-小鱼比可爱</strong></h2><p>人比人，气死人；鱼比鱼，难死鱼。小鱼最近参加了一个“比可爱”比赛，比的是每只鱼的可爱程度。参赛的鱼被从左到右排成一排，头都朝向左边，然后每只鱼会得到一个整数数值，表示这只鱼的可爱程度，很显然整数越大，表示这只鱼越可爱，而且任意两只鱼的可爱程度可能一样。由于所有的鱼头都朝向左边，所以每只鱼只能看见在它左边的鱼的可爱程度，它们心里都在计算，在自己的眼力范围内有多少只鱼不如自己可爱呢。请你帮这些可爱但是鱼脑不够用的小鱼们计算一下。</p><p>输入：<br>6<br>4 3 0 5 1 2<br>输出：<br>0 0 0 3 1 2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n = 0;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">int arr[1000];</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">&#125;</span><br><span class="line">int number[1000];</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">int num = 0;//记录有几个可爱</span><br><span class="line">for (int j = i; j &gt;= 0; j--)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[i] &gt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">number[i] = num;</span><br><span class="line">&#125;</span><br><span class="line">for (int k = 0; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; number[k]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-数组与串-杨辉三角"><a href="#2-数组与串-杨辉三角" class="headerlink" title="2.数组与串-杨辉三角"></a>2.数组与串-杨辉三角</h2><p>给出 n(n≤20)，输出杨辉三角的前 n 行。<br>如果你不知道什么是杨辉三角，可以观察样例找找规律。</p><p>输入: 6<br>输出:<br>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br>1 5 10 10 5 1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string yanghui(int numRows) &#123;</span><br><span class="line">   string result;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; numRows; i++) &#123;</span><br><span class="line">        int num = 1;</span><br><span class="line">        for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">            result += to_string(num) + &quot; &quot;;</span><br><span class="line">            num = num * (i - j) / (j + 1);//为了打印后续重复的</span><br><span class="line">        &#125;</span><br><span class="line">        result += &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int numRows;</span><br><span class="line">    cin &gt;&gt; numRows;</span><br><span class="line">    string str = yanghui(numRows);</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>string 用to_string将数字转变为字符</p><h2 id="3-数组与串-冰雹猜想"><a href="#3-数组与串-冰雹猜想" class="headerlink" title="3.数组与串-冰雹猜想"></a><strong>3.数组与串-冰雹猜想</strong></h2><p>给出一个正整数 n，然后对这个数字一直进行下面的操作：如果这个数字是奇数，那么将其乘 3 再加 1，否则除以 2。经过若干次循环后，最终都会回到 1。经过验证很大的数字（7*10^{11}）都可以按照这样的方式比变成 1，所以被称为“冰雹猜想”。例如当 n 是 2020，变化的过程是20→10→5→16→8→4→2→1。</p><p>输入描述</p><p>输入一个正整数 n。</p><p>输出描述</p><p>输出若干个由空格隔开的正整数，表示从最后的 1 开始倒序的变化数列。</p><p>输入输出样例</p><p>输入：20<br>输出：1 2 4 8 16 5 10 20</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int num = 0;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line">int arr[1000];</span><br><span class="line">arr[0] = num;</span><br><span class="line">int size = 1;</span><br><span class="line">while (num != 1)</span><br><span class="line">&#123;</span><br><span class="line">if (num % 2 != 0)</span><br><span class="line">&#123;</span><br><span class="line">num = num * 3 + 1;</span><br><span class="line">arr[size] = num;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">num = num / 2;</span><br><span class="line">arr[size] = num;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = size - 1; i &gt;= 0; i--)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-数组与串-液晶屏"><a href="#5-数组与串-液晶屏" class="headerlink" title="5.数组与串-液晶屏"></a>5.<strong>数组与串-液晶屏</strong></h2><p>液晶屏上，每个阿拉伯数字都是可以显示成 3×5 的点阵的（其中 X 表示亮点，. 表示暗点）。现在给出数字位数（不超过 100）和一串数字，要求输出这些数字在显示屏上的效果。数字的显示方式如同样例输出，注意每个数字之间都有一列间隔。</p><p>输入描述</p><p>第一行输入一个正整数 n，表示数字的位数。<br>第二行输入一个长度为 n 的自然数</p><p>输出描述</p><p>输出五行，表示显示屏上的数字。<br>有些同学反应看不懂，这里观察一下就知道了<br>每个数字是一个3×5的矩阵<br>每个数字之间用一个1×5的.相隔<br>这里输出有点显示字符占位不一样，导致显示问题。<br>这里我添加一张图片方便大家观察</p><p><img src="http://acm.scu.edu.cn/teach/data/problem/1550/image.png" alt="none"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define MAXSIZE 101</span><br><span class="line">const char digits[10][5][4] = &#123;</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;XXX&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X  &quot;,</span><br><span class="line">&quot;XXX&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;XXX&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X  &quot;,</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;XXX&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X  &quot;,</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;XXX&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;XXX&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;XXX&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n = 0;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">char str[MAXSIZE];</span><br><span class="line">scanf(&quot;%s&quot;, str);</span><br><span class="line">int row, col;</span><br><span class="line">for (row = 0; row &lt; 5; row++) &#123;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">int digit = str[i] - &#x27;0&#x27;; // 将字符数字转换为整数</span><br><span class="line">for (col = 0; col &lt; 3; col++) &#123;</span><br><span class="line">if (digits[digit][row][col] == &#x27;X&#x27;) &#123;</span><br><span class="line">printf(&quot;X&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">printf(&quot;.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (i &lt; n - 1) &#123;</span><br><span class="line">printf(&quot;.&quot;); // 数字之间用点隔开</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义三维数组，</p><h2 id="6-n皇后问题"><a href="#6-n皇后问题" class="headerlink" title="6.n皇后问题"></a>6.n皇后问题</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>题目难度 LeetCode+简单</p><p>输入一个数组</p><p>输出描述</p><p>输出方案总数</p><p>输入输出样例</p><p>输入：n &#x3D; 4<br>输出：2</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n,string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;<span class="comment">//创建棋盘</span></span><br><span class="line">        <span class="built_in">solveNQueens</span>(board, <span class="number">0</span>, count);<span class="comment">//核心函数,回溯皇后</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveNQueens</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span>&amp; count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; board.<span class="built_in">size</span>(); col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isSafe</span>(board, row, col)) &#123;</span><br><span class="line">                board[row][col] = <span class="string">&#x27;Q&#x27;</span>;<span class="comment">//是安全的，就可以放皇后</span></span><br><span class="line">                <span class="built_in">solveNQueens</span>(board, row + <span class="number">1</span>, count);<span class="comment">//检查下一行</span></span><br><span class="line">                board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSafe</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;<span class="comment">//判断是不是有没有皇后，是不是安全的</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左上是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row, j = col; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查右上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row, j = col; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; board.<span class="built_in">size</span>(); i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n ;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="type">int</span> result = solution.<span class="built_in">totalNQueens</span>(n);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSafe</span><span class="params">(<span class="type">int</span> board[], <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the column</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i] == col || <span class="built_in">abs</span>(board[i] - col) == <span class="built_in">abs</span>(i - row)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> board[], <span class="type">int</span> row, <span class="type">int</span> n, <span class="type">int</span> *count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        (*count)++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSafe(board, row, col, n)) &#123;</span><br><span class="line">            board[row] = col;</span><br><span class="line">            solveNQueens(board, row + <span class="number">1</span>, n, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> board[n];</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    solveNQueens(board, <span class="number">0</span>, n, &amp;count);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> result = totalNQueens(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作业题库：二叉树"><a href="#作业题库：二叉树" class="headerlink" title="作业题库：二叉树"></a>作业题库：二叉树</h2><h3 id="1-相同的树"><a href="#1-相同的树" class="headerlink" title="1.相同的树"></a>1.<strong>相同的树</strong></h3><p><img src="http://acm.scu.edu.cn/teach/data/problem/1562/11.png" alt="11.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char arr1[10000];</span><br><span class="line">char arr2[10000];</span><br><span class="line">char s=1;</span><br><span class="line">char t = 1;</span><br><span class="line">int num1=0;</span><br><span class="line">    int num2=0;</span><br><span class="line">string str1, str2;</span><br><span class="line">getline(cin, str1);</span><br><span class="line">getline(cin, str2);</span><br><span class="line">if (str1 == str2)</span><br><span class="line">cout &lt;&lt; &quot;true&quot;;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;false&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接比较字符串是否相同</p><h3 id="2-二叉树的中序遍历"><a href="#2-二叉树的中序遍历" class="headerlink" title="2.二叉树的中序遍历**"></a>2.二叉树的中序遍历**</h3><p>给你一个二叉树的根节点root，检查它是否轴对称。</p><p>输入描述<br>一个节点序列</p><p>输出描述<br>真假</p><p>输入输出样例</p><p>输入<br>1,2,3,4，null</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line">TreeNode* createTree(char* input) &#123;</span><br><span class="line">    if (strcmp(input, &quot;null&quot;) == 0) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size = 1;</span><br><span class="line">    for (int i = 0; i &lt; strlen(input); i++) &#123;</span><br><span class="line">        if (input[i] == &#x27;,&#x27;) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode** queue = new TreeNode * [size];</span><br><span class="line">    int front = 0, rear = 0;</span><br><span class="line">    TreeNode* root = new TreeNode;</span><br><span class="line">    root-&gt;val = atoi(strtok(input, &quot;,&quot;));</span><br><span class="line">    root-&gt;left = root-&gt;right = NULL;</span><br><span class="line">    queue[rear++] = root;</span><br><span class="line"></span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; size) &#123;</span><br><span class="line">        TreeNode* node = queue[front++];</span><br><span class="line">        char* in = strtok(NULL, &quot;,&quot;);</span><br><span class="line"></span><br><span class="line">        if (strcmp(in, &quot;null&quot;) != 0) &#123;</span><br><span class="line">            node-&gt;left = new TreeNode;</span><br><span class="line">            node-&gt;left-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;left-&gt;left = node-&gt;left-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        in = strtok(NULL, &quot;,&quot;);</span><br><span class="line">        if (i &lt; size &amp;&amp; strcmp(in, &quot;null&quot;) != 0) &#123;</span><br><span class="line">            node-&gt;right = new TreeNode;</span><br><span class="line">            node-&gt;right-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;right-&gt;left = node-&gt;right-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归翻转左右子树</span><br><span class="line">    TreeNode* temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;right = invertTree(temp);</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">string levelOrderTraversal(TreeNode* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string result;</span><br><span class="line">    queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">    nodeQueue.push(root);</span><br><span class="line">    result += to_string(root-&gt;val) + &quot;,&quot;;</span><br><span class="line">    while (!nodeQueue.empty()) &#123;</span><br><span class="line">        TreeNode* node = nodeQueue.front();</span><br><span class="line">        nodeQueue.pop();</span><br><span class="line"></span><br><span class="line">        if (node-&gt;left != NULL) &#123;</span><br><span class="line">            nodeQueue.push(node-&gt;left);</span><br><span class="line">            result += to_string(node-&gt;left-&gt;val) + &quot;,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (node-&gt;right) result += &quot;null,&quot;;</span><br><span class="line">        else &#123;</span><br><span class="line">            result += &quot;null,&quot;;</span><br><span class="line">            result += &quot;null,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node-&gt;right != NULL) &#123;</span><br><span class="line">            nodeQueue.push(node-&gt;right);</span><br><span class="line">            result += to_string(node-&gt;right-&gt;val) + &quot;,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (node-&gt;left) result += &quot;null,&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!result.empty()) &#123;</span><br><span class="line">        result.pop_back();  // 去除最后一个逗号</span><br><span class="line">    &#125;</span><br><span class="line">    while (result[result.size() - 1] == &#x27;l&#x27;) &#123;</span><br><span class="line">        result.pop_back();</span><br><span class="line">        result.pop_back();</span><br><span class="line">        result.pop_back();</span><br><span class="line">        result.pop_back();</span><br><span class="line">        result.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char input[256];</span><br><span class="line">    cin.getline(input, sizeof(input));</span><br><span class="line">    int num = strlen(input);</span><br><span class="line">    TreeNode* root = createTree(input);</span><br><span class="line">    TreeNode* invertedRoot = invertTree(root);</span><br><span class="line">    string output;</span><br><span class="line">    output=  levelOrderTraversal(invertedRoot);</span><br><span class="line">    cout &lt;&lt; output;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-翻转二叉树"><a href="#3-翻转二叉树" class="headerlink" title="3.翻转二叉树"></a>3.翻转二叉树</h3><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><p><strong>输入描述：</strong><br>一个节点序列</p><p><strong>输出描述：</strong><br>返回其根节点序列</p><p><strong>样例</strong></p><p>输入<br>root &#x3D; [4,2,7,1,3,6,9]<br>输出</p><p>[4,7,2,9,6,3,1]</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归翻转左右子树</span><br><span class="line">    TreeNode* temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;right = invertTree(temp);</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-左叶子之和"><a href="#4-左叶子之和" class="headerlink" title="4.左叶子之和"></a>4.<strong>左叶子之和</strong></h3><p><strong>题目描述</strong><br>给定二叉树的根节点 root ，返回所有左叶子之和。</p><p><strong>输入描述</strong><br>一个节点序列<br><strong>输出描述</strong><br>返回其左叶子之和</p><p><strong>输入输出样例</strong></p><p>输入<br>root &#x3D; [3,9,20,null,null,15,7]<br>输出<br>24<br>输入<br>root &#x3D; [1]<br>输出<br>0</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">     </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建二叉树的函数</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">createTree</span><span class="params">(<span class="type">char</span>* input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">&quot;null&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(input); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode** queue = <span class="keyword">new</span> TreeNode * [size];</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    root-&gt;val = <span class="built_in">atoi</span>(<span class="built_in">strtok</span>(input, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    queue[rear++] = root;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; size) &#123;</span><br><span class="line">        TreeNode* node = queue[front++];</span><br><span class="line">        <span class="type">char</span>* in = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(in, <span class="string">&quot;null&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            node-&gt;left = <span class="keyword">new</span> TreeNode;</span><br><span class="line">            node-&gt;left-&gt;val = <span class="built_in">atoi</span>(in);</span><br><span class="line">            node-&gt;left-&gt;left = node-&gt;left-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">            queue[rear++] = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        in = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; size &amp;&amp; <span class="built_in">strcmp</span>(in, <span class="string">&quot;null&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            node-&gt;right = <span class="keyword">new</span> TreeNode;</span><br><span class="line">            node-&gt;right-&gt;val = <span class="built_in">atoi</span>(in);</span><br><span class="line">            node-&gt;right-&gt;left = node-&gt;right-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">            queue[rear++] = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算左叶子之和的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子树是叶子节点，累加其值</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sum += root-&gt;left-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算左右子树的左叶子之和</span></span><br><span class="line">    sum += <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);</span><br><span class="line">    sum += <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">256</span>];</span><br><span class="line">    cin.<span class="built_in">getline</span>(input, <span class="built_in">sizeof</span>(input));</span><br><span class="line">    TreeNode* root = <span class="built_in">createTree</span>(input);</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sumOfLeftLeaves</span>(root);</span><br><span class="line">    cout  &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-二叉树最近的公共祖先"><a href="#5-二叉树最近的公共祖先" class="headerlink" title="5.二叉树最近的公共祖先"></a>5.二叉树最近的公共祖先</h3><p><strong>题目描述</strong><br>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>（一个节点也可以是它自己的祖先）。</p><p><strong>输入描述</strong><br>给一个二叉树<br><strong>输出描述</strong><br>输出它的最近公共近邻</p><p><strong>输入输出样例</strong><br>输入<br>root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出<br>3</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义二叉树节点</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">   // TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//创建二叉树的函数</span><br><span class="line">TreeNode* createTree(char* input) &#123;</span><br><span class="line">    if (strcmp(input, &quot;null&quot;) == 0) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size = 1;</span><br><span class="line">    for (int i = 0; i &lt; strlen(input); i++) &#123;</span><br><span class="line">        if (input[i] == &#x27;,&#x27;) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode** queue = new TreeNode * [size];</span><br><span class="line">    int front = 0, rear = 0;</span><br><span class="line">    TreeNode* root = new TreeNode;</span><br><span class="line">    root-&gt;val = atoi(strtok(input, &quot;,&quot;));</span><br><span class="line">    root-&gt;left = root-&gt;right = NULL;</span><br><span class="line">    queue[rear++] = root;</span><br><span class="line"></span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; size) &#123;</span><br><span class="line">        TreeNode* node = queue[front++];</span><br><span class="line">        char* in = strtok(NULL, &quot;,&quot;);</span><br><span class="line"></span><br><span class="line">        if (strcmp(in, &quot;null&quot;) != 0) &#123;</span><br><span class="line">            node-&gt;left = new TreeNode;</span><br><span class="line">            node-&gt;left-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;left-&gt;left = node-&gt;left-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        in = strtok(NULL, &quot;,&quot;);</span><br><span class="line">        if (i &lt; size &amp;&amp; strcmp(in, &quot;null&quot;) != 0) &#123;</span><br><span class="line">            node-&gt;right = new TreeNode;</span><br><span class="line">            node-&gt;right-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;right-&gt;left = node-&gt;right-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">    // 如果当前节点为空，或者是 p 或 q 中的一个，直接返回当前节点</span><br><span class="line">    if (root == nullptr || root == p || root == q) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归查找左子树中是否包含 p 或 q</span><br><span class="line">    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line"></span><br><span class="line">    // 递归查找右子树中是否包含 p 或 q</span><br><span class="line">    TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">    // 如果左右子树分别包含 p 和 q，则当前节点就是最近公共祖先</span><br><span class="line">    if (left &amp;&amp; right) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 否则，返回左子树或右子树中包含 p 或 q 的节点（或者返回nullptr）</span><br><span class="line">    return left ? left : right;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* findNodeWithValue(TreeNode* root, int value) &#123;</span><br><span class="line">    // 如果当前节点为空，或者找到了节点值为目标值，直接返回当前节点</span><br><span class="line">    if (root == nullptr || root-&gt;val == value) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归查找左子树</span><br><span class="line">    TreeNode* leftResult = findNodeWithValue(root-&gt;left, value);</span><br><span class="line"></span><br><span class="line">    // 如果在左子树中找到了目标节点，直接返回结果</span><br><span class="line">    if (leftResult != nullptr) &#123;</span><br><span class="line">        return leftResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 否则，递归查找右子树</span><br><span class="line">    return findNodeWithValue(root-&gt;right, value);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    // 在这里你需要提供输入二叉树的方式，创建二叉树，然后调用 lowestCommonAncestor 函数进行测试</span><br><span class="line">    // 示例：</span><br><span class="line">    char input[256];</span><br><span class="line">        cin.getline(input, sizeof(input));</span><br><span class="line">        TreeNode* root = createTree(input);</span><br><span class="line">        int p0, p1;</span><br><span class="line">        cin &gt;&gt; p0 &gt;&gt; p1;</span><br><span class="line">    // TreeNode* root = createTree(&quot;3,5,1,6,2,0,8,null,null,7,4&quot;);</span><br><span class="line">       TreeNode* p = findNodeWithValue(root, p0);</span><br><span class="line">       TreeNode* q = findNodeWithValue(root, p1);</span><br><span class="line">       TreeNode* result = lowestCommonAncestor(root, p, q);</span><br><span class="line">       cout &lt;&lt;result-&gt;val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-恢复二叉搜索树"><a href="#6-恢复二叉搜索树" class="headerlink" title="6.恢复二叉搜索树"></a>6.恢复二叉搜索树</h3><p><strong>题目描述</strong><br>给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。</p><p><strong>输入描述</strong><br>给一个二叉树<br><strong>输出描述</strong><br>恢复这棵树</p><p><strong>输入输出样例</strong><br>输入<br>root &#x3D; [1,3,null,null,2]<br>输出<br>[3,1,null,null,2]</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">   // TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">TreeNode* createTree(char* input) &#123;</span><br><span class="line">    if (strcmp(input, &quot;null&quot;) == 0) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size = 1;</span><br><span class="line">    for (int i = 0; i &lt; strlen(input); i++) &#123;</span><br><span class="line">        if (input[i] == &#x27;,&#x27;) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode** queue = new TreeNode * [size];</span><br><span class="line">    int front = 0, rear = 0;</span><br><span class="line">    TreeNode* root = new TreeNode;</span><br><span class="line">    root-&gt;val = atoi(strtok(input, &quot;,&quot;));</span><br><span class="line">    root-&gt;left = root-&gt;right = NULL;</span><br><span class="line">    queue[rear++] = root;</span><br><span class="line"></span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; size) &#123;</span><br><span class="line">        TreeNode* node = queue[front++];</span><br><span class="line">        char* in = strtok(NULL, &quot;,&quot;);</span><br><span class="line"></span><br><span class="line">        if (strcmp(in, &quot;null&quot;) != 0) &#123;</span><br><span class="line">            node-&gt;left = new TreeNode;</span><br><span class="line">            node-&gt;left-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;left-&gt;left = node-&gt;left-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        in = strtok(NULL, &quot;,&quot;);</span><br><span class="line">        if (i &lt; size &amp;&amp; strcmp(in, &quot;null&quot;) != 0) &#123;</span><br><span class="line">            node-&gt;right = new TreeNode;</span><br><span class="line">            node-&gt;right-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;right-&gt;left = node-&gt;right-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">void inorder(TreeNode* root, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if (root == nullptr) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root-&gt;left, nums);</span><br><span class="line">    nums.push_back(root-&gt;val);</span><br><span class="line">    inorder(root-&gt;right, nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;int, int&gt; findTwoSwapped(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    int index1 = -1, index2 = -1;</span><br><span class="line">    for (int i = 0; i &lt; n - 1; ++i) &#123;</span><br><span class="line">        if (nums[i + 1] &lt; nums[i]) &#123;</span><br><span class="line">            index2 = i + 1;</span><br><span class="line">            if (index1 == -1) &#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int x = nums[index1], y = nums[index2];</span><br><span class="line">    return &#123; x, y &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void recover(TreeNode* r, int count, int x, int y) &#123;</span><br><span class="line">    if (r != nullptr) &#123;</span><br><span class="line">        if (r-&gt;val == x || r-&gt;val == y) &#123;</span><br><span class="line">            r-&gt;val = r-&gt;val == x ? y : x;</span><br><span class="line">            if (--count == 0) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        recover(r-&gt;left, count, x, y);</span><br><span class="line">        recover(r-&gt;right, count, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void recoverTree(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    inorder(root, nums);</span><br><span class="line">    pair&lt;int, int&gt; swapped = findTwoSwapped(nums);</span><br><span class="line">    recover(root, 2, swapped.first, swapped.second);</span><br><span class="line">&#125;</span><br><span class="line">string levelOrderTraversal(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        string result;</span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        result += to_string(root-&gt;val) + &quot;,&quot;;</span><br><span class="line">        while (!nodeQueue.empty()) &#123;</span><br><span class="line">            TreeNode* node = nodeQueue.front();</span><br><span class="line">            nodeQueue.pop();</span><br><span class="line">    </span><br><span class="line">            if (node-&gt;left != NULL) &#123;</span><br><span class="line">                nodeQueue.push(node-&gt;left);</span><br><span class="line">                result += to_string(node-&gt;left-&gt;val) + &quot;,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (node-&gt;right) result += &quot;null,&quot;;</span><br><span class="line">            else &#123;</span><br><span class="line">                result += &quot;null,&quot;;</span><br><span class="line">                result += &quot;null,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;right != NULL) &#123;</span><br><span class="line">                nodeQueue.push(node-&gt;right);</span><br><span class="line">                result += to_string(node-&gt;right-&gt;val) + &quot;,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (node-&gt;left) result += &quot;null,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        if (!result.empty()) &#123;</span><br><span class="line">            result.pop_back();  // 去除最后一个逗号</span><br><span class="line">        &#125;</span><br><span class="line">        while (result[result.size() - 1] == &#x27;l&#x27;) &#123;</span><br><span class="line">            result.pop_back();</span><br><span class="line">            result.pop_back();</span><br><span class="line">            result.pop_back();</span><br><span class="line">            result.pop_back();</span><br><span class="line">            result.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">char input[256];</span><br><span class="line">cin.getline(input, sizeof(input));</span><br><span class="line">TreeNode* root = createTree(input);</span><br><span class="line">    recoverTree(root);</span><br><span class="line">    string output = levelOrderTraversal(root);</span><br><span class="line">    cout &lt;&lt; output;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-奇偶树"><a href="#7-奇偶树" class="headerlink" title="7.奇偶树"></a>7.奇偶树</h3><p>如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：<br>二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。<br>偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增<br>奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减<br>给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。</p><p><strong>输入描述</strong><br>给一个二叉树<br><strong>输出描述</strong><br>判断是否是奇偶树</p><p><strong>输入输出样例</strong><br>输入<br>root &#x3D; [1,10,4,3,null,7,9,12,8,6,null,null,2]<br>输出<br>true</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isEvenOddTree(TreeNode* root) &#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; qu;</span><br><span class="line">    qu.push(root);</span><br><span class="line">    int level = 0;</span><br><span class="line">    while (!qu.empty()) &#123;</span><br><span class="line">        int size = qu.size();</span><br><span class="line">        int prev = level % 2 == 0 ? INT_MIN : INT_MAX;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode* node = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            int value = node-&gt;val;</span><br><span class="line">            if (level % 2 == value % 2) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((level % 2 == 0 &amp;&amp; value &lt;= prev) || (level % 2 == 1 &amp;&amp; value &gt;= prev)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = value;</span><br><span class="line">            if (node-&gt;left != nullptr) &#123;</span><br><span class="line">                qu.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;right != nullptr) &#123;</span><br><span class="line">                qu.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-二叉树的子树大小"><a href="#8-二叉树的子树大小" class="headerlink" title="8.二叉树的子树大小"></a>8.二叉树的子树大小</h3><p>描述</p><p>现在给出一棵二叉树，希望你输出它的每一个结点为根的子树大小</p><p>输入</p><p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。<br>接下来 n 行，每行两个正整数 li, ri ​ ，分别表示节点 i 的左右孩子的编号。如果不存在左 &#x2F; 右孩子，则以 −1 表示。两个数之间用一个空格隔开。</p><p>输出</p><p>一行，n个数，分别表示i号结点为根的子树的子树大小</p><p>样例</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">-1 -1</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> leftChild;</span><br><span class="line">    <span class="type">int</span> rightChild;</span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归计算以指定节点为根的子树大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">calculateSubtreeSize</span><span class="params">(TreeNode tree[], <span class="type">int</span> node)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果节点为空，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算左右子树大小</span></span><br><span class="line">    <span class="type">int</span> leftSize = calculateSubtreeSize(tree, tree[node].leftChild);</span><br><span class="line">    <span class="type">int</span> rightSize = calculateSubtreeSize(tree, tree[node].rightChild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以当前节点为根的子树大小（包括当前节点）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + leftSize + rightSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建二叉树节点数组</span></span><br><span class="line">    TreeNode* tree = (TreeNode*)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取每个节点的左右孩子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;tree[i].leftChild, &amp;tree[i].rightChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并输出每个节点为根的子树大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> subtreeSize = calculateSubtreeSize(tree, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, subtreeSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-二叉树的子树和"><a href="#9-二叉树的子树和" class="headerlink" title="9.二叉树的子树和"></a>9.二叉树的子树和</h3><p>现在给出一棵二叉树，每个结点有一个权值，希望你依次输出每一个节点为根的子树的子树权值和</p><p>输入</p><p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。<br>第二行 n 个正整数，用一个空格分隔，第 i 个正整数vi，代表节点 i 的权值。<br>接下来 n 行，每行两个正整数 li, ri ​ ，分别表示节点 i 的左右孩子的编号。如果不存在左 &#x2F; 右孩子，则以 −1 表示。两个数之间用一个空格隔开。</p><p>输出</p><p>一行，n个数，分别表示i号结点为根的子树的子树权值和</p><p>样例</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1000 1000</span><br><span class="line">2 3</span><br><span class="line">-1 -1</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2001 1000 1000</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> leftChild;</span><br><span class="line">    <span class="type">int</span> rightChild;</span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归计算以指定节点为根的子树权值和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">calculateSubtreeSum</span><span class="params">(TreeNode tree[], <span class="type">int</span> node, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果节点为空，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="number">-1</span> || node &gt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算左右子树权值和</span></span><br><span class="line">    <span class="type">int</span> leftSum = calculateSubtreeSum(tree, tree[node].leftChild, n);</span><br><span class="line">    <span class="type">int</span> rightSum = calculateSubtreeSum(tree, tree[node].rightChild, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以当前节点为根的子树权值和（包括当前节点）</span></span><br><span class="line">    <span class="keyword">return</span> tree[node].value + leftSum + rightSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建二叉树节点数组</span></span><br><span class="line">    TreeNode* tree = (TreeNode*)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取每个节点的权值和左右孩子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tree[i].value);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;tree[i].leftChild, &amp;tree[i].rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算并输出每个节点为根的子树权值和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> subtreeSum = calculateSubtreeSum(tree, i, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, subtreeSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-确定树的形态"><a href="#10-确定树的形态" class="headerlink" title="10.确定树的形态"></a>10.确定树的形态</h3><p>现在给出一棵二叉树的前序遍历和后序遍历，输出树的后序遍历</p><p>输入</p><p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。<br>第二行 n 个正整数，用一个空格分隔，代表二叉树的前序遍历<br>第三行 n 个正整数，用一个空格分隔，代表二叉树的中序遍历</p><p>输出</p><p>一行，n个数，用一个空格分隔，表示二叉树的后序遍历</p><p>样例</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3 </span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 1</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据前序遍历和中序遍历构建二叉树</span></span><br><span class="line">TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span> pre[], <span class="type">int</span> in[], <span class="type">int</span> startPre, <span class="type">int</span> endPre, <span class="type">int</span> startIn, <span class="type">int</span> endIn)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (startPre &gt; endPre || startIn &gt; endIn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建根节点</span></span><br><span class="line">    TreeNode* root = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    root-&gt;data = pre[startPre];</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在中序遍历中找到根节点的位置</span></span><br><span class="line">    <span class="type">int</span> rootIndex;</span><br><span class="line">    <span class="keyword">for</span> (rootIndex = startIn; rootIndex &lt;= endIn; rootIndex++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[rootIndex] == pre[startPre]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> leftSize = rootIndex - startIn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归构建左子树和右子树</span></span><br><span class="line">    root-&gt;left = buildTree(pre, in, startPre + <span class="number">1</span>, startPre + leftSize, startIn, rootIndex - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = buildTree(pre, in, startPre + leftSize + <span class="number">1</span>, endPre, rootIndex + <span class="number">1</span>, endIn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历输出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历左子树</span></span><br><span class="line">    postOrder(root-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历右子树</span></span><br><span class="line">    postOrder(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出根节点的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取前序遍历和中序遍历</span></span><br><span class="line">    <span class="type">int</span>* pre = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span>* in = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;in[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建二叉树</span></span><br><span class="line">    TreeNode* root = buildTree(pre, in, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出后序遍历</span></span><br><span class="line">    postOrder(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(pre);</span><br><span class="line">    <span class="built_in">free</span>(in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-哈夫曼树的带权路径长"><a href="#11-哈夫曼树的带权路径长" class="headerlink" title="11.哈夫曼树的带权路径长"></a>11.哈夫曼树的带权路径长</h3><p>现在给出一棵二叉树，每个结点有一个权值，希望你构造赫夫曼树，并输出其对应的带权路径长度</p><p>输入</p><p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n。<br>第二行 n 个正整数，用一个空格分隔，第 i 个正整数vi，代表节点 i 的权值。</p><p>输出</p><p>一个数，表示对应赫夫曼树的带权路径长度</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义二叉树节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* left;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新的节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> weight)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* node = (<span class="keyword">struct</span> TreeNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">node-&gt;weight = weight;</span><br><span class="line">node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小堆的数据结构的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> capacity;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>** array;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建一个新的最小堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeap</span>* <span class="built_in">createMinHeap</span>(<span class="type">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeap</span>* minHeap = (<span class="keyword">struct</span> MinHeap*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> MinHeap));</span><br><span class="line">minHeap-&gt;size = <span class="number">0</span>;</span><br><span class="line">minHeap-&gt;capacity = capacity;</span><br><span class="line">minHeap-&gt;array = (<span class="keyword">struct</span> TreeNode**)<span class="built_in">malloc</span>(capacity * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode*));</span><br><span class="line"><span class="keyword">return</span> minHeap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换两个节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapNodes</span><span class="params">(<span class="keyword">struct</span> TreeNode** a, <span class="keyword">struct</span> TreeNode** b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* t = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最小堆的下沉操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">minHeapify</span><span class="params">(<span class="keyword">struct</span> MinHeap* minHeap, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> smallest = index;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; minHeap-&gt;size &amp;&amp; minHeap-&gt;array[left]-&gt;weight &lt; minHeap-&gt;array[smallest]-&gt;weight)</span><br><span class="line">        smallest = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &lt; minHeap-&gt;size &amp;&amp; minHeap-&gt;array[right]-&gt;weight &lt; minHeap-&gt;array[smallest]-&gt;weight)</span><br><span class="line">        smallest = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (smallest != index) &#123;</span><br><span class="line">        <span class="built_in">swapNodes</span>(&amp;minHeap-&gt;array[smallest], &amp;minHeap-&gt;array[index]);</span><br><span class="line">        <span class="built_in">minHeapify</span>(minHeap, smallest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为叶子节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLeaf</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(root-&gt;left) &amp;&amp; !(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建最小堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeap</span>* <span class="built_in">buildMinHeap</span>(<span class="type">int</span> weights[], <span class="type">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MinHeap</span>* minHeap = <span class="built_in">createMinHeap</span>(size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        minHeap-&gt;array[i] = <span class="built_in">createNode</span>(weights[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    minHeap-&gt;size = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">minHeapify</span>(minHeap, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minHeap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最小堆中提取最小值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">extractMin</span>(<span class="keyword">struct</span> MinHeap* minHeap) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* temp = minHeap-&gt;array[<span class="number">0</span>];</span><br><span class="line">    minHeap-&gt;array[<span class="number">0</span>] = minHeap-&gt;array[minHeap-&gt;size - <span class="number">1</span>];</span><br><span class="line">    --minHeap-&gt;size;</span><br><span class="line">    <span class="built_in">minHeapify</span>(minHeap, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新节点到最小堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertMinHeap</span><span class="params">(<span class="keyword">struct</span> MinHeap* minHeap, <span class="keyword">struct</span> TreeNode* node)</span> </span>&#123;</span><br><span class="line">    ++minHeap-&gt;size;</span><br><span class="line">    <span class="type">int</span> i = minHeap-&gt;size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; node-&gt;weight &lt; minHeap-&gt;array[(i - <span class="number">1</span>) / <span class="number">2</span>]-&gt;weight) &#123;</span><br><span class="line">        minHeap-&gt;array[i] = minHeap-&gt;array[(i - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minHeap-&gt;array[i] = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建赫夫曼树</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">buildHuffmanTree</span>(<span class="type">int</span> weights[], <span class="type">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* left, * right, * top;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MinHeap</span>* minHeap = <span class="built_in">buildMinHeap</span>(weights, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (minHeap-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        left = <span class="built_in">extractMin</span>(minHeap);</span><br><span class="line">        right = <span class="built_in">extractMin</span>(minHeap);</span><br><span class="line"></span><br><span class="line">        top = <span class="built_in">createNode</span>(left-&gt;weight + right-&gt;weight);</span><br><span class="line">        top-&gt;left = left;</span><br><span class="line">        top-&gt;right = right;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">insertMinHeap</span>(minHeap, top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">extractMin</span>(minHeap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算带权路径长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculateWPL</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isLeaf</span>(root))</span><br><span class="line">        <span class="keyword">return</span> root-&gt;weight * depth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">calculateWPL</span>(root-&gt;left, depth + <span class="number">1</span>) + <span class="built_in">calculateWPL</span>(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> weights[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; weights[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* root = <span class="built_in">buildHuffmanTree</span>(weights, n);</span><br><span class="line"><span class="type">int</span> wpl = <span class="built_in">calculateWPL</span>(root, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; wpl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实验 </span><br><span class="line">实验题目：排序</span><br><span class="line"></span><br><span class="line">实验目的：</span><br><span class="line">掌握各种排序方法的基本思想、排序过程、算法实现，能进行时间和空间性能的分析，根据实际问题的特点和要求选择合适的排序方法。</span><br><span class="line"></span><br><span class="line">实验要求：</span><br><span class="line">实现直接排序、冒泡、直接选择、快速、堆、归并排序算法。比较各种算法的运行速度。</span><br><span class="line"></span><br><span class="line">实验主要步骤：</span><br><span class="line"></span><br><span class="line">实验代码</span><br><span class="line"></span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define Max 100         //假设文件长度</span><br><span class="line">typedef struct &#123;         //定义记录类型</span><br><span class="line">    int key;            //关键字项</span><br><span class="line">&#125;RecType;</span><br><span class="line">typedef RecType SeqList[Max + 1]; //SeqList为顺序表，表中第0个元素作为哨兵</span><br><span class="line">int n;                 //顺序表实际的长度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//==========直接插入排序法======</span><br><span class="line">void InsertSort(SeqList R)</span><br><span class="line">&#123;       //对顺序表R中的记录R[1‥n]按递增序进行插入排序</span><br><span class="line">    int i, j;</span><br><span class="line">    for (i = 2; i &lt;= n; ++i)</span><br><span class="line">        if (R[i].key &lt; R[i - 1].key)//将L.r[i]插入有序子表</span><br><span class="line">        &#123;</span><br><span class="line">            R[0] = R[i]; // 复制为哨兵</span><br><span class="line">            R[i] = R[i - 1];</span><br><span class="line">            for (j = i - 2; R[0].key &lt; R[j].key; --j)</span><br><span class="line">                R[j + 1] = R[j]; // 记录后移 </span><br><span class="line">            R[j + 1] = R[0]; //插入到正确位置</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//==========冒泡排序======= </span><br><span class="line">typedef enum &#123; FALSE, TRUE &#125; Boolean;  //FALSE为0，TRUE为1</span><br><span class="line">void BubbleSort(SeqList R) &#123;             //自下向上扫描对R做冒泡排序</span><br><span class="line">    int i, j,num;     Boolean exchange;     //交换标志</span><br><span class="line">    for (i = 1; i &lt; n; i++) &#123;    //最多做n-1趟排序</span><br><span class="line">        exchange = FALSE;       //本趟排序开始前，交换标志应为假</span><br><span class="line">        for (j = n - 1; j &gt;= i; j--)       //对当前无序区R[i‥n] 自下向上扫描</span><br><span class="line">            if (R[j + 1].key &lt; R[j].key) &#123;    //两两比较，满足条件交换记录</span><br><span class="line">                num = R[j].key;</span><br><span class="line">                R[j].key = R[j + 1].key;</span><br><span class="line">                R[j + 1].key = num;</span><br><span class="line">                    exchange = TRUE;         //发生了交换，故将交换标志置为真</span><br><span class="line">            &#125;</span><br><span class="line">        if (!exchange)           //本趟排序未发生交换，提前终止算法</span><br><span class="line">            return;</span><br><span class="line">    &#125;//endfor（为循环）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//1.========一次划分函数=====</span><br><span class="line">int Partition(SeqList R, int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    int pivotkey = R[i].key;//   对R[i‥j]做一次划分，并返回基准记录的位置</span><br><span class="line">    RecType pivot = R[i];    //用第一个记录作为基准</span><br><span class="line">    while (i &lt; j) &#123;  </span><br><span class="line">        while (i &lt; j &amp;&amp; R[j].key &gt;= pivotkey)  --j;</span><br><span class="line">       R[i] =R[j];</span><br><span class="line">        while (i &lt; j &amp;&amp; R[i].key &lt;= pivotkey)  ++i;</span><br><span class="line">        R[j] =R[i];</span><br><span class="line">        //从区间两端交替向中间扫描，直到i=j</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    R[i] = pivot;    //此时，i=j，基准记录已被最后定位</span><br><span class="line">    return i;      //返回基准记录的位置</span><br><span class="line">&#125;</span><br><span class="line">//2.=====快速排序===========</span><br><span class="line">void QuickSort(SeqList R, int low, int high)</span><br><span class="line">&#123;                 //R[low..high]快速排序</span><br><span class="line">    int pivotpos;            //划分后基准记录的位置</span><br><span class="line">    if (low &lt; high) &#123;           //仅当区间长度大于1时才排序</span><br><span class="line">        pivotpos = Partition(R, low, high);  //对R[low..high]做一次划分，得到基准记录的位置</span><br><span class="line">        QuickSort(R, low, pivotpos - 1);       //对左区间递归排序</span><br><span class="line">        QuickSort(R, pivotpos + 1, high);      //对右区间递归排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//======直接选择排序========</span><br><span class="line">void SelectSort(SeqList R)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    for (i = 1; i &lt; n; i++) &#123;         //做第i趟排序（1≤i≤n-1）</span><br><span class="line">        k = i;</span><br><span class="line">        for (j = i + 1; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (R[j].key &lt; R[k].key)</span><br><span class="line">            &#123;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        if (k != i)</span><br><span class="line">        &#123;</span><br><span class="line">            int temp = R[i].key;</span><br><span class="line">            R[i].key = R[k].key;</span><br><span class="line">            R[k].key = temp;</span><br><span class="line"></span><br><span class="line">        &#125;//endif</span><br><span class="line">    &#125; //endfor</span><br><span class="line">&#125;</span><br><span class="line">//==========大根堆调整函数=======</span><br><span class="line">void Heapify(SeqList R, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    int i = low;</span><br><span class="line">    int j = 2 * i;</span><br><span class="line">    RecType temp = R[i];</span><br><span class="line">    while (j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        if (j &lt; high &amp;&amp; R[j].key &lt; R[j + 1].key)</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp.key &gt;= R[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        R[i] = R[j];</span><br><span class="line">        i = j;</span><br><span class="line">        j = 2 * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    R[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">//==========构造大根堆==========</span><br><span class="line">void BuildHeap(SeqList R,int n)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = n / 2; i &gt;= 1; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Heapify(R, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//==========堆排序===========</span><br><span class="line">void HeapSort(SeqList R)</span><br><span class="line">&#123;</span><br><span class="line">    BuildHeap(R,n);</span><br><span class="line">    // 依次将堆顶元素与末尾元素交换并重新调整堆</span><br><span class="line">    for (int i = n; i &gt; 1; i--) &#123;</span><br><span class="line">        swap(R[1], R[i]); // 将堆顶元素（最大值）与末尾元素交换</span><br><span class="line">        Heapify(R, 1, i - 1); // 调整堆</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//=====将两个有序的子序列R[low..m]和R[m+1..high]归并成有序的序列R[low..high]==</span><br><span class="line">void Merge(SeqList R, int low, int m, int high)</span><br><span class="line">&#123;</span><br><span class="line">    int i = low, j = m + 1, k = 0;</span><br><span class="line">    SeqList temp;</span><br><span class="line">    while (i &lt;= m &amp;&amp; j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        if (R[i].key &lt;= R[j].key) &#123;</span><br><span class="line">            temp[++k] = R[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            temp[++k] = R[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (i &lt;= m) &#123;</span><br><span class="line">        temp[++k] = R[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (j &lt;= high) &#123;</span><br><span class="line">        temp[++k] = R[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 1, j = low; i &lt;= k; ++i, ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        R[j] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//=========对R[1..n]做一趟归并排序========</span><br><span class="line">void MergePass(SeqList R, int length)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 1; i + 2 * length - 1 &lt;= n; i += 2 * length)</span><br><span class="line">    &#123;</span><br><span class="line">        Merge(R, i, i + length - 1, i + 2 * length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (i + length - 1 &lt; n) &#123;</span><br><span class="line">        Merge(R, i, i + length - 1, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//========== 自底向上对R[1..n]做二路归并排序===============</span><br><span class="line">void MergeSort(SeqList R)</span><br><span class="line">&#123;</span><br><span class="line">    int length;</span><br><span class="line">    for (length = 1; length &lt; n; length *= 2)     //做[lgn]趟排序</span><br><span class="line">        MergePass(R, length);     //有序长度≥n时终止</span><br><span class="line">&#125;</span><br><span class="line">//==========输入顺序表========</span><br><span class="line">void input_int(SeqList R)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    printf(&quot;Please input num(int):&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    printf(&quot;Plase input %d integer:&quot;, n);</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;R[i].key);</span><br><span class="line">&#125;</span><br><span class="line">//==========输出顺序表========</span><br><span class="line">void output_int(SeqList R)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">        printf(&quot;%4d&quot;, R[i].key);</span><br><span class="line">&#125;</span><br><span class="line">//==========主函数======</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    SeqList R;</span><br><span class="line">    input_int(R);</span><br><span class="line">    printf(&quot;\t******** Select **********\n&quot;);</span><br><span class="line">    printf(&quot;\t1: Insert Sort\n&quot;);</span><br><span class="line">    printf(&quot;\t2: Bubble Sort\n&quot;);</span><br><span class="line">    printf(&quot;\t3: Quick Sort\n&quot;);</span><br><span class="line">    printf(&quot;\t4: Straight Selection Sort\n&quot;);</span><br><span class="line">    printf(&quot;\t5: Heap Sort\n&quot;);</span><br><span class="line">    printf(&quot;\t6: Merge Sort\n&quot;);</span><br><span class="line">    printf(&quot;\t7: Exit\n&quot;);</span><br><span class="line">    printf(&quot;\t***************************\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;i);   //输入整数1-7，选择排序方式</span><br><span class="line">    switch (i) &#123;</span><br><span class="line">    case 1: InsertSort(R); break;       //值为1，直接插入排序</span><br><span class="line">    case 2: BubbleSort(R); break;       //值为2，冒泡法排序</span><br><span class="line">    case 3: QuickSort(R, 1, n); break;    //值为3，快速排序</span><br><span class="line">    case 4: SelectSort(R); break;       //值为4，直接选择排序</span><br><span class="line">    case 5: HeapSort(R); break;         //值为5，堆排序</span><br><span class="line">    case 6: MergeSort(R); break;        //值为6，归并排序</span><br><span class="line">    case 7: exit(0);                    //值为7，结束程序</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Sort reult:&quot;);</span><br><span class="line">    output_int(R);</span><br><span class="line">&#125;</span><br><span class="line">实验结果：</span><br><span class="line">1.直接插入排序  输入 15 2 13 33 3 5 9 14 11 22</span><br><span class="line"></span><br><span class="line">2.冒泡排序</span><br><span class="line"></span><br><span class="line">3.快速排序</span><br><span class="line"></span><br><span class="line">4.直接选择排序</span><br><span class="line"></span><br><span class="line">5.堆排序</span><br><span class="line"></span><br><span class="line">6.归并排序</span><br><span class="line"></span><br><span class="line">运行速度比较：</span><br><span class="line"></span><br><span class="line">1.直接插入排序</span><br><span class="line">时间复杂度为 o(n2)</span><br><span class="line">空间复杂度为 o(1)</span><br><span class="line"></span><br><span class="line">2.冒泡排序</span><br><span class="line">时间复杂度为 o(n2)</span><br><span class="line">空间复杂度为 o(1)</span><br><span class="line"></span><br><span class="line">3.快速排序</span><br><span class="line">时间效率：O(nlog2n) —每趟确定的元素呈指数增加</span><br><span class="line">空间效率：</span><br><span class="line">O（log2n）—递归要用到栈空间</span><br><span class="line"></span><br><span class="line">4.直接选择排序</span><br><span class="line">直接插入排序的平均时间复杂度为O(n2）</span><br><span class="line">因此空间复杂度为：O(1) </span><br><span class="line">5.堆排序</span><br><span class="line">时间效率：O(nlog2n) </span><br><span class="line">空间效率：O（1）</span><br><span class="line">6.归并排序</span><br><span class="line">时间复杂度O(nlog2n)</span><br><span class="line">空间复杂度O（n）</span><br></pre></td></tr></table></figure><h3 id="1-直接插入排序"><a href="#1-直接插入排序" class="headerlink" title="1.直接插入排序"></a>1.直接插入排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void insertionSort(int arr[], int n) &#123;</span><br><span class="line">    int i, key, j;</span><br><span class="line">    for (i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        key = arr[i];</span><br><span class="line">        j = i - 1;</span><br><span class="line"></span><br><span class="line">        // 将 arr[0...i-1] 中大于 key 的元素都向右移动一个位置</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + 1] = arr[j];</span><br><span class="line">            j = j - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 插入 key 到正确的位置</span><br><span class="line">        arr[j + 1] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-折半排序"><a href="#2-折半排序" class="headerlink" title="2.折半排序"></a>2.折半排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void binaryInsertionSort(int arr[], int n) &#123;</span><br><span class="line">    int i, key, j, low, high, mid;</span><br><span class="line"></span><br><span class="line">    for (i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        key = arr[i];</span><br><span class="line">        low = 0;</span><br><span class="line">        high = i - 1;</span><br><span class="line"></span><br><span class="line">        // 使用二分查找找到插入位置</span><br><span class="line">        while (low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / 2;</span><br><span class="line">            if (arr[mid] &gt; key)</span><br><span class="line">                high = mid - 1;</span><br><span class="line">            else</span><br><span class="line">                low = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 移动元素，插入到正确位置</span><br><span class="line">        for (j = i - 1; j &gt;= low; j--)</span><br><span class="line">            arr[j + 1] = arr[j];</span><br><span class="line"></span><br><span class="line">        arr[low] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3.希尔排序"></a>3.希尔排序</h3><p>1.分步骤，直接排</p><p>2.有间隔，用dk表示跳跃的间隔，最后dk一定为1</p><p>3.不稳定</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void shellSort(int arr[], int n) &#123;</span><br><span class="line">    for (int gap = n / 2; gap &gt; 0; gap /= 2) &#123;</span><br><span class="line">        for (int i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            int j;</span><br><span class="line">            for (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap)</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-交换排序"><a href="#4-交换排序" class="headerlink" title="4.交换排序"></a>4.交换排序</h3><h4 id="4-1冒泡排序（起泡排序）"><a href="#4-1冒泡排序（起泡排序）" class="headerlink" title="4.1冒泡排序（起泡排序）"></a>4.1冒泡排序（起泡排序）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void bubbleSort(int arr[], int n) &#123;</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n - i - 1; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                // 交换 arr[j] 和 arr[j+1]</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.快速排序"></a>5.快速排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int partition(int arr[], int low, int high) &#123;</span><br><span class="line">    int pivot = arr[high];</span><br><span class="line">    int i = (low - 1);</span><br><span class="line"></span><br><span class="line">    for (int j = low; j &lt;= high - 1; j++) &#123;</span><br><span class="line">        if (arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            // 交换 arr[i] 和 arr[j]</span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 交换 arr[i + 1] 和 arr[high]</span><br><span class="line">    int temp = arr[i + 1];</span><br><span class="line">    arr[i + 1] = arr[high];</span><br><span class="line">    arr[high] = temp;</span><br><span class="line">    return (i + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quickSort(int arr[], int low, int high) &#123;</span><br><span class="line">    if (low &lt; high) &#123;</span><br><span class="line">        int pi = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">        quickSort(arr, low, pi - 1);</span><br><span class="line">        quickSort(arr, pi + 1, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-简单选择排序"><a href="#6-简单选择排序" class="headerlink" title="6.简单选择排序"></a>6.简单选择排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void selectionSort(int arr[], int n) &#123;</span><br><span class="line">    int i, j, minIndex;</span><br><span class="line">    for (i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        for (j = i + 1; j &lt; n; j++)</span><br><span class="line">            if (arr[j] &lt; arr[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line"></span><br><span class="line">        // 交换 arr[i] 和 arr[minIndex]</span><br><span class="line">        int temp = arr[minIndex];</span><br><span class="line">        arr[minIndex] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-树形选择排序（锦标赛ghp-9yymKPfuZyP90Ic46ZIGEhZpjOTDP54cat4B"><a href="#7-树形选择排序（锦标赛ghp-9yymKPfuZyP90Ic46ZIGEhZpjOTDP54cat4B" class="headerlink" title="7.树形选择排序（锦标赛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"></a>7.树形选择排序（锦标赛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</h3><h3 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="8.堆排序"></a>8.堆排序</h3><p><strong>堆排序</strong>是一种树形选择排序，在排序过程中，将待排序的记录r[1..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序序列中选择关键字最大（或最小）的记录。</p><p>如果将序列看成一个完全二叉树，非叶子结点的值均小于（上面左边不等式）或大于（上面右边不等式）左右孩子结点的值</p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312071626515.png" alt="image-20231207162654394"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void heapify(int arr[], int n, int i) &#123;</span><br><span class="line">    int largest = i;</span><br><span class="line">    int left = 2 * i + 1;</span><br><span class="line">    int right = 2 * i + 2;</span><br><span class="line"></span><br><span class="line">    if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line"></span><br><span class="line">    if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line"></span><br><span class="line">    if (largest != i) &#123;</span><br><span class="line">        // 交换 arr[i] 和 arr[largest]</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line"></span><br><span class="line">        heapify(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heapSort(int arr[], int n) &#123;</span><br><span class="line">    for (int i = n / 2 - 1; i &gt;= 0; i--)</span><br><span class="line">        heapify(arr, n, i);</span><br><span class="line"></span><br><span class="line">    for (int i = n - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        // 交换 arr[0] 和 arr[i]</span><br><span class="line">        int temp = arr[0];</span><br><span class="line">        arr[0] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line"></span><br><span class="line">        heapify(arr, i, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-外部排序"><a href="#9-外部排序" class="headerlink" title="9.外部排序"></a>9.外部排序</h3><h4 id="外排的基本方法"><a href="#外排的基本方法" class="headerlink" title="外排的基本方法"></a>外排的基本方法</h4><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\image-20231214082134736.png" alt="image-20231214082134736"></p><h4 id="胜者树ghp-Te68DICI21MITinvYONIbo4DB2ImNo3yPNHW"><a href="#胜者树ghp-Te68DICI21MITinvYONIbo4DB2ImNo3yPNHW" class="headerlink" title="胜者树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"></a>胜者树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</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140827871.png" alt="image-20231214082755792"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140828711.png" alt="image-20231214082841635"></p><h4 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140828894.png" alt="image-20231214082857798"></p><h3 id="置换选择排序"><a href="#置换选择排序" class="headerlink" title="置换选择排序"></a>置换选择排序</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140829406.png" alt="image-20231214082947332"></p><h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140830118.png" alt="image-20231214083002042"></p><h4 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140832733.png" alt="image-20231214083216645"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140835160.png" alt="image-20231214083515080"></p><h3 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140841982.png" alt="image-20231214084145898"></p><p>不稳定：希尔排序，快速排序，堆排序</p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140849845.png" alt="image-20231214084947762"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140850880.png" alt="image-20231214085000801"></p><h2 id="查找题库"><a href="#查找题库" class="headerlink" title="查找题库"></a>查找题库</h2><h3 id="1-找最小值"><a href="#1-找最小值" class="headerlink" title="1.找最小值"></a>1.找最小值</h3><p>用的直接比较</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int min = 1e5;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">int arr[10000];</span><br><span class="line">int number;</span><br><span class="line">int m = 0;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (min &gt; arr[i])</span><br><span class="line">&#123;</span><br><span class="line">min = arr[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; min;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m;</span><br><span class="line">cin &gt;&gt; n&gt;&gt;m;</span><br><span class="line">int arr[120];</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">&#125;</span><br><span class="line">int inquire[120];</span><br><span class="line">int len = 0;</span><br><span class="line">for (int i = 0; i&lt;m; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; inquire[i];</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">int flag = -1;</span><br><span class="line">for (int j = 0; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (inquire[i] == arr[j])</span><br><span class="line">&#123;</span><br><span class="line">flag = j+1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; flag&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-A-B数对"><a href="#3-A-B数对" class="headerlink" title="3.A-B数对"></a>3.A-B数对</h3><p>描述<a href="https://www.luogu.com.cn/problem/solution/P1102">P1102 A-B 数对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>给出一串单调不下降的数以及一个数字 C，要求计算出所有A−B&#x3D;C 的数对的个数（不同位置的数字一样的数对算不同的数对）。</p><p>输入</p><p>输入共两行。</p><p>第一行，两个整数 N,C。</p><p>第二行，N个整数，作为要求处理的那串数。</p><p>输出</p><p>一行，表示该串数中包含的满足A−B&#x3D;C 的数对的个数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">    #include &lt;map&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">    typedef long long LL;</span><br><span class="line">    LL a[200001];</span><br><span class="line">    map&lt;LL,LL&gt; m;//建立一个数字到出现次数的映射 map&lt;num,times&gt;</span><br><span class="line">    //A-B=C --&gt; A-C=B</span><br><span class="line">    int main() &#123;</span><br><span class="line">        int n;</span><br><span class="line">        LL c;</span><br><span class="line">        LL ans=0;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">        for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            m[a[i]]++;</span><br><span class="line">            a[i]-=c;    </span><br><span class="line">        &#125; </span><br><span class="line">        for(int i=1;i&lt;=n;i++) ans+=m[a[i]];</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-普通二叉树"><a href="#4-普通二叉树" class="headerlink" title="4.普通二叉树"></a>4.普通二叉树</h3><p>您需要写一种数据结构，来维护一些数（都是 1e9 以内的数字）的集合，最开始时集合是空的。其中需要提供以下操作，操作次数 q 不超过 104：</p><ol><li>查询值为x的数的排名（排名定义为比当前数小的数的个数 +1。若有多个相同的数，应输出最小的排名）。</li><li>查询排名为 x 的数。</li><li>求 x 的前驱（前驱定义为小于 x，且最大的数）。若未找到则输出−2147483647。</li><li>求 x 的后继（后继定义为大于 x，且最小的数）。若未找到则输出 2147483647。</li><li>插入一个数 x。</li></ol><p>输入</p><p>第一行是一个整数 q，表示操作次数。</p><p>接下来 q 行，每行两个整数 op,x，分别表示操作序号以及操作的参数 x。</p><p>输出</p><p>输出有若干行。对于操作 1,2,3,4输出一个整数，表示该操作的结果。</p><p>样例</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">5 1</span><br><span class="line">5 3</span><br><span class="line">5 5</span><br><span class="line">1 3</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n = 2147483647;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    int count; // 记录当前节点的重复次数</span><br><span class="line">    int leftCount; // 记录左子树节点数量</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(int x) : val(x), count(1), leftCount(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 向二叉搜索树中插入节点</span><br><span class="line">TreeNode* insert(TreeNode* root, int x) &#123;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return new TreeNode(x);</span><br><span class="line">    &#125;</span><br><span class="line">    if (x == root-&gt;val) &#123;</span><br><span class="line">        root-&gt;count++; // 如果值相同，增加当前节点的重复次数</span><br><span class="line">    &#125;</span><br><span class="line">    else if (x &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;leftCount++; // 更新左子树节点数量</span><br><span class="line">        root-&gt;left = insert(root-&gt;left, x);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, x);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取节点排名</span><br><span class="line">int getRank(TreeNode* root, int x) &#123;</span><br><span class="line">    int rank = 0;</span><br><span class="line">    while (root) &#123;</span><br><span class="line">        if (x == root-&gt;val) &#123;</span><br><span class="line">            return rank + root-&gt;leftCount + 1; // 当前节点的排名为左子树节点数量加上重复次数加1</span><br><span class="line">        &#125;</span><br><span class="line">        else if (x &lt; root-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            rank += root-&gt;leftCount + root-&gt;count; // 更新排名</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return rank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据排名获取节点值</span><br><span class="line">int getValueByRank(TreeNode* root, int rank) &#123;</span><br><span class="line">    while (root) &#123;</span><br><span class="line">        int leftSubtreeSize = root-&gt;leftCount;</span><br><span class="line">        int currentNodeCount = root-&gt;count;</span><br><span class="line">        int totalLeftNodes = leftSubtreeSize + currentNodeCount;</span><br><span class="line"></span><br><span class="line">        if (rank &lt;= leftSubtreeSize) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (rank &gt; totalLeftNodes) &#123;</span><br><span class="line">            rank -= totalLeftNodes;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (-n); // 如果未找到，返回-1或其他适当的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取前驱节点值</span><br><span class="line">int getPredecessor(TreeNode* root, int x) &#123;</span><br><span class="line">    int predecessor = -2147483647;</span><br><span class="line">    while (root) &#123;</span><br><span class="line">        if (x &lt;= root-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            predecessor = root-&gt;val;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return predecessor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取后继节点值</span><br><span class="line">int getSuccessor(TreeNode* root, int x) &#123;</span><br><span class="line">    int successor = 2147483647;</span><br><span class="line">    while (root) &#123;</span><br><span class="line">        if (x &gt;= root-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            successor = root-&gt;val;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return successor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    TreeNode* root = nullptr;</span><br><span class="line">    int q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    for (int i = 0; i &lt; q; i++) &#123;</span><br><span class="line">        int op, x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        switch (op) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            cout &lt;&lt; getRank(root, x) &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            cout &lt;&lt; getValueByRank(root, x) &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            cout &lt;&lt; getPredecessor(root, x) &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            cout &lt;&lt; getSuccessor(root, x) &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        case 5:</span><br><span class="line">            root = insert(root, x);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-队列安排"><a href="#5-队列安排" class="headerlink" title="5.队列安排"></a>5.队列安排</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个学校里老师要将班上 N 个同学排成一列，同学被编号为1∼N，他采取如下的方法：</span><br><span class="line"></span><br><span class="line">先将 1 号同学安排进队列，这时队列中只有他一个人；</span><br><span class="line"></span><br><span class="line">2-N 号同学依次入列，编号为 i 的同学入列方式为：老师指定编号为 i 的同学站在编号为 1∼(i−1) 中某位同学（即之前已经入列的同学）的左边或右边；</span><br><span class="line"></span><br><span class="line">最后，从队列中去掉 M(M&lt;N） 个同学，其他同学位置顺序不变。</span><br><span class="line"></span><br><span class="line">在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第 1 行为一个正整数 N，表示了有 N 个整数。</span><br><span class="line">第 2∼N行，第 i 行包含两个整数 k,p，其中 k 为小于i 的正整数，p 为 0 或者 1。若 p 为0，则表示将 i 号同学插入到 k 号同学的左边，p 为 1 则表示插入到右边。</span><br><span class="line">第 N+1 行为一个正整数 M，表示去掉的同学数目。</span><br><span class="line">接下来 M行，每行一个正整数 x，表示将 x 号同学从队列中移去，如果 x 号同学已经不在队列中则忽略这一条指令。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">1 行，包含最多 N 个空格隔开的正整数，表示了队列从左到右所有同学的编号，行末换行且无空格。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mx=1e5+10;</span><br><span class="line">int n,m;</span><br><span class="line">struct T&#123;</span><br><span class="line">    int l,r;        //每个同学的“左右手” </span><br><span class="line">int d;          //表示同学是否输出 </span><br><span class="line">&#125;t[mx]=&#123;0&#125;;</span><br><span class="line">void add(int i,int k,int f)       //新增同学 </span><br><span class="line">&#123;</span><br><span class="line">    if(f==1)         //左 </span><br><span class="line">    &#123;</span><br><span class="line">        t[k].r=t[i].r;</span><br><span class="line">        t[k].l=i; </span><br><span class="line">        t[i].r=k;</span><br><span class="line">        t[t[k].r].l=k;</span><br><span class="line">    &#125;</span><br><span class="line">    else             //右 </span><br><span class="line">    &#123;</span><br><span class="line">        t[k].r=i;</span><br><span class="line">        t[k].l=t[i].l;</span><br><span class="line">        t[i].l=k;</span><br><span class="line">        t[t[k].l].r=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int x,k,f;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    t[0].r=0,t[0].l=0;</span><br><span class="line">    add(0,1,1);</span><br><span class="line">    for (int i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;f;</span><br><span class="line">        add(x,i,f);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        t[x].d=1;         //将该同学标记为不输出 </span><br><span class="line">    &#125;</span><br><span class="line">    for (int i=t[0].r;i;i=t[i].r)</span><br><span class="line">    &#123;</span><br><span class="line">        if (t[i].d==0)    //输出未标记的 </span><br><span class="line">          cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-明明的随机数"><a href="#6-明明的随机数" class="headerlink" title="6.明明的随机数"></a>6.明明的随机数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 N个 1到 1000 之间的随机整数 （N&lt;=100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">输入有两行，第 1 行为 1 个正整数，表示所生成的随机数的个数 N。</span><br><span class="line">第 2 行有 N个用空格隔开的正整数，为所产生的随机数。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">输出也是两行，第 1 行为 1 个正整数 M，表示不相同的随机数的个数。</span><br><span class="line">第 2 行为 M 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。</span><br><span class="line"></span><br><span class="line">样例</span><br><span class="line">输入</span><br><span class="line"></span><br><span class="line">10</span><br><span class="line">20 40 32 67 40 20 89 300 400 15</span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">15 20 32 40 67 89 300 400</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;//头文件</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">bool a[1001]=&#123;0&#125;;//定义一个桶</span><br><span class="line">int n,i,x;</span><br><span class="line">cin&gt;&gt;n;//输入数量</span><br><span class="line">for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;x;//读入数据</span><br><span class="line">a[x]=1;//统计数据+去重</span><br><span class="line">&#125;</span><br><span class="line">n=0;</span><br><span class="line">for(i=1;i&lt;=1000;i++)&#123;</span><br><span class="line">if(a[i]==1)n++;//统计数量</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;n&lt;&lt;endl;//输出数量</span><br><span class="line">for(i=1;i&lt;=1000;i++)&#123;</span><br><span class="line">if(a[i]==1)cout&lt;&lt;i&lt;&lt;&quot; &quot;;//最后的输出</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桶排序</p><h3 id="7-奖学金"><a href="#7-奖学金" class="headerlink" title="7.奖学金"></a>7.奖学金</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前 5 名学生发奖学金。期末，每个学生都有 3 门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学 排在前面，这样，每个学生的排序是唯一确定的。</span><br><span class="line">任务：先根据输入的 3 门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前 5 名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分) 是:</span><br><span class="line">7 279</span><br><span class="line">5 279</span><br><span class="line">这两行数据的含义是:总分最高的两个同学的学号依次是 7 号、5 号。这两名同学的总分都是 279 (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为 7 的学生语文成绩更高一些。如果你的前两名的输出数据是:</span><br><span class="line">5 279</span><br><span class="line">7 279</span><br><span class="line">则按输出错误处理，不能得分。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">共 n+1行。</span><br><span class="line">第 1 行为一个正整数n（n≤300)，表示该校参加评选的学生人数。</span><br><span class="line">第 2 到 n+1 行，每行有 3 个用空格隔开的数字，每个数字都在 0 到 100之间。第 j行的 3 个数字依次表示学号为 j-1 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 1~n（恰好是输入数据的行号减 1）。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">共 5 行，每行是两个用空格隔开的正整数，依次表示前 5 名学生的学号和总分。</span><br><span class="line"></span><br><span class="line">样例</span><br><span class="line">输入1</span><br><span class="line"></span><br><span class="line">6</span><br><span class="line">90 67 80</span><br><span class="line">87 66 91</span><br><span class="line">78 89 91</span><br><span class="line">88 99 77</span><br><span class="line">67 89 64</span><br><span class="line">78 89 98</span><br><span class="line">输出1</span><br><span class="line"></span><br><span class="line">6 265</span><br><span class="line">4 264</span><br><span class="line">3 258</span><br><span class="line">2 244</span><br><span class="line">1 237</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct stu</span><br><span class="line">&#123;</span><br><span class="line">    int num;//编号</span><br><span class="line">    int c,m,e; </span><br><span class="line">    int sum;</span><br><span class="line">&#125;student[310];</span><br><span class="line">bool cmp(stu a,stu b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a.sum&gt;b.sum) return 1;</span><br><span class="line">    else if(a.sum&lt;b.sum) return 0;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(a.c&gt;b.c) return 1;</span><br><span class="line">        else if(a.c&lt;b.c) return 0;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(a.num&gt;b.num) return 0;</span><br><span class="line">            else return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        student[i].num=i;//录入编号</span><br><span class="line">        cin&gt;&gt;student[i].c&gt;&gt;student[i].m&gt;&gt;student[i].e;//输入</span><br><span class="line">        student[i].sum=student[i].c+student[i].m+student[i].e;//计算总分</span><br><span class="line">    &#125;</span><br><span class="line">    sort(student+1,student+1+n,cmp);</span><br><span class="line">    for(int i=1;i&lt;=5;i++)</span><br><span class="line">        cout&lt;&lt;student[i].num&lt;&lt;&#x27; &#x27;&lt;&lt;student[i].sum&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-纪念品分组"><a href="#8-纪念品分组" class="headerlink" title="8.纪念品分组"></a>8.纪念品分组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得 的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品， 并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。</span><br><span class="line"></span><br><span class="line">你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">共 n+2行：</span><br><span class="line">第一行包括一个整数 w，为每组纪念品价格之和的上限。</span><br><span class="line">第二行为一个整数 n，表示购来的纪念品的总件数 G。</span><br><span class="line">第 3 ∼n+2 行每行包含一个正整数 Pi 表示所对应纪念品的价格。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">一个整数，即最少的分组数目。</span><br><span class="line"></span><br><span class="line">样例</span><br><span class="line">输入</span><br><span class="line"></span><br><span class="line">100 </span><br><span class="line">9 </span><br><span class="line">90 </span><br><span class="line">20 </span><br><span class="line">20 </span><br><span class="line">30 </span><br><span class="line">50 </span><br><span class="line">60 </span><br><span class="line">70 </span><br><span class="line">80 </span><br><span class="line">90</span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>题意</p><p>输入一个有N个数字的数组，你要将它们分组（每组只能由两数组成），使各组两数之和（两数之和&lt;&#x3D;W）接近。输出满足上述条件的最小组数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int p[100005];</span><br><span class="line">int w, n;</span><br><span class="line">int main ()&#123;</span><br><span class="line">    cin &gt;&gt;w&gt;&gt;n;</span><br><span class="line">    for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p, p + n);</span><br><span class="line">    int  j = 0;</span><br><span class="line">    int sum =0;</span><br><span class="line">    for(int i = n - 1; i &gt;= j; i--)&#123;</span><br><span class="line">        if(p[i] + p[j] &lt;= w)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="9-统计数字"><a href="#9-统计数字" class="headerlink" title="9.统计数字"></a>9.统计数字</h3><p>[P1097 <a href="https://www.luogu.com.cn/problem/solution/P1097">NOIP2007 提高组] 统计数字 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">某次科研调查时得到了n个自然数，每个数均不超过1500000000(1.5×109</span><br><span class="line">)。已知不相同的数不超过10000个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">共n+1行。</span><br><span class="line"></span><br><span class="line">第一行是整数n，表示自然数的个数；</span><br><span class="line"></span><br><span class="line">第2至n+1每行一个自然数。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">共m行（m为n个自然数中不相同数的个数），按照自然数从小到大的顺序输出。</span><br><span class="line"></span><br><span class="line">每行输出2个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    // 使用map来存储自然数及其出现次数</span><br><span class="line">    std::map&lt;int, int&gt; countMap;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        int num;</span><br><span class="line">        std::cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">        // 更新map中自然数的出现次数</span><br><span class="line">        countMap[num]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历map，按照自然数从小到大的顺序输出统计结果</span><br><span class="line">    for (auto it = countMap.begin(); it != countMap.end(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-分数线划定"><a href="#10-分数线划定" class="headerlink" title="10.分数线划定"></a>10.分数线划定</h3><p>[P1068 <a href="https://www.luogu.com.cn/problem/P1068">NOIP2009 普及组] 分数线划定 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A 市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 150% 划定，即如果计划录取 m 名志愿者，则面试分数线为排名第 m ×150%（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。</span><br><span class="line"></span><br><span class="line">现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第一行，两个整数 n,m(5≤n≤5000,3≤m≤n)，中间用一个空格隔开，其中 n 表示报名参加笔试的选手总数，m 表示计划录取的志愿者人数。输入数据保证 m ×150% 向下取整后小于等于 n。</span><br><span class="line">第二行到第 n+1行，每行包括两个整数，中间用一个空格隔开，分别是选手的报名号 k(1000≤k≤9999)和该选手的笔试成绩 s(1≤s≤100)。数据保证选手的报名号各不相同。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">第一行，有 2 个整数，用一个空格隔开，第一个整数表示面试分数线；第二个整数为进入面试的选手的实际人数。</span><br><span class="line"></span><br><span class="line">从第二行开始，每行包含 2 个整数，中间用一个空格隔开，分别表示进入面试的选手的报名号和笔试成绩，按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。</span><br><span class="line"></span><br><span class="line">样例</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;//万能头文件</span><br><span class="line">using namespace std;</span><br><span class="line">int i,n,m,f,k[5001],s[5001],sub[5001];//f是分数线，sub是下标</span><br><span class="line">bool cmp(int a,int b)&#123;//sort规则</span><br><span class="line">    if(s[a]==s[b])return k[a]&lt;k[b];//成绩相等比编号</span><br><span class="line">    return s[a]&gt;s[b];//否则比成绩</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(i=1;i&lt;=n;i++)cin&gt;&gt;k[sub[i]=i]&gt;&gt;s[i];//输入编号和成绩，同时初始化下标</span><br><span class="line">    sort(sub+1,sub+n+1,cmp);//对下标排序</span><br><span class="line">    f=s[sub[int(m*1.5)]];//算分数线</span><br><span class="line">    for(i=1;s[sub[i]]&gt;=f;i++);//算录取人数</span><br><span class="line">    cout&lt;&lt;f&lt;&lt;&quot; &quot;&lt;&lt;i-1&lt;&lt;endl;</span><br><span class="line">    for(i=1;s[sub[i]]&gt;=f;i++)cout&lt;&lt;k[sub[i]]&lt;&lt;&quot; &quot;&lt;&lt;s[sub[i]]&lt;&lt;endl;//输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-合并果子"><a href="#11-合并果子" class="headerlink" title="11.合并果子"></a>11.合并果子</h3><p>[P1090 <a href="https://www.luogu.com.cn/problem/P1090">NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</span><br><span class="line"></span><br><span class="line">每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</span><br><span class="line"></span><br><span class="line">因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</span><br><span class="line"></span><br><span class="line">例如有 3 种果子，数目依次为 1 ， 2 ， 9 。可以先将 1 、 2 堆合并，新堆数目为 3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为 12 。所以多多总共耗费体力 =3+12=15 。可以证明 15 为最小的体力耗费值。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">共两行。</span><br><span class="line">第一行是一个整数 n(1≤n≤10000) ，表示果子的种类数。</span><br><span class="line">第二行包含 n 个整数，用空格分隔，第 i 个整数ai(1≤ai≤20000) 是第 i 种果子的数目。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2e31</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,x,ans;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;x,q.push(x);</span><br><span class="line">while(q.size()&gt;=2)&#123;</span><br><span class="line">int a=q.top(); q.pop();</span><br><span class="line">int b=q.top(); q.pop();</span><br><span class="line">ans+=a+b;</span><br><span class="line">q.push(a+b);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="1-合并两个有序链表"><a href="#1-合并两个有序链表" class="headerlink" title="1.合并两个有序链表"></a>1.合并两个有序链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 合并两个有序链表</span><br><span class="line">描述</span><br><span class="line">将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</span><br><span class="line">输入</span><br><span class="line">输入两个顺序表l1，l2，l1和l2均按非递减顺序排列，两个链表的节点数目范围是 [0, 50]，-100 &lt;= Node.val &lt;= 100</span><br><span class="line">-1表示链表结束符</span><br><span class="line">输出</span><br><span class="line">输出合并后的顺序表</span><br><span class="line">输入样例</span><br><span class="line"></span><br><span class="line">1 2 4 -1</span><br><span class="line">1 3 4 -1</span><br><span class="line">输出样例</span><br><span class="line"></span><br><span class="line">1 1 2 3 4 4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    if (l1 == NULL) &#123;</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (l2 == NULL) &#123;</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;</span><br><span class="line">    l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">    return l2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建新节点</span><br><span class="line">struct ListNode* createNode(int val) &#123;</span><br><span class="line">    struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">    if (newNode != NULL) &#123;</span><br><span class="line">        newNode-&gt;val = val;</span><br><span class="line">        newNode-&gt;next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入节点到链表末尾</span><br><span class="line">void insertNode(struct ListNode** head, int val) &#123;</span><br><span class="line">    struct ListNode* newNode = createNode(val);</span><br><span class="line">    if (*head == NULL) &#123;</span><br><span class="line">        *head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        struct ListNode* current = *head;</span><br><span class="line">        while (current-&gt;next != NULL) &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用于输出链表</span><br><span class="line">void printList(struct ListNode* head) &#123;</span><br><span class="line">    while (head != NULL) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, head-&gt;val);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">   // 表示链表结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建链表1: 1 -&gt; 2 -&gt; 4</span><br><span class="line"></span><br><span class="line">    struct ListNode* l1 = NULL;</span><br><span class="line">    for (int i = 0;; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a = 0;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        if (a == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        insertNode(&amp;l1, a);</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* l2 = NULL;</span><br><span class="line">    for (int i = 0;; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a = 0;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        if (a == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        insertNode(&amp;l2, a);</span><br><span class="line">    &#125;</span><br><span class="line">    // 合并两个有序链表</span><br><span class="line">    struct ListNode* mergedList = mergeTwoLists(l1, l2);</span><br><span class="line">    // 输出合并后的链表</span><br><span class="line">    printList(mergedList);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-删除排序链表中的重复元素"><a href="#2-删除排序链表中的重复元素" class="headerlink" title="2.删除排序链表中的重复元素"></a>2.删除排序链表中的重复元素</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回已排序的链表 </span><br><span class="line">输入</span><br><span class="line">输入已排序的链表，链表中节点数目在范围 [0, 300] 内，-100 &lt;= Node.val &lt;= 100，题目数据保证链表已经按升序排列</span><br><span class="line">-1表示链表结束符</span><br><span class="line">输出</span><br><span class="line">输出已排序的链表</span><br><span class="line">输入样例</span><br><span class="line"></span><br><span class="line">1 1 2 3 3 -1</span><br><span class="line">输出样例</span><br><span class="line"></span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Function to delete duplicates from a sorted linked list</span><br><span class="line">struct ListNode* deleteDuplicates(struct ListNode* head) &#123;</span><br><span class="line">    if (head == nullptr || head-&gt;next == nullptr) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct ListNode* current = head;</span><br><span class="line"></span><br><span class="line">    while (current != nullptr &amp;&amp; current-&gt;next != nullptr) &#123;</span><br><span class="line">        if (current-&gt;val == current-&gt;next-&gt;val) &#123;</span><br><span class="line">            // Duplicate found, skip the next node</span><br><span class="line">            struct ListNode* temp = current-&gt;next;</span><br><span class="line">            current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Move to the next node</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Function to insert a node at the end of the linked list</span><br><span class="line">void insertNode(struct ListNode** head, int val) &#123;</span><br><span class="line">    struct ListNode* newNode = new ListNode;</span><br><span class="line">    newNode-&gt;val = val;</span><br><span class="line">    newNode-&gt;next = nullptr;</span><br><span class="line"></span><br><span class="line">    if (*head == nullptr) &#123;</span><br><span class="line">        *head = newNode;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        struct ListNode* current = *head;</span><br><span class="line">        while (current-&gt;next != nullptr) &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Function to print the linked list</span><br><span class="line">void printList(struct ListNode* head) &#123;</span><br><span class="line">    while (head != nullptr) &#123;</span><br><span class="line">        cout &lt;&lt; head-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    struct ListNode* head = nullptr;</span><br><span class="line"></span><br><span class="line">    // Create a sorted linked list</span><br><span class="line">    int value;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        cin &gt;&gt; value;</span><br><span class="line">        if (value == -1) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        insertNode(&amp;head, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Delete duplicates</span><br><span class="line">    head = deleteDuplicates(head);</span><br><span class="line"></span><br><span class="line">    // Print the resulting linked list</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-板子"><a href="#总结-板子" class="headerlink" title="总结  板子"></a>总结  板子</h2><h3 id="1-定义链表"><a href="#1-定义链表" class="headerlink" title="1.定义链表"></a>1.定义链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-创建链表"><a href="#2-创建链表" class="headerlink" title="2.创建链表"></a>2.创建链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode* createNode(int val) &#123;</span><br><span class="line">    struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">    if (newNode != NULL) &#123;</span><br><span class="line">        newNode-&gt;val = val;</span><br><span class="line">        newNode-&gt;next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-插入尾节点"><a href="#3-插入尾节点" class="headerlink" title="3.插入尾节点"></a>3.插入尾节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void insertNode(struct ListNode** head, int val) &#123;</span><br><span class="line">    struct ListNode* newNode = createNode(val);</span><br><span class="line">    if (*head == NULL) &#123;</span><br><span class="line">        *head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        struct ListNode* current = *head;</span><br><span class="line">        while (current-&gt;next != NULL) &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-输出链表"><a href="#4-输出链表" class="headerlink" title="4.输出链表"></a>4.输出链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void printList(struct ListNode* head) &#123;</span><br><span class="line">    while (head != NULL) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, head-&gt;val);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 表示链表结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-反转链表"><a href="#5-反转链表" class="headerlink" title="5.反转链表"></a>5.反转链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">    ListNode* prev = nullptr;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    while (current != nullptr) &#123;</span><br><span class="line">        ListNode* nextTemp = current-&gt;next;</span><br><span class="line">        current-&gt;next = prev;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-反转链表2"><a href="#6-反转链表2" class="headerlink" title="6. 反转链表2"></a>6. 反转链表2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode* reverseLists(struct ListNode* head,int left,int right) &#123;</span><br><span class="line">    if (head == NULL || left == right) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* dummy = new ListNode();</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    struct ListNode* pre = dummy;</span><br><span class="line">    for (int i = 0; i &lt; left-1; i++) &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* cur = pre-&gt;next;</span><br><span class="line">    struct ListNode* next = NULL;</span><br><span class="line">    for (int i = 0; i &lt; right - left; ++i) &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-删除值为val的节点"><a href="#7-删除值为val的节点" class="headerlink" title="7.删除值为val的节点"></a>7.删除值为val的节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode* deleteLists(struct ListNode* l, int val) &#123;</span><br><span class="line">    struct ListNode dummy;//创建一个名为 dummy 的虚拟头节点，其 next 指针指向原始链表的头部。这样做的目的是简化边界情况的处理，因为无论原始链表是否为空，我们都能够使用 dummy.next 访问到链表的头部。</span><br><span class="line">    dummy.next = l;</span><br><span class="line">    struct ListNode* current = &amp;dummy;</span><br><span class="line"></span><br><span class="line">    while (current-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if (current-&gt;next-&gt;val == val) &#123;</span><br><span class="line">            struct ListNode* temp = current-&gt;next;</span><br><span class="line">            current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-删除最后第N个节点"><a href="#8-删除最后第N个节点" class="headerlink" title="8.删除最后第N个节点"></a>8.删除最后第N个节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode* deleteLists(struct ListNode* l, int num) &#123;</span><br><span class="line">    l = reverseList(l);</span><br><span class="line">    struct ListNode dummy;//创建一个名为 dummy 的虚拟头节点，其 next 指针指向原始链表的头部。这样做的目的是简化边界情况的处理，因为无论原始链表是否为空，我们都能够使用 dummy.next 访问到链表的头部。</span><br><span class="line">    dummy.next = l;</span><br><span class="line">    struct ListNode* current = &amp;dummy;</span><br><span class="line">    int number = 1;</span><br><span class="line">    while (current-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if (number==num) &#123;</span><br><span class="line">            struct ListNode* temp = current-&gt;next;</span><br><span class="line">            current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return reverseList(dummy.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-合并有序链表（递归）"><a href="#9-合并有序链表（递归）" class="headerlink" title="9.合并有序链表（递归）"></a>9.合并有序链表（递归）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    if (l1 == NULL) &#123;</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (l2 == NULL) &#123;</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;</span><br><span class="line">    l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">    return l2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-链表孪生和"><a href="#10-链表孪生和" class="headerlink" title="10.链表孪生和"></a>10.链表孪生和</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int pairSum(ListNode* head) &#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head-&gt;next;</span><br><span class="line">    while (fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 反转链表</span><br><span class="line">    ListNode* last = slow-&gt;next;</span><br><span class="line">    while (last-&gt;next) &#123;</span><br><span class="line">        ListNode* cur = last-&gt;next;</span><br><span class="line">        last-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    ListNode* x = head;</span><br><span class="line">    ListNode* y = slow-&gt;next;</span><br><span class="line">    while (y) &#123;</span><br><span class="line">        ans = max(ans, x-&gt;val + y-&gt;val);</span><br><span class="line">        x = x-&gt;next;</span><br><span class="line">        y = y-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-两数相加"><a href="#11-两数相加" class="headerlink" title="11.两数相加"></a>11.两数相加</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    if (l1 == NULL) &#123;</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (l2 == NULL) &#123;</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* result = NULL;</span><br><span class="line">    struct ListNode* current = NULL;</span><br><span class="line">    int carry = 0;</span><br><span class="line">    while (l1 != NULL || l2 != NULL || carry != 0) &#123;</span><br><span class="line">        int val1 = (l1 != NULL) ? l1-&gt;val : 0;</span><br><span class="line">        int val2 = (l2 != NULL) ? l2-&gt;val : 0;</span><br><span class="line"></span><br><span class="line">        int sum = val1 + val2 + carry;</span><br><span class="line">        carry = sum / 10;</span><br><span class="line"></span><br><span class="line">        struct ListNode* newNode = createNode(sum % 10);</span><br><span class="line"></span><br><span class="line">        if (result == NULL) &#123;</span><br><span class="line">            result = newNode;</span><br><span class="line">            current = result;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            current-&gt;next = newNode;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (l1 != NULL) l1 = l1-&gt;next;</span><br><span class="line">        if (l2 != NULL) l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Reverse the result list before returning</span><br><span class="line">    return reverseLists(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>力扣面试题</title>
      <link href="/2023/09/26/%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/09/26/%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣面试-数据结构作业题库"><a href="#力扣面试-数据结构作业题库" class="headerlink" title="力扣面试+数据结构作业题库"></a>力扣面试+数据结构作业题库</h1><h2 id="1-合并有序数组"><a href="#1-合并有序数组" class="headerlink" title="1.合并有序数组"></a>1.合并有序数组</h2><p>两种思路，第一个交换</p><p><img src="https://pic.leetcode-cn.com/29ab5c730deb7ffec1d7854bbfdc1552a6829a6ac5da4e64e591150f08757e68-%E5%9B%BE%E7%89%87.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">    int i = nums1.size() - 1;</span><br><span class="line">    m--;</span><br><span class="line">    n--;</span><br><span class="line">    while (n &gt;= 0) &#123;</span><br><span class="line">        while (m &gt;= 0 &amp;&amp; nums1[m] &gt; nums2[n]) &#123;</span><br><span class="line">            swap(nums1[i--], nums1[m--]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums1[i--], nums2[n--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种，直接覆盖，在排列</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">            nums1[m + i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法三：双指针<br>算法</p><p>  已经被排序的性质。为了利用这一性质，我们可以使用双指针方法。这一方法将两个数组看作队列，每次从两个数组头部取出比较小的数字放到结果中。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sorted[m + n];</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == m) &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == n) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            sorted[p1 + p2 - <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != m + n; ++i) &#123;</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-移除元素"><a href="#2-移除元素" class="headerlink" title="2.移除元素"></a>2.移除元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(nums[i]==val)</span><br><span class="line">         &#123;</span><br><span class="line">             nums[i]=<span class="number">0</span>;</span><br><span class="line">             j++;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>()-j;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>由于题目要求删除数组中等于 val的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置。</p><p>如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</p><p>如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位。</p><p>整个过程保持不变的性质是：区间 [0,left) 中的元素都不等于 val。当左右指针遍历完输入数组以后，left 的值就是输出数组的长度。</p><p>这样的算法在最坏情况下（输入数组中没有元素等于 val），左右指针各遍历了数组一次。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != val) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度O（n)z至多遍历2次</p><p>空间复杂度O(1)</p><h3 id="双指针优化"><a href="#双指针优化" class="headerlink" title="双指针优化"></a>双指针优化</h3><p>如果要移除的元素恰好在数组的开头，例如序列 [1,2,3,4,5][1,2,3,4,5][1,2,3,4,5]，当 val为 111 时，我们需要把每一个元素都左移一位。注意到题目中说：「元素的顺序可以改变」。实际上我们可以直接将最后一个元素 555 移动到序列开头，取代元素 111，得到序列 [5,2,3,4][5,2,3,4][5,2,3,4]，同样满足题目要求。这个优化在序列中 val 元素的数量较少时非常有效。</p><p>实现方面，我们依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。</p><p>算法</p><p>如果左指针 left指向的元素等于 val，此时将右指针 right 指向的元素复制到左指针 left 的位置，然后右指针 right 左移一位。如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 val 为止。</p><p>当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素。</p><p>这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>;<span class="type">int</span> right=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]==val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[left]=nums[right<span class="number">-1</span>];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">                 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-删除有序数组中的重复项"><a href="#3-删除有序数组中的重复项" class="headerlink" title="3.删除有序数组中的重复项"></a>3.删除有序数组中的重复项</h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1.双指针"></a>1.双指针</h3><p>i为慢指针，指向答案位置</p><p>j为快指针，用来扫描</p><p>当nums[j]!&#x3D;nums[i],找到不重复项，复制到答案位置，i指针前进一步</p><h2 id="4-删除有序数组中的重复项二"><a href="#4-删除有序数组中的重复项二" class="headerlink" title="4.删除有序数组中的重复项二"></a>4.删除有序数组中的重复项二</h2><p>简单修改3就可</p><h2 id="5-多数元素"><a href="#5-多数元素" class="headerlink" title="5.多数元素"></a>5.多数元素</h2><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最简单的暴力方法是，枚举数组中的每个元素，再遍历一遍数组统计其出现次数。该方法的时间复杂度是 O(n2)O(n^2)O(n<br>2<br> )，会超出时间限制，因此我们需要找出时间复杂度小于 O(n2)O(n^2)O(n<br>2<br> ) 的优秀做法。</p><h4 id="1-方法一：哈希表"><a href="#1-方法一：哈希表" class="headerlink" title="1.方法一：哈希表"></a>1.方法一：哈希表</h4><p><a href="https://so.csdn.net/so/search?q=%E6%95%A3%E5%88%97%E8%A1%A8&spm=1001.2101.3001.7020">散列表</a>（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p><ul><li><p>哈希表也叫散列表</p></li><li><p>哈希表是一个数据结构</p></li><li><p>散列表是数组结构</p></li><li><pre><code class="c++">class Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int,int&gt;counts;        int majority =0,cnt =0;        for(int num:nums)        &#123;            ++counts[num];               if(counts[num]&gt;cnt)       &#123;           majority =num;           cnt =counts[num];       &#125;        &#125;return majority;    &#125;&#125;;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  首先创建一个哈希表counts，然后遍历数组nums</span><br><span class="line"></span><br><span class="line">  ![1695388913246](https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202401141420131.png)</span><br><span class="line"></span><br><span class="line">  用for的另外用法，对应的数的数组加一，进行打擂台形式选择最大项</span><br><span class="line"></span><br><span class="line">#### 2.摩根投票</span><br><span class="line"></span><br><span class="line">核心理念为 **票数正负抵消** 。此方法时间和空间复杂度分别为 O(N)和 O(1)，为本题的最佳解法。</span><br><span class="line"></span><br><span class="line">设输入数组 nums 的众数为 x ，数组长度为 n 。</span><br><span class="line"></span><br><span class="line">推论一： 若记 众数 的票数为 +1，非众数 的票数为 −1，则一定有所有数字的 票数和 &gt;0 。</span><br><span class="line"></span><br><span class="line">推论二： 若数组的前 a个数字的 票数和 =0，则 数组剩余 (n−a)个数字的 票数和一定仍 &gt;0，即后 (n−a) 个数字的 众数仍为 x 。</span><br><span class="line"></span><br><span class="line">。</span><br><span class="line"></span><br><span class="line">![Picture1.png](https://pic.leetcode-cn.com/1603612327-bOQxzq-Picture1.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 6.轮转数组</span><br><span class="line"></span><br><span class="line">给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 1.方法一</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;int&gt; newArr(n);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            newArr[(i + k) % n] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nums.assign(newArr.begin(), newArr.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>我们可以使用额外的数组来将每个元素放至正确的位置。用 n 表示数组的长度，我们遍历原数组，将原数组下标为 i 的元素放至新数组下标为 (i+k)mod n 的位置，最后将新数组拷贝至原数组即可。</p><ul><li>时间复杂度： O(n)，其中 n 为数组的长度。</li><li>空间复杂度： O(n</li></ul><p>(i+k)%n  轮转相当于对k进行模</p><h4 id="2-方法二：环状替换"><a href="#2-方法二：环状替换" class="headerlink" title="2.方法二：环状替换"></a>2.方法二：环状替换</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="type">int</span> count = <span class="built_in">gcd</span>(k, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; count; ++start) &#123;</span><br><span class="line">            <span class="type">int</span> current = start;</span><br><span class="line">            <span class="type">int</span> prev = nums[start];</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">int</span> next = (current + k) % n;</span><br><span class="line">                <span class="built_in">swap</span>(nums[next], prev);</span><br><span class="line">                current = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (start != current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法一中使用额外数组的原因在于如果我们直接将每个数字放至它最后的位置，这样被放置位置的元素会被覆盖从而丢失。因此，从另一个角度，我们可以将被替换的元素保存在变量 temp中，从而避免了额外数组的开销。</p><p>我们从位置0开始，最初令temp &#x3D; nums [0] 。根据规则，位置0的元素会放至(0＋ k) mod n的位置，令x&#x3D;(0＋k) mod n，此时交换temp和nums[x]，完成位置x的更新。然后，我们考察位置x，并交换temp和nums[(a ＋k) mod n]，从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置0。</p><p>容易发现，当回到初始位置 0 时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？我们不妨先考虑这样一个问题：从 0开始不断遍历，最终回到起点 0 的过程中，我们遍历了多少个元素？</p><p>由于最终回到了起点，故该过程恰好走了整数数量的圈，不妨设为 a 圈；再设该过程总共遍历了 b 个元素。因此，我们有 an&#x3D;bk即 an 一定为 n,k 的公倍数。又因为我们在第一次回到起点时就结束，因此 a要尽可能小，故 an 就是 n,k的最小公倍数 lcm(n,k)，因此 b 就为 lcm(n,k)&#x2F;k</p><p>这说明单次遍历会访问到 lcm(n,k)&#x2F;k 个元素。为了访问到所有的元素，我们需要进行遍历的次数为</p><p><img src="/.com//test-blog\source_posts\力扣面试题\1.png" alt="1"></p><p>其中 gcd 指的是最大公约数。</p><p>我们用下面的例子更具体地说明这个过程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums = [1, 2, 3, 4, 5, 6]</span><br><span class="line">k = 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/f0493a97cdb7bc46b37306ca14e555451496f9f9c21effcad8517a81a26f30d6-image.png" alt="image.png"></p><p>时间复杂度：O(n)，其中 n 为数组的长度。每个元素只会被遍历一次。</p><p>空间复杂度：O(1))。我们只需常数空间存放若干变量</p><h4 id="3-方法三：数组翻转"><a href="#3-方法三：数组翻转" class="headerlink" title="3.方法三：数组翻转"></a>3.方法三：数组翻转</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[start], nums[end]);</span><br><span class="line">            start += <span class="number">1</span>;</span><br><span class="line">            end -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, k, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该方法基于如下的事实：当我们将数组的元素向右移动 k 次后，尾部 k mod n 个元素会移动至数组头部，其余元素向后移动 k mod n 个位置。</p><p>该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的 k mod n个元素就被移至数组头部，然后我们再翻转[0,k mod n-1] 区间的元素和 [k mod n,n−1] 区间的元素即能得到最后的答案。</p><p>我们以 n&#x3D;7，k&#x3D;3为例进行如下展示：</p><p><img src="/.com//test-blog\source_posts\力扣面试题\2.png" alt="2"></p><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><h3 id="1-暴力法（遍历n-n-1-x2F-2找最大值）"><a href="#1-暴力法（遍历n-n-1-x2F-2找最大值）" class="headerlink" title="1.暴力法（遍历n*(n-1)&#x2F;2找最大值）"></a>1.暴力法（遍历n*(n-1)&#x2F;2找最大值）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> a =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                a=<span class="built_in">max</span>(a,prices[j]-prices[i]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度：O(n2)<br> )。循环运行 n(n−1)&#x2F;2</p><p>  次。<br>空间复杂度：O(1)。只使用了常数个变量。</p><h3 id="2-一次遍历法"><a href="#2-一次遍历法" class="headerlink" title="2.一次遍历法"></a>2.一次遍历法<img src="/.com//test-blog\source_posts\力扣面试题\3.png" alt="3"></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">        <span class="type">int</span> minprice = inf, maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price: prices) &#123;</span><br><span class="line">            maxprofit = <span class="built_in">max</span>(maxprofit, price - minprice);</span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。</p><p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。</p><ul><li>时间复杂度：O(n)，只需要遍历一次。</li><li>空间复杂度：O(1)，只使用了常数个变量。</li><li>差值最大却不在最低点买入的情况，这一定发生在到达股票最低点日子之前，记录 maxprofit 。 之后即使到了最低点，更改了 minprice, 但 maxprofit 却不会改变了。仍然是正确值</li></ul><h2 id="买卖股票的最佳时机2"><a href="#买卖股票的最佳时机2" class="headerlink" title="买卖股票的最佳时机2"></a>买卖股票的最佳时机2</h2><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="方法二：简单一次遍历"><a href="#方法二：简单一次遍历" class="headerlink" title="方法二：简单一次遍历"></a>方法二：简单一次遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> profit=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(prices[i]&gt;prices[i<span class="number">-1</span>])</span><br><span class="line">               &#123;</span><br><span class="line">                   profit+=prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="1-迭代法"><a href="#1-迭代法" class="headerlink" title="1.迭代法"></a>1.迭代法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>* <span class="built_in">ReverseList</span>(<span class="keyword">struct</span> ListNode* pHead ) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *curr = pHead;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        next = curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反转链表：<br>head    pre   next<br>1  -&gt;  2  -&gt;  3  -&gt;  4  -&gt;  5<br>head   pre    next<br>1  &lt;-  2      3  -&gt;  4  -&gt;  5<br>head    pre    next<br>1  &lt;-  2  &lt;-  3      4  -&gt;  5<br>head    pre    next<br>1  &lt;-  2  &lt;-  3  &lt;-  4      5<br>head    pre    next<br>1  &lt;-  2  &lt;-  3  &lt;-  4  &lt;-  5</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 将 curr 的下一个节点指向 prev：这一步是为了将当前节点 curr 的 next 指针指向它的前一个节点 prev。这样做的目的是为了使链表反转，将当前节点的指针方向改变，指向前一个节点。</span><br><span class="line"></span><br><span class="line">2. 将 prev 移动到 curr：这一步是为了将 prev 指针向右移动一位，使它指向 curr。这样做的目的是为了在下一次循环中，curr 的下一个节点仍然能够访问到它。</span><br><span class="line"></span><br><span class="line">3. 将 curr 移动到 next：这一步是为了将 curr 指针向右移动一位，使它指向 next。这样做的目的是为了在下一次循环中，将 curr 的下一个节点指向它的前一个节点。</span><br><span class="line"></span><br><span class="line">4. 将 next 移动到 curr 的下一个节点：这一步是为了将 next 指针向右移动一位，使它指向 curr 的下一个节点。这样做的目的是为了在下一次循环中，访问到 curr 的下一个节点。</span><br><span class="line"></span><br><span class="line">这些步骤综合起来，实际上就是在不断地将链表的指针方向进行反转，使得链表从原来的顺序变成相反的顺序。最后 prev 就会指向反转后链表的表头。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-递归法"><a href="#2-递归法" class="headerlink" title="2.递归法"></a>2.递归法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if (!head || !head-&gt;next) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = nullptr;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="for在c-的五种用法和string的用法"><a href="#for在c-的五种用法和string的用法" class="headerlink" title="for在c++的五种用法和string的用法"></a>for在c++的五种用法和string的用法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int nArray[] = &#123; 0, 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">vector&lt;int&gt; vecNum(nArray, nArray + 6);</span><br><span class="line">CString strText;</span><br><span class="line"> </span><br><span class="line">// 第一种用法：最原始的语法(用下标)</span><br><span class="line">for (size_t i = 0; i &lt; vecNum.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    strText.Format(&quot;%d&quot;, nArray[i]);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 第二种用法：最原始的语法(用迭代器)</span><br><span class="line">for (auto it = vecNum.begin(); it != vecNum.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    strText.Format(&quot;%d&quot;, *it);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 第三种用法：简化数组遍历语法(从vs2008开始支持)</span><br><span class="line">for each(auto item in vecNum)</span><br><span class="line">&#123;</span><br><span class="line">    strText.Format(&quot;%d&quot;, item);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 第四种用法：STL函数</span><br><span class="line">std::for_each(vecNum.begin(), vecNum.end(), [](int item)&#123;</span><br><span class="line">    CString strText;</span><br><span class="line">    strText.Format(&quot;%d&quot;, item);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// 第五种用法：C++11新增加的(VS2012支持)</span><br><span class="line">for(auto item : vecNum)</span><br><span class="line">&#123;</span><br><span class="line">    strText.Format(&quot;%d&quot;, item);</span><br><span class="line">    AfxMessageBox(strText);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C++string类常用方法</span><br><span class="line">1、string(const char *s) ：将 string 对象初始化为 s 指向的字符串</span><br><span class="line"></span><br><span class="line">string str(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">string(size_type n,char c) ：创建一个包含 n 个元素的 string 对象，其中每个元素都被初始化为字符 c</span><br><span class="line"></span><br><span class="line">string str(10, &#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line">string(const string &amp;str) ：将一个 string 对象初始化为 string 对象 str（复制构造函数）</span><br><span class="line"></span><br><span class="line">string str(&quot;abcde&quot;);</span><br><span class="line">string str2(str);</span><br><span class="line">string() ：创建一个默认的 string 对象，长度为 0（默认构造函数）</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">使用C语言风格字符串处理string对象</span><br><span class="line"></span><br><span class="line">string str = &quot;hello!&quot;;</span><br><span class="line">获取string对象的长度，C语言中使用strlen()来获取字符串长度，C++中使用str.size()或str.length().</span><br><span class="line"></span><br><span class="line">string str(&quot;hello!&quot;);</span><br><span class="line">int len1 = str.size();</span><br><span class="line">int len2 = str.length();</span><br><span class="line"></span><br><span class="line">将一个 string 对象赋值给另一个 string 对象</span><br><span class="line"></span><br><span class="line">string str(&quot;hello!&quot;);</span><br><span class="line">string str2;</span><br><span class="line">str2 = str;</span><br><span class="line"></span><br><span class="line">8、string 对象的拼接</span><br><span class="line">C 语言中使用 strcat、strncat 函数来进行字符串拼接操作，C++中可以采用以下方式：</span><br><span class="line"></span><br><span class="line">string str1(&quot;hello&quot;);</span><br><span class="line">string str2(&quot;world&quot;);</span><br><span class="line">string str3 = str1 + str2;</span><br><span class="line"></span><br><span class="line">9、使用 += 来在一个 string 对象后面附加一个 string 对象、字符以及 C 风格的字符串</span><br><span class="line"></span><br><span class="line">string str(&quot;hello&quot;);</span><br><span class="line">string str2(&quot;world&quot;);</span><br><span class="line">str += str2;</span><br><span class="line">str += &#x27;a&#x27;;</span><br><span class="line">str += &quot;abcd&quot;;</span><br><span class="line"></span><br><span class="line">10、string.append() 函数，在string对象后添加一个string对象或c风格字符串。</span><br><span class="line"></span><br><span class="line">string str(&quot;hello&quot;);</span><br><span class="line">string str2(&quot;world&quot;);</span><br><span class="line">str.append(str2);</span><br><span class="line">str.append(&quot;abcd&quot;);</span><br><span class="line"></span><br><span class="line">11、string.push_back() 函数来在一个 string 对象后面附加一个字符</span><br><span class="line"></span><br><span class="line">string str(&quot;hello&quot;);</span><br><span class="line">char ch = &#x27;a&#x27;;</span><br><span class="line">str.push_back(ch);</span><br><span class="line"></span><br><span class="line">12、对于string对象的比较，可以直接使用关系运算符。</span><br><span class="line"></span><br><span class="line">string str1(&quot;abcd&quot;);</span><br><span class="line">string str2(&quot;abcd&quot;);</span><br><span class="line">if(str1 == str2)</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">13、string对象的比较也可以使用string.compare() 方法</span><br><span class="line"></span><br><span class="line">int compare(const string&amp;str) const;</span><br><span class="line">int compare(size_t pos，size_t len，const string&amp;str)const;</span><br><span class="line">int compare(size_t pos，size_t len，const string&amp;str, size_t subpos，size_t sublen)const;</span><br><span class="line">int compare(const char * s)const;</span><br><span class="line">int compare(size_t pos，size_t len，const char * s)const;</span><br><span class="line">int compare(size_t pos，size_t len，const char * s，size_t n)const;</span><br><span class="line"></span><br><span class="line">// example</span><br><span class="line">string str1(&quot;hello world&quot;);</span><br><span class="line">string str2(&quot;hello boy&quot;);</span><br><span class="line">str1.compare(6, 3, str2, 6, 3);</span><br><span class="line"></span><br><span class="line">14、使用 string.substr() 函数来获取子串</span><br><span class="line"></span><br><span class="line">string str(&quot;hello&quot;);</span><br><span class="line">string str2 = str.substr(3,2)</span><br><span class="line"></span><br><span class="line">15、访问 string 字符串的元素</span><br><span class="line"></span><br><span class="line">string str(&quot;hello&quot;);</span><br><span class="line">cout &lt;&lt; str[2] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str.at(2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">16、使用 string.find() 方法查找字符</span><br><span class="line"></span><br><span class="line">//  从字符串的 pos 位置开始（若不指定 pos 的值，则默认从索引 0 处开始），查找子字符串 str。</span><br><span class="line">//  如果找到，则返回该子字符串首次出现时其首字符的索引；否则，返回 string::npos：</span><br><span class="line">//  string 类将 npos 定义为保证大于任何有效下标的值。</span><br><span class="line">size_type find (const string&amp; str, size_type pos = 0) const;</span><br><span class="line">size_type find (const char *s, size_type pos = 0) const;</span><br><span class="line">size_type find (const char *s, size_type pos, size_type n);</span><br><span class="line">size_type find (char ch, size_type pos = 0) const;</span><br><span class="line"></span><br><span class="line">17、string.rfind() 与 string.find() 方法类似，只是查找顺序不一样， string.rfind() 是从指定位置 pos （默认为字符串末尾）开始向前查找，直到字符串的首部，并返回第一次查找到匹配项时匹配项首字符的索引。换句话说，就是查找子字符串或字符最后一次出现的位置。</span><br><span class="line"></span><br><span class="line">18、string.find_first_of() 方法在字符串中从指定位置开始向后（默认为索引 0 处）查找参数中任何一个字符首次出现的位置</span><br><span class="line"></span><br><span class="line">string str(&quot;hello world&quot;);</span><br><span class="line">int pos = str.find_first_of(&quot;abcde&quot;);</span><br><span class="line">int pos = str.find_first_of(&quot;abcde&quot;, 1);  // 第二个参数为位置</span><br><span class="line"></span><br><span class="line">19、string.find_last_of() 方法在字符串中查找参数中任何一个字符最后一次出现的位置</span><br><span class="line"></span><br><span class="line">20、string.find_first_not_of() 方法在字符串中查找第一个不包含在参数中的字符</span><br><span class="line"></span><br><span class="line">21、string.find_last_not_of() 方法在字符串中查找最后一个不包含在参数中的字符</span><br><span class="line"></span><br><span class="line">22、使用 string.insert() 进行插入操作</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，const string＆str）;　　　</span><br><span class="line">// 在位置 pos 处插入字符串 str</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，const string＆str，size_t subpos，size_t sublen）;　</span><br><span class="line">// 在位置 pos 处插入字符串 str 的从位置 subpos 处开始的 sublen 个字符</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，const char * s）;　　　　</span><br><span class="line">// 在位置 pos 处插入字符串 s</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，const char * s，size_t n）;　</span><br><span class="line">// 在位置 pos 处插入字符串 s 的前 n 个字符</span><br><span class="line"></span><br><span class="line">string&amp; insert（size_t pos，size_t n，char c）;　　　　　 </span><br><span class="line">// 在位置 pos 处插入 n 个字符 c</span><br><span class="line"></span><br><span class="line">iterator insert (const_iterator p, size_t n, char c);　</span><br><span class="line">// 在 p 处插入 n 个字符 c，并返回插入后迭代器的位置</span><br><span class="line"></span><br><span class="line">iterator insert (const_iterator p, char c);　　　　　　 </span><br><span class="line">// 在 p 处插入字符 c，并返回插入后迭代器的位置</span><br><span class="line"></span><br><span class="line">23、使用 string.erase() 进行元素删除操作</span><br><span class="line"></span><br><span class="line">string&amp; erase (size_t pos = 0, size_t len = npos);　　　// 删除从 pos 处开始的 n 个字符</span><br><span class="line">iterator erase (const_iterator p);　　　　　　　　　　　　// 删除 p 处的一个字符，并返回删除后迭代器的位置</span><br><span class="line">iterator erase (const_iterator first, const_iterator last);　// 删除从 first 到last 之间的字符，并返回删除后迭代器的位置</span><br><span class="line"></span><br><span class="line">24、使用 getline() 函数来获取 string 输入</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">getline(cin, str);</span><br><span class="line"></span><br><span class="line">25、使用 string.empty() 函数判断字符串是否为空</span><br><span class="line"></span><br><span class="line">26、使用 string.swap() 函数交换两个字符串</span><br><span class="line"></span><br><span class="line">string str1 = &quot;hello&quot;;</span><br><span class="line">string str2 = &quot;HELLO&quot;;</span><br><span class="line">str1.swap(str2);</span><br><span class="line"></span><br><span class="line">27、string.back()获取或修改字符串最后一个字符</span><br><span class="line"></span><br><span class="line">string str(&quot;abcd&quot;);</span><br><span class="line">char b = str.back();</span><br><span class="line">str.back() = &#x27;e&#x27;;</span><br><span class="line"></span><br><span class="line">28、string.front()获取或修改字符串第一个字符</span><br><span class="line"></span><br><span class="line">29、string.pop_back()删除字符串最后一个元素</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作业题库1-括号匹配（用顺序栈）"><a href="#作业题库1-括号匹配（用顺序栈）" class="headerlink" title="作业题库1 括号匹配（用顺序栈）"></a>作业题库1 括号匹配（用顺序栈）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ElemType char</span><br><span class="line">#define MaxSize 50</span><br><span class="line"></span><br><span class="line">typedef struct//自定义名为SqStack的栈</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    int top;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line">bool StackEmpty(SqStack S)//判断是否为空栈</span><br><span class="line">&#123;</span><br><span class="line">    if (S.top == -1)</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Pop(SqStack&amp; S, ElemType&amp; x)//出栈</span><br><span class="line">&#123;</span><br><span class="line">    if (S.top == -1)</span><br><span class="line">        return false;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    S.top--;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Push(SqStack&amp; S, ElemType x)//入栈</span><br><span class="line">&#123;</span><br><span class="line">    if (S.top == MaxSize - 1)</span><br><span class="line">        return false;</span><br><span class="line">    S.top++;</span><br><span class="line">    S.data[S.top] = x;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool GetPop(SqStack S, ElemType&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    if (S.top == -1)</span><br><span class="line">        return false;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void initStack(SqStack&amp; S)</span><br><span class="line">&#123;</span><br><span class="line">    S.top = -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    initStack(S);</span><br><span class="line">    string v;</span><br><span class="line">    getline(cin, v);</span><br><span class="line">    vector&lt;char&gt; c;</span><br><span class="line">    for (int i = 0; i &lt; v.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (v[i] == &#x27;(&#x27; || v[i] == &#x27;)&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            c.push_back(v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int b = 0;</span><br><span class="line">    char a;</span><br><span class="line">    int flag = 1;</span><br><span class="line">    while (b &lt; c.size() &amp;&amp; flag != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        a = c[b];</span><br><span class="line">        if (a == &#x27;(&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(S, a);</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            char getpop;</span><br><span class="line">            GetPop(S, getpop);</span><br><span class="line">            if (getpop == &#x27;(&#x27; &amp;&amp; a == &#x27;)&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                char pop;</span><br><span class="line">                Pop(S, pop);</span><br><span class="line">                b++;</span><br><span class="line">                flag = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                flag = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (StackEmpty(S) &amp;&amp; flag == 1)</span><br><span class="line">        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作业题库2-回文序列（用链栈）"><a href="#作业题库2-回文序列（用链栈）" class="headerlink" title="作业题库2 回文序列（用链栈）"></a>作业题库2 回文序列（用链栈）</h2><p>“回文”指正读反读均相同的字符序列，如“abcdcba”和“abba”均是回文，使用栈这种数据结构判断给定字符序列是否为回文，要求使用链栈实现。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;//stl容器</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">bool isPalindrome(string str) &#123;</span><br><span class="line">    stack&lt;char&gt; st;</span><br><span class="line">    int len = str.length();</span><br><span class="line"></span><br><span class="line">    // 将字符序列依次入栈</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        st.push(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 依次比较栈顶和栈底指针指向的字符</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        char topChar = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line"></span><br><span class="line">        if (topChar != str[i]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">    if (isPalindrome(str)) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;true&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;false&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题库3入栈和出栈"><a href="#题库3入栈和出栈" class="headerlink" title="题库3入栈和出栈"></a>题库3入栈和出栈</h2><p>给定一个正整数数列（以0表示输入结束），从第一个数开始，将每一个数入栈，入栈的同时获得一个分数，即该数的数值乘以入栈后栈的大小，请计算将所有元素入栈后的分数和，然后将栈内元素依次输出，要求使用顺序栈。元素个数&lt;100，每个元素&lt;100。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>;; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; str[i];</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum += (i+<span class="number">1</span>) * str[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = i;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="comment">// 将字符序列依次入栈</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;i ; j++) &#123;</span><br><span class="line">st.<span class="built_in">push</span>(str[j]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; st.<span class="built_in">top</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_SIZE = 100; // 栈的最大容量</span><br><span class="line"></span><br><span class="line">class Stack &#123;</span><br><span class="line">private:</span><br><span class="line">    int* data; // 栈的数组</span><br><span class="line">    int top; // 栈顶指针</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Stack() &#123;</span><br><span class="line">        data = new int[MAX_SIZE];</span><br><span class="line">        top = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Stack() &#123;</span><br><span class="line">        delete[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isEmpty() &#123;</span><br><span class="line">        return top == -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isFull() &#123;</span><br><span class="line">        return top == MAX_SIZE - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Stack is full. Cannot push more elements.&quot; &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        data[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Stack is empty. Cannot pop any element.&quot; &lt;&lt; endl;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int value = data[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getSize() &#123;</span><br><span class="line">        return top + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Stack stack;</span><br><span class="line">    int num, scoreSum = 0;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    while (num != 0) &#123;</span><br><span class="line">        stack.push(num);</span><br><span class="line">        int score = stack.getSize() * num; // 计算分数</span><br><span class="line">        scoreSum += score;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">    &#125;</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        int value = stack.pop();</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题库4-点击消除"><a href="#题库4-点击消除" class="headerlink" title="题库4     点击消除"></a>题库4     点击消除</h2><p>给定一个字符串，每次“点击”，可以把字符串中相邻两个相同字母消除，例如，字符串”abbc”点击后可以生成”ac”。但相同而不相邻、不相同的相邻字母都是不可以被消除的。<br>通过点击足够多次之后可以把字符串变得尽可能短，编程实现输出给定字符串足够多次点击后的最终形态。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ol><li>初始化一个空栈。</li><li>依次遍历字符串中的每个字符：<ul><li>如果栈为空，将当前字符入栈。</li><li>如果栈不为空且当前字符与栈顶字符相同，将栈顶字符出栈。</li><li>如果栈不为空且当前字符与栈顶字符不相同，将当前字符入栈。</li></ul></li><li>栈中剩余的字符即为点击足够多次后的最终形态。</li></ol><h2 id="题库5-周末舞会"><a href="#题库5-周末舞会" class="headerlink" title="题库5 周末舞会"></a>题库5 周末舞会</h2><p>假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头上各出一人配成舞伴。规定每个舞曲能有一对跳舞者。若两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。现要求写一个程序，模拟上述舞伴配对问题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxqsize 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dancePartner</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; males;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; females;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        males.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        females.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (males.<span class="built_in">empty</span>() || females.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> male = males.<span class="built_in">front</span>();</span><br><span class="line">        males.<span class="built_in">push</span>(male);</span><br><span class="line">        males.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> female = females.<span class="built_in">front</span>();</span><br><span class="line">        females.<span class="built_in">pop</span>();</span><br><span class="line">        females.<span class="built_in">push</span>(female);</span><br><span class="line">        cout &lt;&lt; male &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; female &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n, k;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">        cin&gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dancePartner</span>(m, n, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>采用STL库里的queue队列库，将其变成循环队列就好</p><h2 id="题库6-无法吃午餐的学生数量"><a href="#题库6-无法吃午餐的学生数量" class="headerlink" title="题库6  无法吃午餐的学生数量"></a>题库6  <strong>无法吃午餐的学生数量</strong></h2><p>学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：<br>1.如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。<br>否则，这名学生会 放弃这个三明治 并回到队列的尾部。<br>2.这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。</p><p>输入两个整数数组 students 和 sandwiches ，其中 sandwiches[i] 是栈里面第 i个三明治的类型（i &#x3D; 0 是栈的顶部）， students[j] 是初始队列里第 j名学生对三明治的喜好（j &#x3D; 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#define maxqsize 1000</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">void Partner(int *a,int *b, int len) &#123;</span><br><span class="line">    queue&lt;int&gt; studentsqueue;</span><br><span class="line">    stack&lt;int&gt; sandwichesstack;</span><br><span class="line">    int  unhappyCount = 0;</span><br><span class="line">    for (int i = 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        studentsqueue.push(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = len-1; i&gt;=0; i--) &#123;</span><br><span class="line">        sandwichesstack.push(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (!studentsqueue.empty() &amp;&amp; !sandwichesstack.empty()) &#123;</span><br><span class="line">        int frontStudent = studentsqueue.front();</span><br><span class="line">        int topSandwich = sandwichesstack.top();</span><br><span class="line"></span><br><span class="line">        if (frontStudent == topSandwich) &#123;</span><br><span class="line">            // 学生喜欢栈顶的三明治，拿走它并离开队列</span><br><span class="line">            studentsqueue.pop();</span><br><span class="line">            sandwichesstack.pop();</span><br><span class="line">            unhappyCount = 0; // 重置无法吃午餐的学生数量</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 学生不喜欢栈顶的三明治，放弃它并排到队尾</span><br><span class="line">            studentsqueue.pop();</span><br><span class="line">            studentsqueue.push(frontStudent);</span><br><span class="line">            unhappyCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查队列中剩余学生的喜好是否与栈顶的三明治类型相同</span><br><span class="line">        if (unhappyCount == studentsqueue.size()) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; studentsqueue.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int students[100];</span><br><span class="line">    int sandwiches[100];</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    for ( i = 0;; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; students[i];</span><br><span class="line"></span><br><span class="line">        if (students[i] == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (j = 0;; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; sandwiches[j];</span><br><span class="line"></span><br><span class="line">        if (sandwiches[j] == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Partner(students,sandwiches,i);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>队列是先进先出，栈是先进后出，不满意口味的当unhappystudents数量等于目前队列长度则跳出循环</p><h2 id="题库7-栈的操作"><a href="#题库7-栈的操作" class="headerlink" title="题库7  栈的操作"></a>题库7  栈的操作</h2><p>请你实现一个栈。<br>可以完成操作：<br>push x：将 x入栈，保证 x为 int 型整数。<br>pop：输出栈顶，并让栈顶出栈<br>top：输出栈顶，栈顶不出栈</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;str;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">string a;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getline</span>(cin, a);</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">string b;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">5</span>; j &lt; a.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line">b[sum] = a[j];</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">stoi</span>(b);</span><br><span class="line">str.<span class="built_in">push</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">str.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt;str.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题库-8-栈的压入、弹出序列"><a href="#题库-8-栈的压入、弹出序列" class="headerlink" title="题库 8 栈的压入、弹出序列"></a><strong>题库 8 栈的压入、弹出序列</strong></h2><p>对输入的两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p><ol><li>栈中数据的数量≤1000<br>\2. push 的所有数字均不相同</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">bool isPopOrderPossible(const vector&lt;int&gt;&amp; pushOrder, const vector&lt;int&gt;&amp; popOrder) &#123;</span><br><span class="line">    stack&lt;int&gt; stack;//辅助栈</span><br><span class="line">    int pushIndex = 0;//初始化了一个指针pushIndex，用于遍历压入序列。</span><br><span class="line">    //循环来遍历弹出序列中的每个元素</span><br><span class="line">    for (int popIndex = 0; popIndex &lt; popOrder.size(); ++popIndex) &#123;</span><br><span class="line">        while (stack.empty() || stack.top() != popOrder[popIndex]) &#123;</span><br><span class="line">            if (pushIndex == pushOrder.size()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(pushOrder[pushIndex]);</span><br><span class="line">            ++pushIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return stack.empty() &amp;&amp; pushIndex == pushOrder.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; pushOrder;</span><br><span class="line">    vector&lt;int&gt; popOrder;//压入序列和弹出序列</span><br><span class="line">    int num ;</span><br><span class="line">    while (cin &gt;&gt; num &amp;&amp; num != -1) &#123;</span><br><span class="line">        pushOrder.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输入栈的弹出顺序</span><br><span class="line">    while (cin &gt;&gt; num &amp;&amp; num != -1) &#123;</span><br><span class="line">        popOrder.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; boolalpha;  // Print &quot;true&quot; or &quot;false&quot; instead of &quot;1&quot; or &quot;0&quot;</span><br><span class="line">   cout  &lt;&lt; isPopOrderPossible(pushOrder, popOrder) &lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>判断第二个序列是否可能为该栈的弹出顺序的原理基于以下观察：</p><ol><li><p>对于一个元素进栈后，它只能出栈一次。</p></li><li><p>如果一个元素出栈，那么它之前所有比它先进栈的元素都应该已经出栈了。</p></li><li><p>首先，我们定义了一个<code>isPopOrderPossible</code>函数，该函数接受两个参数：<code>pushOrder</code>和<code>popOrder</code>，分别表示压入序列和弹出序列。</p></li><li><p>在函数内部，我们创建了一个辅助栈<code>stack</code>，用于模拟栈的压入和弹出操作。同时，我们初始化了一个指针<code>pushIndex</code>，用于遍历压入序列。</p></li><li><p>接下来，我们使用一个循环来遍历弹出序列中的每个元素。</p></li><li><p>在循环中，我们首先检查辅助栈是否为空或栈顶元素是否与当前弹出元素相等。如果不相等，则说明该元素要么还未进栈，要么已经出栈但不在栈顶。此时，我们需要将压入序列中的元素进栈，直到找到与当前弹出元素相等的元素为止，或者压入序列中的所有元素都进栈了。</p></li><li><p>如果压入序列的指针<code>pushIndex</code>已经遍历完所有元素，但栈顶元素仍然不等于当前弹出元素，说明无法找到与当前弹出元素相等的元素，即第二个序列不可能是该栈的弹出序列。因此，我们返回<code>false</code>。</p></li><li><p>如果栈顶元素等于当前弹出元素，我们将栈顶元素出栈，并移动弹出序列的指针。</p></li><li><p>循环结束后，我们需要检查辅助栈是否为空且压入序列的指针是否已经遍历完所有元素。如果这两个条件都满足，说明第二个序列可能是该栈的弹出序列，我们返回<code>true</code>；否则，返回<code>false</code>。</p></li></ol><h2 id="题库9-最长有效括号"><a href="#题库9-最长有效括号" class="headerlink" title="题库9  最长有效括号"></a>题库9  最长有效括号</h2><p>给你一个只包含 ‘(’ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度</p><h3 id="第一种-不用栈，用count表示左括号"><a href="#第一种-不用栈，用count表示左括号" class="headerlink" title="第一种  不用栈，用count表示左括号"></a>第一种  不用栈，用count表示左括号</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> longest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">                len += <span class="number">2</span>;</span><br><span class="line">                longest = <span class="built_in">max</span>(longest, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遇到右括号且没有与之匹配的左括号，重新开始计算长度</span></span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">longestValidParentheses</span>(str);</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="第二种用栈"><a href="#第二种用栈" class="headerlink" title="第二种用栈"></a>第二种用栈</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string str;</span><br><span class="line">getline(cin, str);</span><br><span class="line">stack&lt;char&gt;strstack;</span><br><span class="line">int num = 0;</span><br><span class="line">char a;</span><br><span class="line">int len = 0;</span><br><span class="line">while (num &lt; str.size())</span><br><span class="line">&#123;</span><br><span class="line">a = str[num];</span><br><span class="line">if (a == &#x27;(&#x27;)</span><br><span class="line">&#123;</span><br><span class="line">strstack.push(a);</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">/*if (strstack.empty() &amp;&amp; a == &#x27;)&#x27;)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;*/</span><br><span class="line">if (!strstack.empty())</span><br><span class="line">&#123;</span><br><span class="line">if (strstack.top() == &#x27;(&#x27; &amp;&amp; a == &#x27;)&#x27;)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">strstack.pop();</span><br><span class="line">num++;</span><br><span class="line">len += 2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题库-11-找出游戏胜利者"><a href="#题库-11-找出游戏胜利者" class="headerlink" title="题库 11  找出游戏胜利者"></a>题库 11  找出游戏胜利者</h2><p>共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 &lt;&#x3D; i &lt; n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。<br>游戏遵循如下规则：</p><ul><li>从第 1 名小伙伴所在位置 开始 。</li><li>沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li><li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li><li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行</li><li>否则，圈子中最后一名小伙伴赢得游戏。</li></ul><p>给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int findTheWinner(int n, int k) &#123;</span><br><span class="line">    std::queue&lt;int&gt; circle;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        circle.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (circle.size() &gt; 1) &#123;</span><br><span class="line">        for (int i = 1; i &lt; k; ++i) &#123;</span><br><span class="line">            circle.push(circle.front());</span><br><span class="line">            circle.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        // 将被淘汰的人移出队列</span><br><span class="line">        circle.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return circle.front();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    int k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    int winner = findTheWinner(n, k);</span><br><span class="line">    cout &lt;&lt; winner &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 &lt;&#x3D; i &lt; n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。<br>游戏遵循如下规则：</p><ul><li>从第 1 名小伙伴所在位置 开始 。</li><li>沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li><li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li><li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行</li><li>否则，圈子中最后一名小伙伴赢得游戏。</li></ul><p>给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。</p><h1 id="作业题库-数组和串"><a href="#作业题库-数组和串" class="headerlink" title="作业题库 数组和串"></a>作业题库 数组和串</h1><h2 id="1-数组与串-小鱼比可爱"><a href="#1-数组与串-小鱼比可爱" class="headerlink" title="1.数组与串-小鱼比可爱"></a>1.<strong>数组与串-小鱼比可爱</strong></h2><p>人比人，气死人；鱼比鱼，难死鱼。小鱼最近参加了一个“比可爱”比赛，比的是每只鱼的可爱程度。参赛的鱼被从左到右排成一排，头都朝向左边，然后每只鱼会得到一个整数数值，表示这只鱼的可爱程度，很显然整数越大，表示这只鱼越可爱，而且任意两只鱼的可爱程度可能一样。由于所有的鱼头都朝向左边，所以每只鱼只能看见在它左边的鱼的可爱程度，它们心里都在计算，在自己的眼力范围内有多少只鱼不如自己可爱呢。请你帮这些可爱但是鱼脑不够用的小鱼们计算一下。</p><p>输入：<br>6<br>4 3 0 5 1 2<br>输出：<br>0 0 0 3 1 2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n = 0;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">int arr[1000];</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">&#125;</span><br><span class="line">int number[1000];</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">int num = 0;//记录有几个可爱</span><br><span class="line">for (int j = i; j &gt;= 0; j--)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[i] &gt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">number[i] = num;</span><br><span class="line">&#125;</span><br><span class="line">for (int k = 0; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; number[k]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-数组与串-杨辉三角"><a href="#2-数组与串-杨辉三角" class="headerlink" title="2.数组与串-杨辉三角"></a>2.数组与串-杨辉三角</h2><p>给出 n(n≤20)，输出杨辉三角的前 n 行。<br>如果你不知道什么是杨辉三角，可以观察样例找找规律。</p><p>输入: 6<br>输出:<br>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br>1 5 10 10 5 1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string yanghui(int numRows) &#123;</span><br><span class="line">   string result;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; numRows; i++) &#123;</span><br><span class="line">        int num = 1;</span><br><span class="line">        for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">            result += to_string(num) + &quot; &quot;;</span><br><span class="line">            num = num * (i - j) / (j + 1);//为了打印后续重复的</span><br><span class="line">        &#125;</span><br><span class="line">        result += &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int numRows;</span><br><span class="line">    cin &gt;&gt; numRows;</span><br><span class="line">    string str = yanghui(numRows);</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>string 用to_string将数字转变为字符</p><h2 id="3-数组与串-冰雹猜想"><a href="#3-数组与串-冰雹猜想" class="headerlink" title="3.数组与串-冰雹猜想"></a><strong>3.数组与串-冰雹猜想</strong></h2><p>给出一个正整数 n，然后对这个数字一直进行下面的操作：如果这个数字是奇数，那么将其乘 3 再加 1，否则除以 2。经过若干次循环后，最终都会回到 1。经过验证很大的数字（7*10^{11}）都可以按照这样的方式比变成 1，所以被称为“冰雹猜想”。例如当 n 是 2020，变化的过程是20→10→5→16→8→4→2→1。</p><p>输入描述</p><p>输入一个正整数 n。</p><p>输出描述</p><p>输出若干个由空格隔开的正整数，表示从最后的 1 开始倒序的变化数列。</p><p>输入输出样例</p><p>输入：20<br>输出：1 2 4 8 16 5 10 20</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int num = 0;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line">int arr[1000];</span><br><span class="line">arr[0] = num;</span><br><span class="line">int size = 1;</span><br><span class="line">while (num != 1)</span><br><span class="line">&#123;</span><br><span class="line">if (num % 2 != 0)</span><br><span class="line">&#123;</span><br><span class="line">num = num * 3 + 1;</span><br><span class="line">arr[size] = num;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">num = num / 2;</span><br><span class="line">arr[size] = num;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = size - 1; i &gt;= 0; i--)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-数组与串-液晶屏"><a href="#5-数组与串-液晶屏" class="headerlink" title="5.数组与串-液晶屏"></a>5.<strong>数组与串-液晶屏</strong></h2><p>液晶屏上，每个阿拉伯数字都是可以显示成 3×5 的点阵的（其中 X 表示亮点，. 表示暗点）。现在给出数字位数（不超过 100）和一串数字，要求输出这些数字在显示屏上的效果。数字的显示方式如同样例输出，注意每个数字之间都有一列间隔。</p><p>输入描述</p><p>第一行输入一个正整数 n，表示数字的位数。<br>第二行输入一个长度为 n 的自然数</p><p>输出描述</p><p>输出五行，表示显示屏上的数字。<br>有些同学反应看不懂，这里观察一下就知道了<br>每个数字是一个3×5的矩阵<br>每个数字之间用一个1×5的.相隔<br>这里输出有点显示字符占位不一样，导致显示问题。<br>这里我添加一张图片方便大家观察</p><p><img src="http://acm.scu.edu.cn/teach/data/problem/1550/image.png" alt="none"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define MAXSIZE 101</span><br><span class="line">const char digits[10][5][4] = &#123;</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;XXX&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X  &quot;,</span><br><span class="line">&quot;XXX&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;XXX&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X  &quot;,</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;XXX&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X  &quot;,</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;XXX&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;  X&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;XXX&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;X X&quot;,</span><br><span class="line">&quot;XXX&quot;,</span><br><span class="line">&quot;  X&quot;,</span><br><span class="line">&quot;XXX&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n = 0;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">char str[MAXSIZE];</span><br><span class="line">scanf(&quot;%s&quot;, str);</span><br><span class="line">int row, col;</span><br><span class="line">for (row = 0; row &lt; 5; row++) &#123;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">int digit = str[i] - &#x27;0&#x27;; // 将字符数字转换为整数</span><br><span class="line">for (col = 0; col &lt; 3; col++) &#123;</span><br><span class="line">if (digits[digit][row][col] == &#x27;X&#x27;) &#123;</span><br><span class="line">printf(&quot;X&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">printf(&quot;.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (i &lt; n - 1) &#123;</span><br><span class="line">printf(&quot;.&quot;); // 数字之间用点隔开</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义三维数组，</p><h2 id="6-n皇后问题"><a href="#6-n皇后问题" class="headerlink" title="6.n皇后问题"></a>6.n皇后问题</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>题目难度 LeetCode+简单</p><p>输入一个数组</p><p>输出描述</p><p>输出方案总数</p><p>输入输出样例</p><p>输入：n &#x3D; 4<br>输出：2</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n,string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;<span class="comment">//创建棋盘</span></span><br><span class="line">        <span class="built_in">solveNQueens</span>(board, <span class="number">0</span>, count);<span class="comment">//核心函数,回溯皇后</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveNQueens</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span>&amp; count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; board.<span class="built_in">size</span>(); col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isSafe</span>(board, row, col)) &#123;</span><br><span class="line">                board[row][col] = <span class="string">&#x27;Q&#x27;</span>;<span class="comment">//是安全的，就可以放皇后</span></span><br><span class="line">                <span class="built_in">solveNQueens</span>(board, row + <span class="number">1</span>, count);<span class="comment">//检查下一行</span></span><br><span class="line">                board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSafe</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;<span class="comment">//判断是不是有没有皇后，是不是安全的</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左上是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row, j = col; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查右上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row, j = col; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; board.<span class="built_in">size</span>(); i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n ;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="type">int</span> result = solution.<span class="built_in">totalNQueens</span>(n);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSafe</span><span class="params">(<span class="type">int</span> board[], <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the column</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i] == col || <span class="built_in">abs</span>(board[i] - col) == <span class="built_in">abs</span>(i - row)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> board[], <span class="type">int</span> row, <span class="type">int</span> n, <span class="type">int</span> *count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        (*count)++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSafe(board, row, col, n)) &#123;</span><br><span class="line">            board[row] = col;</span><br><span class="line">            solveNQueens(board, row + <span class="number">1</span>, n, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> board[n];</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    solveNQueens(board, <span class="number">0</span>, n, &amp;count);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> result = totalNQueens(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作业题库：二叉树"><a href="#作业题库：二叉树" class="headerlink" title="作业题库：二叉树"></a>作业题库：二叉树</h2><h3 id="1-相同的树"><a href="#1-相同的树" class="headerlink" title="1.相同的树"></a>1.<strong>相同的树</strong></h3><p><img src="http://acm.scu.edu.cn/teach/data/problem/1562/11.png" alt="11.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char arr1[10000];</span><br><span class="line">char arr2[10000];</span><br><span class="line">char s=1;</span><br><span class="line">char t = 1;</span><br><span class="line">int num1=0;</span><br><span class="line">    int num2=0;</span><br><span class="line">string str1, str2;</span><br><span class="line">getline(cin, str1);</span><br><span class="line">getline(cin, str2);</span><br><span class="line">if (str1 == str2)</span><br><span class="line">cout &lt;&lt; &quot;true&quot;;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;false&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接比较字符串是否相同</p><h3 id="2-二叉树的中序遍历"><a href="#2-二叉树的中序遍历" class="headerlink" title="2.二叉树的中序遍历**"></a>2.二叉树的中序遍历**</h3><p>给你一个二叉树的根节点root，检查它是否轴对称。</p><p>输入描述<br>一个节点序列</p><p>输出描述<br>真假</p><p>输入输出样例</p><p>输入<br>1,2,3,4，null</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line">TreeNode* createTree(char* input) &#123;</span><br><span class="line">    if (strcmp(input, &quot;null&quot;) == 0) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size = 1;</span><br><span class="line">    for (int i = 0; i &lt; strlen(input); i++) &#123;</span><br><span class="line">        if (input[i] == &#x27;,&#x27;) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode** queue = new TreeNode * [size];</span><br><span class="line">    int front = 0, rear = 0;</span><br><span class="line">    TreeNode* root = new TreeNode;</span><br><span class="line">    root-&gt;val = atoi(strtok(input, &quot;,&quot;));</span><br><span class="line">    root-&gt;left = root-&gt;right = NULL;</span><br><span class="line">    queue[rear++] = root;</span><br><span class="line"></span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; size) &#123;</span><br><span class="line">        TreeNode* node = queue[front++];</span><br><span class="line">        char* in = strtok(NULL, &quot;,&quot;);</span><br><span class="line"></span><br><span class="line">        if (strcmp(in, &quot;null&quot;) != 0) &#123;</span><br><span class="line">            node-&gt;left = new TreeNode;</span><br><span class="line">            node-&gt;left-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;left-&gt;left = node-&gt;left-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        in = strtok(NULL, &quot;,&quot;);</span><br><span class="line">        if (i &lt; size &amp;&amp; strcmp(in, &quot;null&quot;) != 0) &#123;</span><br><span class="line">            node-&gt;right = new TreeNode;</span><br><span class="line">            node-&gt;right-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;right-&gt;left = node-&gt;right-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归翻转左右子树</span><br><span class="line">    TreeNode* temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;right = invertTree(temp);</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">string levelOrderTraversal(TreeNode* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string result;</span><br><span class="line">    queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">    nodeQueue.push(root);</span><br><span class="line">    result += to_string(root-&gt;val) + &quot;,&quot;;</span><br><span class="line">    while (!nodeQueue.empty()) &#123;</span><br><span class="line">        TreeNode* node = nodeQueue.front();</span><br><span class="line">        nodeQueue.pop();</span><br><span class="line"></span><br><span class="line">        if (node-&gt;left != NULL) &#123;</span><br><span class="line">            nodeQueue.push(node-&gt;left);</span><br><span class="line">            result += to_string(node-&gt;left-&gt;val) + &quot;,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (node-&gt;right) result += &quot;null,&quot;;</span><br><span class="line">        else &#123;</span><br><span class="line">            result += &quot;null,&quot;;</span><br><span class="line">            result += &quot;null,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node-&gt;right != NULL) &#123;</span><br><span class="line">            nodeQueue.push(node-&gt;right);</span><br><span class="line">            result += to_string(node-&gt;right-&gt;val) + &quot;,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (node-&gt;left) result += &quot;null,&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!result.empty()) &#123;</span><br><span class="line">        result.pop_back();  // 去除最后一个逗号</span><br><span class="line">    &#125;</span><br><span class="line">    while (result[result.size() - 1] == &#x27;l&#x27;) &#123;</span><br><span class="line">        result.pop_back();</span><br><span class="line">        result.pop_back();</span><br><span class="line">        result.pop_back();</span><br><span class="line">        result.pop_back();</span><br><span class="line">        result.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char input[256];</span><br><span class="line">    cin.getline(input, sizeof(input));</span><br><span class="line">    int num = strlen(input);</span><br><span class="line">    TreeNode* root = createTree(input);</span><br><span class="line">    TreeNode* invertedRoot = invertTree(root);</span><br><span class="line">    string output;</span><br><span class="line">    output=  levelOrderTraversal(invertedRoot);</span><br><span class="line">    cout &lt;&lt; output;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-翻转二叉树"><a href="#3-翻转二叉树" class="headerlink" title="3.翻转二叉树"></a>3.翻转二叉树</h3><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><p><strong>输入描述：</strong><br>一个节点序列</p><p><strong>输出描述：</strong><br>返回其根节点序列</p><p><strong>样例</strong></p><p>输入<br>root &#x3D; [4,2,7,1,3,6,9]<br>输出</p><p>[4,7,2,9,6,3,1]</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归翻转左右子树</span><br><span class="line">    TreeNode* temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;right = invertTree(temp);</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-左叶子之和"><a href="#4-左叶子之和" class="headerlink" title="4.左叶子之和"></a>4.<strong>左叶子之和</strong></h3><p><strong>题目描述</strong><br>给定二叉树的根节点 root ，返回所有左叶子之和。</p><p><strong>输入描述</strong><br>一个节点序列<br><strong>输出描述</strong><br>返回其左叶子之和</p><p><strong>输入输出样例</strong></p><p>输入<br>root &#x3D; [3,9,20,null,null,15,7]<br>输出<br>24<br>输入<br>root &#x3D; [1]<br>输出<br>0</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">     </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建二叉树的函数</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">createTree</span><span class="params">(<span class="type">char</span>* input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, <span class="string">&quot;null&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(input); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode** queue = <span class="keyword">new</span> TreeNode * [size];</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    root-&gt;val = <span class="built_in">atoi</span>(<span class="built_in">strtok</span>(input, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    queue[rear++] = root;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; size) &#123;</span><br><span class="line">        TreeNode* node = queue[front++];</span><br><span class="line">        <span class="type">char</span>* in = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(in, <span class="string">&quot;null&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            node-&gt;left = <span class="keyword">new</span> TreeNode;</span><br><span class="line">            node-&gt;left-&gt;val = <span class="built_in">atoi</span>(in);</span><br><span class="line">            node-&gt;left-&gt;left = node-&gt;left-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">            queue[rear++] = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        in = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; size &amp;&amp; <span class="built_in">strcmp</span>(in, <span class="string">&quot;null&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            node-&gt;right = <span class="keyword">new</span> TreeNode;</span><br><span class="line">            node-&gt;right-&gt;val = <span class="built_in">atoi</span>(in);</span><br><span class="line">            node-&gt;right-&gt;left = node-&gt;right-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">            queue[rear++] = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算左叶子之和的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子树是叶子节点，累加其值</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sum += root-&gt;left-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算左右子树的左叶子之和</span></span><br><span class="line">    sum += <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);</span><br><span class="line">    sum += <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">256</span>];</span><br><span class="line">    cin.<span class="built_in">getline</span>(input, <span class="built_in">sizeof</span>(input));</span><br><span class="line">    TreeNode* root = <span class="built_in">createTree</span>(input);</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sumOfLeftLeaves</span>(root);</span><br><span class="line">    cout  &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-二叉树最近的公共祖先"><a href="#5-二叉树最近的公共祖先" class="headerlink" title="5.二叉树最近的公共祖先"></a>5.二叉树最近的公共祖先</h3><p><strong>题目描述</strong><br>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>（一个节点也可以是它自己的祖先）。</p><p><strong>输入描述</strong><br>给一个二叉树<br><strong>输出描述</strong><br>输出它的最近公共近邻</p><p><strong>输入输出样例</strong><br>输入<br>root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出<br>3</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义二叉树节点</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">   // TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//创建二叉树的函数</span><br><span class="line">TreeNode* createTree(char* input) &#123;</span><br><span class="line">    if (strcmp(input, &quot;null&quot;) == 0) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size = 1;</span><br><span class="line">    for (int i = 0; i &lt; strlen(input); i++) &#123;</span><br><span class="line">        if (input[i] == &#x27;,&#x27;) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode** queue = new TreeNode * [size];</span><br><span class="line">    int front = 0, rear = 0;</span><br><span class="line">    TreeNode* root = new TreeNode;</span><br><span class="line">    root-&gt;val = atoi(strtok(input, &quot;,&quot;));</span><br><span class="line">    root-&gt;left = root-&gt;right = NULL;</span><br><span class="line">    queue[rear++] = root;</span><br><span class="line"></span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; size) &#123;</span><br><span class="line">        TreeNode* node = queue[front++];</span><br><span class="line">        char* in = strtok(NULL, &quot;,&quot;);</span><br><span class="line"></span><br><span class="line">        if (strcmp(in, &quot;null&quot;) != 0) &#123;</span><br><span class="line">            node-&gt;left = new TreeNode;</span><br><span class="line">            node-&gt;left-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;left-&gt;left = node-&gt;left-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        in = strtok(NULL, &quot;,&quot;);</span><br><span class="line">        if (i &lt; size &amp;&amp; strcmp(in, &quot;null&quot;) != 0) &#123;</span><br><span class="line">            node-&gt;right = new TreeNode;</span><br><span class="line">            node-&gt;right-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;right-&gt;left = node-&gt;right-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">    // 如果当前节点为空，或者是 p 或 q 中的一个，直接返回当前节点</span><br><span class="line">    if (root == nullptr || root == p || root == q) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归查找左子树中是否包含 p 或 q</span><br><span class="line">    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line"></span><br><span class="line">    // 递归查找右子树中是否包含 p 或 q</span><br><span class="line">    TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">    // 如果左右子树分别包含 p 和 q，则当前节点就是最近公共祖先</span><br><span class="line">    if (left &amp;&amp; right) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 否则，返回左子树或右子树中包含 p 或 q 的节点（或者返回nullptr）</span><br><span class="line">    return left ? left : right;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* findNodeWithValue(TreeNode* root, int value) &#123;</span><br><span class="line">    // 如果当前节点为空，或者找到了节点值为目标值，直接返回当前节点</span><br><span class="line">    if (root == nullptr || root-&gt;val == value) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归查找左子树</span><br><span class="line">    TreeNode* leftResult = findNodeWithValue(root-&gt;left, value);</span><br><span class="line"></span><br><span class="line">    // 如果在左子树中找到了目标节点，直接返回结果</span><br><span class="line">    if (leftResult != nullptr) &#123;</span><br><span class="line">        return leftResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 否则，递归查找右子树</span><br><span class="line">    return findNodeWithValue(root-&gt;right, value);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    // 在这里你需要提供输入二叉树的方式，创建二叉树，然后调用 lowestCommonAncestor 函数进行测试</span><br><span class="line">    // 示例：</span><br><span class="line">    char input[256];</span><br><span class="line">        cin.getline(input, sizeof(input));</span><br><span class="line">        TreeNode* root = createTree(input);</span><br><span class="line">        int p0, p1;</span><br><span class="line">        cin &gt;&gt; p0 &gt;&gt; p1;</span><br><span class="line">    // TreeNode* root = createTree(&quot;3,5,1,6,2,0,8,null,null,7,4&quot;);</span><br><span class="line">       TreeNode* p = findNodeWithValue(root, p0);</span><br><span class="line">       TreeNode* q = findNodeWithValue(root, p1);</span><br><span class="line">       TreeNode* result = lowestCommonAncestor(root, p, q);</span><br><span class="line">       cout &lt;&lt;result-&gt;val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-恢复二叉搜索树"><a href="#6-恢复二叉搜索树" class="headerlink" title="6.恢复二叉搜索树"></a>6.恢复二叉搜索树</h3><p><strong>题目描述</strong><br>给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。</p><p><strong>输入描述</strong><br>给一个二叉树<br><strong>输出描述</strong><br>恢复这棵树</p><p><strong>输入输出样例</strong><br>输入<br>root &#x3D; [1,3,null,null,2]<br>输出<br>[3,1,null,null,2]</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">   // TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">TreeNode* createTree(char* input) &#123;</span><br><span class="line">    if (strcmp(input, &quot;null&quot;) == 0) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size = 1;</span><br><span class="line">    for (int i = 0; i &lt; strlen(input); i++) &#123;</span><br><span class="line">        if (input[i] == &#x27;,&#x27;) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode** queue = new TreeNode * [size];</span><br><span class="line">    int front = 0, rear = 0;</span><br><span class="line">    TreeNode* root = new TreeNode;</span><br><span class="line">    root-&gt;val = atoi(strtok(input, &quot;,&quot;));</span><br><span class="line">    root-&gt;left = root-&gt;right = NULL;</span><br><span class="line">    queue[rear++] = root;</span><br><span class="line"></span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; size) &#123;</span><br><span class="line">        TreeNode* node = queue[front++];</span><br><span class="line">        char* in = strtok(NULL, &quot;,&quot;);</span><br><span class="line"></span><br><span class="line">        if (strcmp(in, &quot;null&quot;) != 0) &#123;</span><br><span class="line">            node-&gt;left = new TreeNode;</span><br><span class="line">            node-&gt;left-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;left-&gt;left = node-&gt;left-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        in = strtok(NULL, &quot;,&quot;);</span><br><span class="line">        if (i &lt; size &amp;&amp; strcmp(in, &quot;null&quot;) != 0) &#123;</span><br><span class="line">            node-&gt;right = new TreeNode;</span><br><span class="line">            node-&gt;right-&gt;val = atoi(in);</span><br><span class="line">            node-&gt;right-&gt;left = node-&gt;right-&gt;right = NULL;</span><br><span class="line">            queue[rear++] = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">void inorder(TreeNode* root, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if (root == nullptr) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root-&gt;left, nums);</span><br><span class="line">    nums.push_back(root-&gt;val);</span><br><span class="line">    inorder(root-&gt;right, nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;int, int&gt; findTwoSwapped(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    int index1 = -1, index2 = -1;</span><br><span class="line">    for (int i = 0; i &lt; n - 1; ++i) &#123;</span><br><span class="line">        if (nums[i + 1] &lt; nums[i]) &#123;</span><br><span class="line">            index2 = i + 1;</span><br><span class="line">            if (index1 == -1) &#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int x = nums[index1], y = nums[index2];</span><br><span class="line">    return &#123; x, y &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void recover(TreeNode* r, int count, int x, int y) &#123;</span><br><span class="line">    if (r != nullptr) &#123;</span><br><span class="line">        if (r-&gt;val == x || r-&gt;val == y) &#123;</span><br><span class="line">            r-&gt;val = r-&gt;val == x ? y : x;</span><br><span class="line">            if (--count == 0) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        recover(r-&gt;left, count, x, y);</span><br><span class="line">        recover(r-&gt;right, count, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void recoverTree(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    inorder(root, nums);</span><br><span class="line">    pair&lt;int, int&gt; swapped = findTwoSwapped(nums);</span><br><span class="line">    recover(root, 2, swapped.first, swapped.second);</span><br><span class="line">&#125;</span><br><span class="line">string levelOrderTraversal(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        string result;</span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        result += to_string(root-&gt;val) + &quot;,&quot;;</span><br><span class="line">        while (!nodeQueue.empty()) &#123;</span><br><span class="line">            TreeNode* node = nodeQueue.front();</span><br><span class="line">            nodeQueue.pop();</span><br><span class="line">    </span><br><span class="line">            if (node-&gt;left != NULL) &#123;</span><br><span class="line">                nodeQueue.push(node-&gt;left);</span><br><span class="line">                result += to_string(node-&gt;left-&gt;val) + &quot;,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (node-&gt;right) result += &quot;null,&quot;;</span><br><span class="line">            else &#123;</span><br><span class="line">                result += &quot;null,&quot;;</span><br><span class="line">                result += &quot;null,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;right != NULL) &#123;</span><br><span class="line">                nodeQueue.push(node-&gt;right);</span><br><span class="line">                result += to_string(node-&gt;right-&gt;val) + &quot;,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (node-&gt;left) result += &quot;null,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        if (!result.empty()) &#123;</span><br><span class="line">            result.pop_back();  // 去除最后一个逗号</span><br><span class="line">        &#125;</span><br><span class="line">        while (result[result.size() - 1] == &#x27;l&#x27;) &#123;</span><br><span class="line">            result.pop_back();</span><br><span class="line">            result.pop_back();</span><br><span class="line">            result.pop_back();</span><br><span class="line">            result.pop_back();</span><br><span class="line">            result.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">char input[256];</span><br><span class="line">cin.getline(input, sizeof(input));</span><br><span class="line">TreeNode* root = createTree(input);</span><br><span class="line">    recoverTree(root);</span><br><span class="line">    string output = levelOrderTraversal(root);</span><br><span class="line">    cout &lt;&lt; output;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-奇偶树"><a href="#7-奇偶树" class="headerlink" title="7.奇偶树"></a>7.奇偶树</h3><p>如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：<br>二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。<br>偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增<br>奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减<br>给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。</p><p><strong>输入描述</strong><br>给一个二叉树<br><strong>输出描述</strong><br>判断是否是奇偶树</p><p><strong>输入输出样例</strong><br>输入<br>root &#x3D; [1,10,4,3,null,7,9,12,8,6,null,null,2]<br>输出<br>true</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isEvenOddTree(TreeNode* root) &#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; qu;</span><br><span class="line">    qu.push(root);</span><br><span class="line">    int level = 0;</span><br><span class="line">    while (!qu.empty()) &#123;</span><br><span class="line">        int size = qu.size();</span><br><span class="line">        int prev = level % 2 == 0 ? INT_MIN : INT_MAX;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode* node = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            int value = node-&gt;val;</span><br><span class="line">            if (level % 2 == value % 2) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((level % 2 == 0 &amp;&amp; value &lt;= prev) || (level % 2 == 1 &amp;&amp; value &gt;= prev)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = value;</span><br><span class="line">            if (node-&gt;left != nullptr) &#123;</span><br><span class="line">                qu.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;right != nullptr) &#123;</span><br><span class="line">                qu.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-二叉树的子树大小"><a href="#8-二叉树的子树大小" class="headerlink" title="8.二叉树的子树大小"></a>8.二叉树的子树大小</h3><p>描述</p><p>现在给出一棵二叉树，希望你输出它的每一个结点为根的子树大小</p><p>输入</p><p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。<br>接下来 n 行，每行两个正整数 li, ri ​ ，分别表示节点 i 的左右孩子的编号。如果不存在左 &#x2F; 右孩子，则以 −1 表示。两个数之间用一个空格隔开。</p><p>输出</p><p>一行，n个数，分别表示i号结点为根的子树的子树大小</p><p>样例</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">-1 -1</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> leftChild;</span><br><span class="line">    <span class="type">int</span> rightChild;</span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归计算以指定节点为根的子树大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">calculateSubtreeSize</span><span class="params">(TreeNode tree[], <span class="type">int</span> node)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果节点为空，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算左右子树大小</span></span><br><span class="line">    <span class="type">int</span> leftSize = calculateSubtreeSize(tree, tree[node].leftChild);</span><br><span class="line">    <span class="type">int</span> rightSize = calculateSubtreeSize(tree, tree[node].rightChild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以当前节点为根的子树大小（包括当前节点）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + leftSize + rightSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建二叉树节点数组</span></span><br><span class="line">    TreeNode* tree = (TreeNode*)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取每个节点的左右孩子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;tree[i].leftChild, &amp;tree[i].rightChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并输出每个节点为根的子树大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> subtreeSize = calculateSubtreeSize(tree, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, subtreeSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-二叉树的子树和"><a href="#9-二叉树的子树和" class="headerlink" title="9.二叉树的子树和"></a>9.二叉树的子树和</h3><p>现在给出一棵二叉树，每个结点有一个权值，希望你依次输出每一个节点为根的子树的子树权值和</p><p>输入</p><p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。<br>第二行 n 个正整数，用一个空格分隔，第 i 个正整数vi，代表节点 i 的权值。<br>接下来 n 行，每行两个正整数 li, ri ​ ，分别表示节点 i 的左右孩子的编号。如果不存在左 &#x2F; 右孩子，则以 −1 表示。两个数之间用一个空格隔开。</p><p>输出</p><p>一行，n个数，分别表示i号结点为根的子树的子树权值和</p><p>样例</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1000 1000</span><br><span class="line">2 3</span><br><span class="line">-1 -1</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2001 1000 1000</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> leftChild;</span><br><span class="line">    <span class="type">int</span> rightChild;</span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归计算以指定节点为根的子树权值和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">calculateSubtreeSum</span><span class="params">(TreeNode tree[], <span class="type">int</span> node, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果节点为空，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="number">-1</span> || node &gt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算左右子树权值和</span></span><br><span class="line">    <span class="type">int</span> leftSum = calculateSubtreeSum(tree, tree[node].leftChild, n);</span><br><span class="line">    <span class="type">int</span> rightSum = calculateSubtreeSum(tree, tree[node].rightChild, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以当前节点为根的子树权值和（包括当前节点）</span></span><br><span class="line">    <span class="keyword">return</span> tree[node].value + leftSum + rightSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建二叉树节点数组</span></span><br><span class="line">    TreeNode* tree = (TreeNode*)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取每个节点的权值和左右孩子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tree[i].value);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;tree[i].leftChild, &amp;tree[i].rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算并输出每个节点为根的子树权值和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> subtreeSum = calculateSubtreeSum(tree, i, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, subtreeSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-确定树的形态"><a href="#10-确定树的形态" class="headerlink" title="10.确定树的形态"></a>10.确定树的形态</h3><p>现在给出一棵二叉树的前序遍历和后序遍历，输出树的后序遍历</p><p>输入</p><p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。<br>第二行 n 个正整数，用一个空格分隔，代表二叉树的前序遍历<br>第三行 n 个正整数，用一个空格分隔，代表二叉树的中序遍历</p><p>输出</p><p>一行，n个数，用一个空格分隔，表示二叉树的后序遍历</p><p>样例</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3 </span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 1</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据前序遍历和中序遍历构建二叉树</span></span><br><span class="line">TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span> pre[], <span class="type">int</span> in[], <span class="type">int</span> startPre, <span class="type">int</span> endPre, <span class="type">int</span> startIn, <span class="type">int</span> endIn)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (startPre &gt; endPre || startIn &gt; endIn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建根节点</span></span><br><span class="line">    TreeNode* root = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    root-&gt;data = pre[startPre];</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在中序遍历中找到根节点的位置</span></span><br><span class="line">    <span class="type">int</span> rootIndex;</span><br><span class="line">    <span class="keyword">for</span> (rootIndex = startIn; rootIndex &lt;= endIn; rootIndex++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[rootIndex] == pre[startPre]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> leftSize = rootIndex - startIn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归构建左子树和右子树</span></span><br><span class="line">    root-&gt;left = buildTree(pre, in, startPre + <span class="number">1</span>, startPre + leftSize, startIn, rootIndex - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = buildTree(pre, in, startPre + leftSize + <span class="number">1</span>, endPre, rootIndex + <span class="number">1</span>, endIn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历输出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历左子树</span></span><br><span class="line">    postOrder(root-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历右子树</span></span><br><span class="line">    postOrder(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出根节点的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取前序遍历和中序遍历</span></span><br><span class="line">    <span class="type">int</span>* pre = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span>* in = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;in[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建二叉树</span></span><br><span class="line">    TreeNode* root = buildTree(pre, in, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出后序遍历</span></span><br><span class="line">    postOrder(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(pre);</span><br><span class="line">    <span class="built_in">free</span>(in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-哈夫曼树的带权路径长"><a href="#11-哈夫曼树的带权路径长" class="headerlink" title="11.哈夫曼树的带权路径长"></a>11.哈夫曼树的带权路径长</h3><p>现在给出一棵二叉树，每个结点有一个权值，希望你构造赫夫曼树，并输出其对应的带权路径长度</p><p>输入</p><p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n。<br>第二行 n 个正整数，用一个空格分隔，第 i 个正整数vi，代表节点 i 的权值。</p><p>输出</p><p>一个数，表示对应赫夫曼树的带权路径长度</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义二叉树节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* left;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新的节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">createNode</span>(<span class="type">int</span> weight)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* node = (<span class="keyword">struct</span> TreeNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">node-&gt;weight = weight;</span><br><span class="line">node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小堆的数据结构的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> capacity;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>** array;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建一个新的最小堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeap</span>* <span class="built_in">createMinHeap</span>(<span class="type">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeap</span>* minHeap = (<span class="keyword">struct</span> MinHeap*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> MinHeap));</span><br><span class="line">minHeap-&gt;size = <span class="number">0</span>;</span><br><span class="line">minHeap-&gt;capacity = capacity;</span><br><span class="line">minHeap-&gt;array = (<span class="keyword">struct</span> TreeNode**)<span class="built_in">malloc</span>(capacity * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode*));</span><br><span class="line"><span class="keyword">return</span> minHeap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换两个节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapNodes</span><span class="params">(<span class="keyword">struct</span> TreeNode** a, <span class="keyword">struct</span> TreeNode** b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* t = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最小堆的下沉操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">minHeapify</span><span class="params">(<span class="keyword">struct</span> MinHeap* minHeap, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> smallest = index;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; minHeap-&gt;size &amp;&amp; minHeap-&gt;array[left]-&gt;weight &lt; minHeap-&gt;array[smallest]-&gt;weight)</span><br><span class="line">        smallest = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &lt; minHeap-&gt;size &amp;&amp; minHeap-&gt;array[right]-&gt;weight &lt; minHeap-&gt;array[smallest]-&gt;weight)</span><br><span class="line">        smallest = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (smallest != index) &#123;</span><br><span class="line">        <span class="built_in">swapNodes</span>(&amp;minHeap-&gt;array[smallest], &amp;minHeap-&gt;array[index]);</span><br><span class="line">        <span class="built_in">minHeapify</span>(minHeap, smallest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为叶子节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLeaf</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(root-&gt;left) &amp;&amp; !(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建最小堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinHeap</span>* <span class="built_in">buildMinHeap</span>(<span class="type">int</span> weights[], <span class="type">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MinHeap</span>* minHeap = <span class="built_in">createMinHeap</span>(size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        minHeap-&gt;array[i] = <span class="built_in">createNode</span>(weights[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    minHeap-&gt;size = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">minHeapify</span>(minHeap, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minHeap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最小堆中提取最小值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">extractMin</span>(<span class="keyword">struct</span> MinHeap* minHeap) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* temp = minHeap-&gt;array[<span class="number">0</span>];</span><br><span class="line">    minHeap-&gt;array[<span class="number">0</span>] = minHeap-&gt;array[minHeap-&gt;size - <span class="number">1</span>];</span><br><span class="line">    --minHeap-&gt;size;</span><br><span class="line">    <span class="built_in">minHeapify</span>(minHeap, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新节点到最小堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertMinHeap</span><span class="params">(<span class="keyword">struct</span> MinHeap* minHeap, <span class="keyword">struct</span> TreeNode* node)</span> </span>&#123;</span><br><span class="line">    ++minHeap-&gt;size;</span><br><span class="line">    <span class="type">int</span> i = minHeap-&gt;size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; node-&gt;weight &lt; minHeap-&gt;array[(i - <span class="number">1</span>) / <span class="number">2</span>]-&gt;weight) &#123;</span><br><span class="line">        minHeap-&gt;array[i] = minHeap-&gt;array[(i - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minHeap-&gt;array[i] = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建赫夫曼树</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">buildHuffmanTree</span>(<span class="type">int</span> weights[], <span class="type">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* left, * right, * top;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MinHeap</span>* minHeap = <span class="built_in">buildMinHeap</span>(weights, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (minHeap-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        left = <span class="built_in">extractMin</span>(minHeap);</span><br><span class="line">        right = <span class="built_in">extractMin</span>(minHeap);</span><br><span class="line"></span><br><span class="line">        top = <span class="built_in">createNode</span>(left-&gt;weight + right-&gt;weight);</span><br><span class="line">        top-&gt;left = left;</span><br><span class="line">        top-&gt;right = right;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">insertMinHeap</span>(minHeap, top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">extractMin</span>(minHeap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算带权路径长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculateWPL</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isLeaf</span>(root))</span><br><span class="line">        <span class="keyword">return</span> root-&gt;weight * depth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">calculateWPL</span>(root-&gt;left, depth + <span class="number">1</span>) + <span class="built_in">calculateWPL</span>(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> weights[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; weights[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* root = <span class="built_in">buildHuffmanTree</span>(weights, n);</span><br><span class="line"><span class="type">int</span> wpl = <span class="built_in">calculateWPL</span>(root, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; wpl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实验 </span><br><span class="line">实验题目：排序</span><br><span class="line"></span><br><span class="line">实验目的：</span><br><span class="line">掌握各种排序方法的基本思想、排序过程、算法实现，能进行时间和空间性能的分析，根据实际问题的特点和要求选择合适的排序方法。</span><br><span class="line"></span><br><span class="line">实验要求：</span><br><span class="line">实现直接排序、冒泡、直接选择、快速、堆、归并排序算法。比较各种算法的运行速度。</span><br><span class="line"></span><br><span class="line">实验主要步骤：</span><br><span class="line"></span><br><span class="line">实验代码</span><br><span class="line"></span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define Max 100         //假设文件长度</span><br><span class="line">typedef struct &#123;         //定义记录类型</span><br><span class="line">    int key;            //关键字项</span><br><span class="line">&#125;RecType;</span><br><span class="line">typedef RecType SeqList[Max + 1]; //SeqList为顺序表，表中第0个元素作为哨兵</span><br><span class="line">int n;                 //顺序表实际的长度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//==========直接插入排序法======</span><br><span class="line">void InsertSort(SeqList R)</span><br><span class="line">&#123;       //对顺序表R中的记录R[1‥n]按递增序进行插入排序</span><br><span class="line">    int i, j;</span><br><span class="line">    for (i = 2; i &lt;= n; ++i)</span><br><span class="line">        if (R[i].key &lt; R[i - 1].key)//将L.r[i]插入有序子表</span><br><span class="line">        &#123;</span><br><span class="line">            R[0] = R[i]; // 复制为哨兵</span><br><span class="line">            R[i] = R[i - 1];</span><br><span class="line">            for (j = i - 2; R[0].key &lt; R[j].key; --j)</span><br><span class="line">                R[j + 1] = R[j]; // 记录后移 </span><br><span class="line">            R[j + 1] = R[0]; //插入到正确位置</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//==========冒泡排序======= </span><br><span class="line">typedef enum &#123; FALSE, TRUE &#125; Boolean;  //FALSE为0，TRUE为1</span><br><span class="line">void BubbleSort(SeqList R) &#123;             //自下向上扫描对R做冒泡排序</span><br><span class="line">    int i, j,num;     Boolean exchange;     //交换标志</span><br><span class="line">    for (i = 1; i &lt; n; i++) &#123;    //最多做n-1趟排序</span><br><span class="line">        exchange = FALSE;       //本趟排序开始前，交换标志应为假</span><br><span class="line">        for (j = n - 1; j &gt;= i; j--)       //对当前无序区R[i‥n] 自下向上扫描</span><br><span class="line">            if (R[j + 1].key &lt; R[j].key) &#123;    //两两比较，满足条件交换记录</span><br><span class="line">                num = R[j].key;</span><br><span class="line">                R[j].key = R[j + 1].key;</span><br><span class="line">                R[j + 1].key = num;</span><br><span class="line">                    exchange = TRUE;         //发生了交换，故将交换标志置为真</span><br><span class="line">            &#125;</span><br><span class="line">        if (!exchange)           //本趟排序未发生交换，提前终止算法</span><br><span class="line">            return;</span><br><span class="line">    &#125;//endfor（为循环）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//1.========一次划分函数=====</span><br><span class="line">int Partition(SeqList R, int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    int pivotkey = R[i].key;//   对R[i‥j]做一次划分，并返回基准记录的位置</span><br><span class="line">    RecType pivot = R[i];    //用第一个记录作为基准</span><br><span class="line">    while (i &lt; j) &#123;  </span><br><span class="line">        while (i &lt; j &amp;&amp; R[j].key &gt;= pivotkey)  --j;</span><br><span class="line">       R[i] =R[j];</span><br><span class="line">        while (i &lt; j &amp;&amp; R[i].key &lt;= pivotkey)  ++i;</span><br><span class="line">        R[j] =R[i];</span><br><span class="line">        //从区间两端交替向中间扫描，直到i=j</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    R[i] = pivot;    //此时，i=j，基准记录已被最后定位</span><br><span class="line">    return i;      //返回基准记录的位置</span><br><span class="line">&#125;</span><br><span class="line">//2.=====快速排序===========</span><br><span class="line">void QuickSort(SeqList R, int low, int high)</span><br><span class="line">&#123;                 //R[low..high]快速排序</span><br><span class="line">    int pivotpos;            //划分后基准记录的位置</span><br><span class="line">    if (low &lt; high) &#123;           //仅当区间长度大于1时才排序</span><br><span class="line">        pivotpos = Partition(R, low, high);  //对R[low..high]做一次划分，得到基准记录的位置</span><br><span class="line">        QuickSort(R, low, pivotpos - 1);       //对左区间递归排序</span><br><span class="line">        QuickSort(R, pivotpos + 1, high);      //对右区间递归排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//======直接选择排序========</span><br><span class="line">void SelectSort(SeqList R)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    for (i = 1; i &lt; n; i++) &#123;         //做第i趟排序（1≤i≤n-1）</span><br><span class="line">        k = i;</span><br><span class="line">        for (j = i + 1; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (R[j].key &lt; R[k].key)</span><br><span class="line">            &#123;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        if (k != i)</span><br><span class="line">        &#123;</span><br><span class="line">            int temp = R[i].key;</span><br><span class="line">            R[i].key = R[k].key;</span><br><span class="line">            R[k].key = temp;</span><br><span class="line"></span><br><span class="line">        &#125;//endif</span><br><span class="line">    &#125; //endfor</span><br><span class="line">&#125;</span><br><span class="line">//==========大根堆调整函数=======</span><br><span class="line">void Heapify(SeqList R, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    int i = low;</span><br><span class="line">    int j = 2 * i;</span><br><span class="line">    RecType temp = R[i];</span><br><span class="line">    while (j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        if (j &lt; high &amp;&amp; R[j].key &lt; R[j + 1].key)</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp.key &gt;= R[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        R[i] = R[j];</span><br><span class="line">        i = j;</span><br><span class="line">        j = 2 * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    R[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">//==========构造大根堆==========</span><br><span class="line">void BuildHeap(SeqList R,int n)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = n / 2; i &gt;= 1; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Heapify(R, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//==========堆排序===========</span><br><span class="line">void HeapSort(SeqList R)</span><br><span class="line">&#123;</span><br><span class="line">    BuildHeap(R,n);</span><br><span class="line">    // 依次将堆顶元素与末尾元素交换并重新调整堆</span><br><span class="line">    for (int i = n; i &gt; 1; i--) &#123;</span><br><span class="line">        swap(R[1], R[i]); // 将堆顶元素（最大值）与末尾元素交换</span><br><span class="line">        Heapify(R, 1, i - 1); // 调整堆</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//=====将两个有序的子序列R[low..m]和R[m+1..high]归并成有序的序列R[low..high]==</span><br><span class="line">void Merge(SeqList R, int low, int m, int high)</span><br><span class="line">&#123;</span><br><span class="line">    int i = low, j = m + 1, k = 0;</span><br><span class="line">    SeqList temp;</span><br><span class="line">    while (i &lt;= m &amp;&amp; j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        if (R[i].key &lt;= R[j].key) &#123;</span><br><span class="line">            temp[++k] = R[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            temp[++k] = R[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (i &lt;= m) &#123;</span><br><span class="line">        temp[++k] = R[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (j &lt;= high) &#123;</span><br><span class="line">        temp[++k] = R[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 1, j = low; i &lt;= k; ++i, ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        R[j] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//=========对R[1..n]做一趟归并排序========</span><br><span class="line">void MergePass(SeqList R, int length)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 1; i + 2 * length - 1 &lt;= n; i += 2 * length)</span><br><span class="line">    &#123;</span><br><span class="line">        Merge(R, i, i + length - 1, i + 2 * length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (i + length - 1 &lt; n) &#123;</span><br><span class="line">        Merge(R, i, i + length - 1, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//========== 自底向上对R[1..n]做二路归并排序===============</span><br><span class="line">void MergeSort(SeqList R)</span><br><span class="line">&#123;</span><br><span class="line">    int length;</span><br><span class="line">    for (length = 1; length &lt; n; length *= 2)     //做[lgn]趟排序</span><br><span class="line">        MergePass(R, length);     //有序长度≥n时终止</span><br><span class="line">&#125;</span><br><span class="line">//==========输入顺序表========</span><br><span class="line">void input_int(SeqList R)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    printf(&quot;Please input num(int):&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    printf(&quot;Plase input %d integer:&quot;, n);</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;R[i].key);</span><br><span class="line">&#125;</span><br><span class="line">//==========输出顺序表========</span><br><span class="line">void output_int(SeqList R)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">        printf(&quot;%4d&quot;, R[i].key);</span><br><span class="line">&#125;</span><br><span class="line">//==========主函数======</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    SeqList R;</span><br><span class="line">    input_int(R);</span><br><span class="line">    printf(&quot;\t******** Select **********\n&quot;);</span><br><span class="line">    printf(&quot;\t1: Insert Sort\n&quot;);</span><br><span class="line">    printf(&quot;\t2: Bubble Sort\n&quot;);</span><br><span class="line">    printf(&quot;\t3: Quick Sort\n&quot;);</span><br><span class="line">    printf(&quot;\t4: Straight Selection Sort\n&quot;);</span><br><span class="line">    printf(&quot;\t5: Heap Sort\n&quot;);</span><br><span class="line">    printf(&quot;\t6: Merge Sort\n&quot;);</span><br><span class="line">    printf(&quot;\t7: Exit\n&quot;);</span><br><span class="line">    printf(&quot;\t***************************\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;i);   //输入整数1-7，选择排序方式</span><br><span class="line">    switch (i) &#123;</span><br><span class="line">    case 1: InsertSort(R); break;       //值为1，直接插入排序</span><br><span class="line">    case 2: BubbleSort(R); break;       //值为2，冒泡法排序</span><br><span class="line">    case 3: QuickSort(R, 1, n); break;    //值为3，快速排序</span><br><span class="line">    case 4: SelectSort(R); break;       //值为4，直接选择排序</span><br><span class="line">    case 5: HeapSort(R); break;         //值为5，堆排序</span><br><span class="line">    case 6: MergeSort(R); break;        //值为6，归并排序</span><br><span class="line">    case 7: exit(0);                    //值为7，结束程序</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Sort reult:&quot;);</span><br><span class="line">    output_int(R);</span><br><span class="line">&#125;</span><br><span class="line">实验结果：</span><br><span class="line">1.直接插入排序  输入 15 2 13 33 3 5 9 14 11 22</span><br><span class="line"></span><br><span class="line">2.冒泡排序</span><br><span class="line"></span><br><span class="line">3.快速排序</span><br><span class="line"></span><br><span class="line">4.直接选择排序</span><br><span class="line"></span><br><span class="line">5.堆排序</span><br><span class="line"></span><br><span class="line">6.归并排序</span><br><span class="line"></span><br><span class="line">运行速度比较：</span><br><span class="line"></span><br><span class="line">1.直接插入排序</span><br><span class="line">时间复杂度为 o(n2)</span><br><span class="line">空间复杂度为 o(1)</span><br><span class="line"></span><br><span class="line">2.冒泡排序</span><br><span class="line">时间复杂度为 o(n2)</span><br><span class="line">空间复杂度为 o(1)</span><br><span class="line"></span><br><span class="line">3.快速排序</span><br><span class="line">时间效率：O(nlog2n) —每趟确定的元素呈指数增加</span><br><span class="line">空间效率：</span><br><span class="line">O（log2n）—递归要用到栈空间</span><br><span class="line"></span><br><span class="line">4.直接选择排序</span><br><span class="line">直接插入排序的平均时间复杂度为O(n2）</span><br><span class="line">因此空间复杂度为：O(1) </span><br><span class="line">5.堆排序</span><br><span class="line">时间效率：O(nlog2n) </span><br><span class="line">空间效率：O（1）</span><br><span class="line">6.归并排序</span><br><span class="line">时间复杂度O(nlog2n)</span><br><span class="line">空间复杂度O（n）</span><br></pre></td></tr></table></figure><h3 id="1-直接插入排序"><a href="#1-直接插入排序" class="headerlink" title="1.直接插入排序"></a>1.直接插入排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void insertionSort(int arr[], int n) &#123;</span><br><span class="line">    int i, key, j;</span><br><span class="line">    for (i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        key = arr[i];</span><br><span class="line">        j = i - 1;</span><br><span class="line"></span><br><span class="line">        // 将 arr[0...i-1] 中大于 key 的元素都向右移动一个位置</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + 1] = arr[j];</span><br><span class="line">            j = j - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 插入 key 到正确的位置</span><br><span class="line">        arr[j + 1] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-折半排序"><a href="#2-折半排序" class="headerlink" title="2.折半排序"></a>2.折半排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void binaryInsertionSort(int arr[], int n) &#123;</span><br><span class="line">    int i, key, j, low, high, mid;</span><br><span class="line"></span><br><span class="line">    for (i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        key = arr[i];</span><br><span class="line">        low = 0;</span><br><span class="line">        high = i - 1;</span><br><span class="line"></span><br><span class="line">        // 使用二分查找找到插入位置</span><br><span class="line">        while (low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / 2;</span><br><span class="line">            if (arr[mid] &gt; key)</span><br><span class="line">                high = mid - 1;</span><br><span class="line">            else</span><br><span class="line">                low = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 移动元素，插入到正确位置</span><br><span class="line">        for (j = i - 1; j &gt;= low; j--)</span><br><span class="line">            arr[j + 1] = arr[j];</span><br><span class="line"></span><br><span class="line">        arr[low] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3.希尔排序"></a>3.希尔排序</h3><p>1.分步骤，直接排</p><p>2.有间隔，用dk表示跳跃的间隔，最后dk一定为1</p><p>3.不稳定</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void shellSort(int arr[], int n) &#123;</span><br><span class="line">    for (int gap = n / 2; gap &gt; 0; gap /= 2) &#123;</span><br><span class="line">        for (int i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            int j;</span><br><span class="line">            for (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap)</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-交换排序"><a href="#4-交换排序" class="headerlink" title="4.交换排序"></a>4.交换排序</h3><h4 id="4-1冒泡排序（起泡排序）"><a href="#4-1冒泡排序（起泡排序）" class="headerlink" title="4.1冒泡排序（起泡排序）"></a>4.1冒泡排序（起泡排序）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void bubbleSort(int arr[], int n) &#123;</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n - i - 1; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                // 交换 arr[j] 和 arr[j+1]</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.快速排序"></a>5.快速排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int partition(int arr[], int low, int high) &#123;</span><br><span class="line">    int pivot = arr[high];</span><br><span class="line">    int i = (low - 1);</span><br><span class="line"></span><br><span class="line">    for (int j = low; j &lt;= high - 1; j++) &#123;</span><br><span class="line">        if (arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            // 交换 arr[i] 和 arr[j]</span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 交换 arr[i + 1] 和 arr[high]</span><br><span class="line">    int temp = arr[i + 1];</span><br><span class="line">    arr[i + 1] = arr[high];</span><br><span class="line">    arr[high] = temp;</span><br><span class="line">    return (i + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quickSort(int arr[], int low, int high) &#123;</span><br><span class="line">    if (low &lt; high) &#123;</span><br><span class="line">        int pi = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">        quickSort(arr, low, pi - 1);</span><br><span class="line">        quickSort(arr, pi + 1, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-简单选择排序"><a href="#6-简单选择排序" class="headerlink" title="6.简单选择排序"></a>6.简单选择排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void selectionSort(int arr[], int n) &#123;</span><br><span class="line">    int i, j, minIndex;</span><br><span class="line">    for (i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        for (j = i + 1; j &lt; n; j++)</span><br><span class="line">            if (arr[j] &lt; arr[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line"></span><br><span class="line">        // 交换 arr[i] 和 arr[minIndex]</span><br><span class="line">        int temp = arr[minIndex];</span><br><span class="line">        arr[minIndex] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-树形选择排序（锦标赛ghp-9yymKPfuZyP90Ic46ZIGEhZpjOTDP54cat4B"><a href="#7-树形选择排序（锦标赛ghp-9yymKPfuZyP90Ic46ZIGEhZpjOTDP54cat4B" class="headerlink" title="7.树形选择排序（锦标赛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"></a>7.树形选择排序（锦标赛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</h3><h3 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="8.堆排序"></a>8.堆排序</h3><p><strong>堆排序</strong>是一种树形选择排序，在排序过程中，将待排序的记录r[1..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序序列中选择关键字最大（或最小）的记录。</p><p>如果将序列看成一个完全二叉树，非叶子结点的值均小于（上面左边不等式）或大于（上面右边不等式）左右孩子结点的值</p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312071626515.png" alt="image-20231207162654394"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void heapify(int arr[], int n, int i) &#123;</span><br><span class="line">    int largest = i;</span><br><span class="line">    int left = 2 * i + 1;</span><br><span class="line">    int right = 2 * i + 2;</span><br><span class="line"></span><br><span class="line">    if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line"></span><br><span class="line">    if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line"></span><br><span class="line">    if (largest != i) &#123;</span><br><span class="line">        // 交换 arr[i] 和 arr[largest]</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line"></span><br><span class="line">        heapify(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heapSort(int arr[], int n) &#123;</span><br><span class="line">    for (int i = n / 2 - 1; i &gt;= 0; i--)</span><br><span class="line">        heapify(arr, n, i);</span><br><span class="line"></span><br><span class="line">    for (int i = n - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        // 交换 arr[0] 和 arr[i]</span><br><span class="line">        int temp = arr[0];</span><br><span class="line">        arr[0] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line"></span><br><span class="line">        heapify(arr, i, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-外部排序"><a href="#9-外部排序" class="headerlink" title="9.外部排序"></a>9.外部排序</h3><h4 id="外排的基本方法"><a href="#外排的基本方法" class="headerlink" title="外排的基本方法"></a>外排的基本方法</h4><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\image-20231214082134736.png" alt="image-20231214082134736"></p><h4 id="胜者树ghp-Te68DICI21MITinvYONIbo4DB2ImNo3yPNHW"><a href="#胜者树ghp-Te68DICI21MITinvYONIbo4DB2ImNo3yPNHW" class="headerlink" title="胜者树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"></a>胜者树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</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140827871.png" alt="image-20231214082755792"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140828711.png" alt="image-20231214082841635"></p><h4 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140828894.png" alt="image-20231214082857798"></p><h3 id="置换选择排序"><a href="#置换选择排序" class="headerlink" title="置换选择排序"></a>置换选择排序</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140829406.png" alt="image-20231214082947332"></p><h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140830118.png" alt="image-20231214083002042"></p><h4 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140832733.png" alt="image-20231214083216645"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140835160.png" alt="image-20231214083515080"></p><h3 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140841982.png" alt="image-20231214084145898"></p><p>不稳定：希尔排序，快速排序，堆排序</p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140849845.png" alt="image-20231214084947762"></p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312140850880.png" alt="image-20231214085000801"></p><h2 id="查找题库"><a href="#查找题库" class="headerlink" title="查找题库"></a>查找题库</h2><h3 id="1-找最小值"><a href="#1-找最小值" class="headerlink" title="1.找最小值"></a>1.找最小值</h3><p>用的直接比较</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int min = 1e5;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">int arr[10000];</span><br><span class="line">int number;</span><br><span class="line">int m = 0;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (min &gt; arr[i])</span><br><span class="line">&#123;</span><br><span class="line">min = arr[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; min;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m;</span><br><span class="line">cin &gt;&gt; n&gt;&gt;m;</span><br><span class="line">int arr[120];</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">&#125;</span><br><span class="line">int inquire[120];</span><br><span class="line">int len = 0;</span><br><span class="line">for (int i = 0; i&lt;m; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; inquire[i];</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">int flag = -1;</span><br><span class="line">for (int j = 0; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (inquire[i] == arr[j])</span><br><span class="line">&#123;</span><br><span class="line">flag = j+1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; flag&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-A-B数对"><a href="#3-A-B数对" class="headerlink" title="3.A-B数对"></a>3.A-B数对</h3><p>描述<a href="https://www.luogu.com.cn/problem/solution/P1102">P1102 A-B 数对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>给出一串单调不下降的数以及一个数字 C，要求计算出所有A−B&#x3D;C 的数对的个数（不同位置的数字一样的数对算不同的数对）。</p><p>输入</p><p>输入共两行。</p><p>第一行，两个整数 N,C。</p><p>第二行，N个整数，作为要求处理的那串数。</p><p>输出</p><p>一行，表示该串数中包含的满足A−B&#x3D;C 的数对的个数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">    #include &lt;map&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">    typedef long long LL;</span><br><span class="line">    LL a[200001];</span><br><span class="line">    map&lt;LL,LL&gt; m;//建立一个数字到出现次数的映射 map&lt;num,times&gt;</span><br><span class="line">    //A-B=C --&gt; A-C=B</span><br><span class="line">    int main() &#123;</span><br><span class="line">        int n;</span><br><span class="line">        LL c;</span><br><span class="line">        LL ans=0;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">        for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            m[a[i]]++;</span><br><span class="line">            a[i]-=c;    </span><br><span class="line">        &#125; </span><br><span class="line">        for(int i=1;i&lt;=n;i++) ans+=m[a[i]];</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-普通二叉树"><a href="#4-普通二叉树" class="headerlink" title="4.普通二叉树"></a>4.普通二叉树</h3><p>您需要写一种数据结构，来维护一些数（都是 1e9 以内的数字）的集合，最开始时集合是空的。其中需要提供以下操作，操作次数 q 不超过 104：</p><ol><li>查询值为x的数的排名（排名定义为比当前数小的数的个数 +1。若有多个相同的数，应输出最小的排名）。</li><li>查询排名为 x 的数。</li><li>求 x 的前驱（前驱定义为小于 x，且最大的数）。若未找到则输出−2147483647。</li><li>求 x 的后继（后继定义为大于 x，且最小的数）。若未找到则输出 2147483647。</li><li>插入一个数 x。</li></ol><p>输入</p><p>第一行是一个整数 q，表示操作次数。</p><p>接下来 q 行，每行两个整数 op,x，分别表示操作序号以及操作的参数 x。</p><p>输出</p><p>输出有若干行。对于操作 1,2,3,4输出一个整数，表示该操作的结果。</p><p>样例</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">5 1</span><br><span class="line">5 3</span><br><span class="line">5 5</span><br><span class="line">1 3</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n = 2147483647;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    int count; // 记录当前节点的重复次数</span><br><span class="line">    int leftCount; // 记录左子树节点数量</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(int x) : val(x), count(1), leftCount(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 向二叉搜索树中插入节点</span><br><span class="line">TreeNode* insert(TreeNode* root, int x) &#123;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return new TreeNode(x);</span><br><span class="line">    &#125;</span><br><span class="line">    if (x == root-&gt;val) &#123;</span><br><span class="line">        root-&gt;count++; // 如果值相同，增加当前节点的重复次数</span><br><span class="line">    &#125;</span><br><span class="line">    else if (x &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;leftCount++; // 更新左子树节点数量</span><br><span class="line">        root-&gt;left = insert(root-&gt;left, x);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, x);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取节点排名</span><br><span class="line">int getRank(TreeNode* root, int x) &#123;</span><br><span class="line">    int rank = 0;</span><br><span class="line">    while (root) &#123;</span><br><span class="line">        if (x == root-&gt;val) &#123;</span><br><span class="line">            return rank + root-&gt;leftCount + 1; // 当前节点的排名为左子树节点数量加上重复次数加1</span><br><span class="line">        &#125;</span><br><span class="line">        else if (x &lt; root-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            rank += root-&gt;leftCount + root-&gt;count; // 更新排名</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return rank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据排名获取节点值</span><br><span class="line">int getValueByRank(TreeNode* root, int rank) &#123;</span><br><span class="line">    while (root) &#123;</span><br><span class="line">        int leftSubtreeSize = root-&gt;leftCount;</span><br><span class="line">        int currentNodeCount = root-&gt;count;</span><br><span class="line">        int totalLeftNodes = leftSubtreeSize + currentNodeCount;</span><br><span class="line"></span><br><span class="line">        if (rank &lt;= leftSubtreeSize) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (rank &gt; totalLeftNodes) &#123;</span><br><span class="line">            rank -= totalLeftNodes;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (-n); // 如果未找到，返回-1或其他适当的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取前驱节点值</span><br><span class="line">int getPredecessor(TreeNode* root, int x) &#123;</span><br><span class="line">    int predecessor = -2147483647;</span><br><span class="line">    while (root) &#123;</span><br><span class="line">        if (x &lt;= root-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            predecessor = root-&gt;val;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return predecessor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取后继节点值</span><br><span class="line">int getSuccessor(TreeNode* root, int x) &#123;</span><br><span class="line">    int successor = 2147483647;</span><br><span class="line">    while (root) &#123;</span><br><span class="line">        if (x &gt;= root-&gt;val) &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            successor = root-&gt;val;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return successor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    TreeNode* root = nullptr;</span><br><span class="line">    int q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    for (int i = 0; i &lt; q; i++) &#123;</span><br><span class="line">        int op, x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        switch (op) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            cout &lt;&lt; getRank(root, x) &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            cout &lt;&lt; getValueByRank(root, x) &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            cout &lt;&lt; getPredecessor(root, x) &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            cout &lt;&lt; getSuccessor(root, x) &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        case 5:</span><br><span class="line">            root = insert(root, x);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-队列安排"><a href="#5-队列安排" class="headerlink" title="5.队列安排"></a>5.队列安排</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个学校里老师要将班上 N 个同学排成一列，同学被编号为1∼N，他采取如下的方法：</span><br><span class="line"></span><br><span class="line">先将 1 号同学安排进队列，这时队列中只有他一个人；</span><br><span class="line"></span><br><span class="line">2-N 号同学依次入列，编号为 i 的同学入列方式为：老师指定编号为 i 的同学站在编号为 1∼(i−1) 中某位同学（即之前已经入列的同学）的左边或右边；</span><br><span class="line"></span><br><span class="line">最后，从队列中去掉 M(M&lt;N） 个同学，其他同学位置顺序不变。</span><br><span class="line"></span><br><span class="line">在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第 1 行为一个正整数 N，表示了有 N 个整数。</span><br><span class="line">第 2∼N行，第 i 行包含两个整数 k,p，其中 k 为小于i 的正整数，p 为 0 或者 1。若 p 为0，则表示将 i 号同学插入到 k 号同学的左边，p 为 1 则表示插入到右边。</span><br><span class="line">第 N+1 行为一个正整数 M，表示去掉的同学数目。</span><br><span class="line">接下来 M行，每行一个正整数 x，表示将 x 号同学从队列中移去，如果 x 号同学已经不在队列中则忽略这一条指令。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">1 行，包含最多 N 个空格隔开的正整数，表示了队列从左到右所有同学的编号，行末换行且无空格。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mx=1e5+10;</span><br><span class="line">int n,m;</span><br><span class="line">struct T&#123;</span><br><span class="line">    int l,r;        //每个同学的“左右手” </span><br><span class="line">int d;          //表示同学是否输出 </span><br><span class="line">&#125;t[mx]=&#123;0&#125;;</span><br><span class="line">void add(int i,int k,int f)       //新增同学 </span><br><span class="line">&#123;</span><br><span class="line">    if(f==1)         //左 </span><br><span class="line">    &#123;</span><br><span class="line">        t[k].r=t[i].r;</span><br><span class="line">        t[k].l=i; </span><br><span class="line">        t[i].r=k;</span><br><span class="line">        t[t[k].r].l=k;</span><br><span class="line">    &#125;</span><br><span class="line">    else             //右 </span><br><span class="line">    &#123;</span><br><span class="line">        t[k].r=i;</span><br><span class="line">        t[k].l=t[i].l;</span><br><span class="line">        t[i].l=k;</span><br><span class="line">        t[t[k].l].r=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int x,k,f;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    t[0].r=0,t[0].l=0;</span><br><span class="line">    add(0,1,1);</span><br><span class="line">    for (int i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;f;</span><br><span class="line">        add(x,i,f);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        t[x].d=1;         //将该同学标记为不输出 </span><br><span class="line">    &#125;</span><br><span class="line">    for (int i=t[0].r;i;i=t[i].r)</span><br><span class="line">    &#123;</span><br><span class="line">        if (t[i].d==0)    //输出未标记的 </span><br><span class="line">          cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-明明的随机数"><a href="#6-明明的随机数" class="headerlink" title="6.明明的随机数"></a>6.明明的随机数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 N个 1到 1000 之间的随机整数 （N&lt;=100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">输入有两行，第 1 行为 1 个正整数，表示所生成的随机数的个数 N。</span><br><span class="line">第 2 行有 N个用空格隔开的正整数，为所产生的随机数。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">输出也是两行，第 1 行为 1 个正整数 M，表示不相同的随机数的个数。</span><br><span class="line">第 2 行为 M 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。</span><br><span class="line"></span><br><span class="line">样例</span><br><span class="line">输入</span><br><span class="line"></span><br><span class="line">10</span><br><span class="line">20 40 32 67 40 20 89 300 400 15</span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">15 20 32 40 67 89 300 400</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;//头文件</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">bool a[1001]=&#123;0&#125;;//定义一个桶</span><br><span class="line">int n,i,x;</span><br><span class="line">cin&gt;&gt;n;//输入数量</span><br><span class="line">for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;x;//读入数据</span><br><span class="line">a[x]=1;//统计数据+去重</span><br><span class="line">&#125;</span><br><span class="line">n=0;</span><br><span class="line">for(i=1;i&lt;=1000;i++)&#123;</span><br><span class="line">if(a[i]==1)n++;//统计数量</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;n&lt;&lt;endl;//输出数量</span><br><span class="line">for(i=1;i&lt;=1000;i++)&#123;</span><br><span class="line">if(a[i]==1)cout&lt;&lt;i&lt;&lt;&quot; &quot;;//最后的输出</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桶排序</p><h3 id="7-奖学金"><a href="#7-奖学金" class="headerlink" title="7.奖学金"></a>7.奖学金</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前 5 名学生发奖学金。期末，每个学生都有 3 门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学 排在前面，这样，每个学生的排序是唯一确定的。</span><br><span class="line">任务：先根据输入的 3 门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前 5 名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分) 是:</span><br><span class="line">7 279</span><br><span class="line">5 279</span><br><span class="line">这两行数据的含义是:总分最高的两个同学的学号依次是 7 号、5 号。这两名同学的总分都是 279 (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为 7 的学生语文成绩更高一些。如果你的前两名的输出数据是:</span><br><span class="line">5 279</span><br><span class="line">7 279</span><br><span class="line">则按输出错误处理，不能得分。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">共 n+1行。</span><br><span class="line">第 1 行为一个正整数n（n≤300)，表示该校参加评选的学生人数。</span><br><span class="line">第 2 到 n+1 行，每行有 3 个用空格隔开的数字，每个数字都在 0 到 100之间。第 j行的 3 个数字依次表示学号为 j-1 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 1~n（恰好是输入数据的行号减 1）。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">共 5 行，每行是两个用空格隔开的正整数，依次表示前 5 名学生的学号和总分。</span><br><span class="line"></span><br><span class="line">样例</span><br><span class="line">输入1</span><br><span class="line"></span><br><span class="line">6</span><br><span class="line">90 67 80</span><br><span class="line">87 66 91</span><br><span class="line">78 89 91</span><br><span class="line">88 99 77</span><br><span class="line">67 89 64</span><br><span class="line">78 89 98</span><br><span class="line">输出1</span><br><span class="line"></span><br><span class="line">6 265</span><br><span class="line">4 264</span><br><span class="line">3 258</span><br><span class="line">2 244</span><br><span class="line">1 237</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct stu</span><br><span class="line">&#123;</span><br><span class="line">    int num;//编号</span><br><span class="line">    int c,m,e; </span><br><span class="line">    int sum;</span><br><span class="line">&#125;student[310];</span><br><span class="line">bool cmp(stu a,stu b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a.sum&gt;b.sum) return 1;</span><br><span class="line">    else if(a.sum&lt;b.sum) return 0;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(a.c&gt;b.c) return 1;</span><br><span class="line">        else if(a.c&lt;b.c) return 0;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(a.num&gt;b.num) return 0;</span><br><span class="line">            else return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        student[i].num=i;//录入编号</span><br><span class="line">        cin&gt;&gt;student[i].c&gt;&gt;student[i].m&gt;&gt;student[i].e;//输入</span><br><span class="line">        student[i].sum=student[i].c+student[i].m+student[i].e;//计算总分</span><br><span class="line">    &#125;</span><br><span class="line">    sort(student+1,student+1+n,cmp);</span><br><span class="line">    for(int i=1;i&lt;=5;i++)</span><br><span class="line">        cout&lt;&lt;student[i].num&lt;&lt;&#x27; &#x27;&lt;&lt;student[i].sum&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-纪念品分组"><a href="#8-纪念品分组" class="headerlink" title="8.纪念品分组"></a>8.纪念品分组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得 的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品， 并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。</span><br><span class="line"></span><br><span class="line">你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">共 n+2行：</span><br><span class="line">第一行包括一个整数 w，为每组纪念品价格之和的上限。</span><br><span class="line">第二行为一个整数 n，表示购来的纪念品的总件数 G。</span><br><span class="line">第 3 ∼n+2 行每行包含一个正整数 Pi 表示所对应纪念品的价格。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">一个整数，即最少的分组数目。</span><br><span class="line"></span><br><span class="line">样例</span><br><span class="line">输入</span><br><span class="line"></span><br><span class="line">100 </span><br><span class="line">9 </span><br><span class="line">90 </span><br><span class="line">20 </span><br><span class="line">20 </span><br><span class="line">30 </span><br><span class="line">50 </span><br><span class="line">60 </span><br><span class="line">70 </span><br><span class="line">80 </span><br><span class="line">90</span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>题意</p><p>输入一个有N个数字的数组，你要将它们分组（每组只能由两数组成），使各组两数之和（两数之和&lt;&#x3D;W）接近。输出满足上述条件的最小组数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int p[100005];</span><br><span class="line">int w, n;</span><br><span class="line">int main ()&#123;</span><br><span class="line">    cin &gt;&gt;w&gt;&gt;n;</span><br><span class="line">    for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p, p + n);</span><br><span class="line">    int  j = 0;</span><br><span class="line">    int sum =0;</span><br><span class="line">    for(int i = n - 1; i &gt;= j; i--)&#123;</span><br><span class="line">        if(p[i] + p[j] &lt;= w)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="9-统计数字"><a href="#9-统计数字" class="headerlink" title="9.统计数字"></a>9.统计数字</h3><p>[P1097 <a href="https://www.luogu.com.cn/problem/solution/P1097">NOIP2007 提高组] 统计数字 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">某次科研调查时得到了n个自然数，每个数均不超过1500000000(1.5×109</span><br><span class="line">)。已知不相同的数不超过10000个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">共n+1行。</span><br><span class="line"></span><br><span class="line">第一行是整数n，表示自然数的个数；</span><br><span class="line"></span><br><span class="line">第2至n+1每行一个自然数。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">共m行（m为n个自然数中不相同数的个数），按照自然数从小到大的顺序输出。</span><br><span class="line"></span><br><span class="line">每行输出2个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    // 使用map来存储自然数及其出现次数</span><br><span class="line">    std::map&lt;int, int&gt; countMap;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        int num;</span><br><span class="line">        std::cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">        // 更新map中自然数的出现次数</span><br><span class="line">        countMap[num]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历map，按照自然数从小到大的顺序输出统计结果</span><br><span class="line">    for (auto it = countMap.begin(); it != countMap.end(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-分数线划定"><a href="#10-分数线划定" class="headerlink" title="10.分数线划定"></a>10.分数线划定</h3><p>[P1068 <a href="https://www.luogu.com.cn/problem/P1068">NOIP2009 普及组] 分数线划定 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A 市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 150% 划定，即如果计划录取 m 名志愿者，则面试分数线为排名第 m ×150%（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。</span><br><span class="line"></span><br><span class="line">现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第一行，两个整数 n,m(5≤n≤5000,3≤m≤n)，中间用一个空格隔开，其中 n 表示报名参加笔试的选手总数，m 表示计划录取的志愿者人数。输入数据保证 m ×150% 向下取整后小于等于 n。</span><br><span class="line">第二行到第 n+1行，每行包括两个整数，中间用一个空格隔开，分别是选手的报名号 k(1000≤k≤9999)和该选手的笔试成绩 s(1≤s≤100)。数据保证选手的报名号各不相同。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">第一行，有 2 个整数，用一个空格隔开，第一个整数表示面试分数线；第二个整数为进入面试的选手的实际人数。</span><br><span class="line"></span><br><span class="line">从第二行开始，每行包含 2 个整数，中间用一个空格隔开，分别表示进入面试的选手的报名号和笔试成绩，按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。</span><br><span class="line"></span><br><span class="line">样例</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;//万能头文件</span><br><span class="line">using namespace std;</span><br><span class="line">int i,n,m,f,k[5001],s[5001],sub[5001];//f是分数线，sub是下标</span><br><span class="line">bool cmp(int a,int b)&#123;//sort规则</span><br><span class="line">    if(s[a]==s[b])return k[a]&lt;k[b];//成绩相等比编号</span><br><span class="line">    return s[a]&gt;s[b];//否则比成绩</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(i=1;i&lt;=n;i++)cin&gt;&gt;k[sub[i]=i]&gt;&gt;s[i];//输入编号和成绩，同时初始化下标</span><br><span class="line">    sort(sub+1,sub+n+1,cmp);//对下标排序</span><br><span class="line">    f=s[sub[int(m*1.5)]];//算分数线</span><br><span class="line">    for(i=1;s[sub[i]]&gt;=f;i++);//算录取人数</span><br><span class="line">    cout&lt;&lt;f&lt;&lt;&quot; &quot;&lt;&lt;i-1&lt;&lt;endl;</span><br><span class="line">    for(i=1;s[sub[i]]&gt;=f;i++)cout&lt;&lt;k[sub[i]]&lt;&lt;&quot; &quot;&lt;&lt;s[sub[i]]&lt;&lt;endl;//输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-合并果子"><a href="#11-合并果子" class="headerlink" title="11.合并果子"></a>11.合并果子</h3><p>[P1090 <a href="https://www.luogu.com.cn/problem/P1090">NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</span><br><span class="line"></span><br><span class="line">每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</span><br><span class="line"></span><br><span class="line">因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</span><br><span class="line"></span><br><span class="line">例如有 3 种果子，数目依次为 1 ， 2 ， 9 。可以先将 1 、 2 堆合并，新堆数目为 3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为 12 。所以多多总共耗费体力 =3+12=15 。可以证明 15 为最小的体力耗费值。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">共两行。</span><br><span class="line">第一行是一个整数 n(1≤n≤10000) ，表示果子的种类数。</span><br><span class="line">第二行包含 n 个整数，用空格分隔，第 i 个整数ai(1≤ai≤20000) 是第 i 种果子的数目。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2e31</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,x,ans;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;x,q.push(x);</span><br><span class="line">while(q.size()&gt;=2)&#123;</span><br><span class="line">int a=q.top(); q.pop();</span><br><span class="line">int b=q.top(); q.pop();</span><br><span class="line">ans+=a+b;</span><br><span class="line">q.push(a+b);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="1-合并两个有序链表"><a href="#1-合并两个有序链表" class="headerlink" title="1.合并两个有序链表"></a>1.合并两个有序链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 合并两个有序链表</span><br><span class="line">描述</span><br><span class="line">将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</span><br><span class="line">输入</span><br><span class="line">输入两个顺序表l1，l2，l1和l2均按非递减顺序排列，两个链表的节点数目范围是 [0, 50]，-100 &lt;= Node.val &lt;= 100</span><br><span class="line">-1表示链表结束符</span><br><span class="line">输出</span><br><span class="line">输出合并后的顺序表</span><br><span class="line">输入样例</span><br><span class="line"></span><br><span class="line">1 2 4 -1</span><br><span class="line">1 3 4 -1</span><br><span class="line">输出样例</span><br><span class="line"></span><br><span class="line">1 1 2 3 4 4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    if (l1 == NULL) &#123;</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (l2 == NULL) &#123;</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;</span><br><span class="line">    l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">    return l2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建新节点</span><br><span class="line">struct ListNode* createNode(int val) &#123;</span><br><span class="line">    struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">    if (newNode != NULL) &#123;</span><br><span class="line">        newNode-&gt;val = val;</span><br><span class="line">        newNode-&gt;next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入节点到链表末尾</span><br><span class="line">void insertNode(struct ListNode** head, int val) &#123;</span><br><span class="line">    struct ListNode* newNode = createNode(val);</span><br><span class="line">    if (*head == NULL) &#123;</span><br><span class="line">        *head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        struct ListNode* current = *head;</span><br><span class="line">        while (current-&gt;next != NULL) &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用于输出链表</span><br><span class="line">void printList(struct ListNode* head) &#123;</span><br><span class="line">    while (head != NULL) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, head-&gt;val);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">   // 表示链表结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建链表1: 1 -&gt; 2 -&gt; 4</span><br><span class="line"></span><br><span class="line">    struct ListNode* l1 = NULL;</span><br><span class="line">    for (int i = 0;; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a = 0;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        if (a == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        insertNode(&amp;l1, a);</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* l2 = NULL;</span><br><span class="line">    for (int i = 0;; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a = 0;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        if (a == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        insertNode(&amp;l2, a);</span><br><span class="line">    &#125;</span><br><span class="line">    // 合并两个有序链表</span><br><span class="line">    struct ListNode* mergedList = mergeTwoLists(l1, l2);</span><br><span class="line">    // 输出合并后的链表</span><br><span class="line">    printList(mergedList);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-删除排序链表中的重复元素"><a href="#2-删除排序链表中的重复元素" class="headerlink" title="2.删除排序链表中的重复元素"></a>2.删除排序链表中的重复元素</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述</span><br><span class="line">给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回已排序的链表 </span><br><span class="line">输入</span><br><span class="line">输入已排序的链表，链表中节点数目在范围 [0, 300] 内，-100 &lt;= Node.val &lt;= 100，题目数据保证链表已经按升序排列</span><br><span class="line">-1表示链表结束符</span><br><span class="line">输出</span><br><span class="line">输出已排序的链表</span><br><span class="line">输入样例</span><br><span class="line"></span><br><span class="line">1 1 2 3 3 -1</span><br><span class="line">输出样例</span><br><span class="line"></span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Function to delete duplicates from a sorted linked list</span><br><span class="line">struct ListNode* deleteDuplicates(struct ListNode* head) &#123;</span><br><span class="line">    if (head == nullptr || head-&gt;next == nullptr) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct ListNode* current = head;</span><br><span class="line"></span><br><span class="line">    while (current != nullptr &amp;&amp; current-&gt;next != nullptr) &#123;</span><br><span class="line">        if (current-&gt;val == current-&gt;next-&gt;val) &#123;</span><br><span class="line">            // Duplicate found, skip the next node</span><br><span class="line">            struct ListNode* temp = current-&gt;next;</span><br><span class="line">            current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Move to the next node</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Function to insert a node at the end of the linked list</span><br><span class="line">void insertNode(struct ListNode** head, int val) &#123;</span><br><span class="line">    struct ListNode* newNode = new ListNode;</span><br><span class="line">    newNode-&gt;val = val;</span><br><span class="line">    newNode-&gt;next = nullptr;</span><br><span class="line"></span><br><span class="line">    if (*head == nullptr) &#123;</span><br><span class="line">        *head = newNode;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        struct ListNode* current = *head;</span><br><span class="line">        while (current-&gt;next != nullptr) &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Function to print the linked list</span><br><span class="line">void printList(struct ListNode* head) &#123;</span><br><span class="line">    while (head != nullptr) &#123;</span><br><span class="line">        cout &lt;&lt; head-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    struct ListNode* head = nullptr;</span><br><span class="line"></span><br><span class="line">    // Create a sorted linked list</span><br><span class="line">    int value;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        cin &gt;&gt; value;</span><br><span class="line">        if (value == -1) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        insertNode(&amp;head, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Delete duplicates</span><br><span class="line">    head = deleteDuplicates(head);</span><br><span class="line"></span><br><span class="line">    // Print the resulting linked list</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-板子"><a href="#总结-板子" class="headerlink" title="总结  板子"></a>总结  板子</h2><h3 id="1-定义链表"><a href="#1-定义链表" class="headerlink" title="1.定义链表"></a>1.定义链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-创建链表"><a href="#2-创建链表" class="headerlink" title="2.创建链表"></a>2.创建链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode* createNode(int val) &#123;</span><br><span class="line">    struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">    if (newNode != NULL) &#123;</span><br><span class="line">        newNode-&gt;val = val;</span><br><span class="line">        newNode-&gt;next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-插入尾节点"><a href="#3-插入尾节点" class="headerlink" title="3.插入尾节点"></a>3.插入尾节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void insertNode(struct ListNode** head, int val) &#123;</span><br><span class="line">    struct ListNode* newNode = createNode(val);</span><br><span class="line">    if (*head == NULL) &#123;</span><br><span class="line">        *head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        struct ListNode* current = *head;</span><br><span class="line">        while (current-&gt;next != NULL) &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-输出链表"><a href="#4-输出链表" class="headerlink" title="4.输出链表"></a>4.输出链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void printList(struct ListNode* head) &#123;</span><br><span class="line">    while (head != NULL) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, head-&gt;val);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 表示链表结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-反转链表"><a href="#5-反转链表" class="headerlink" title="5.反转链表"></a>5.反转链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">    ListNode* prev = nullptr;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    while (current != nullptr) &#123;</span><br><span class="line">        ListNode* nextTemp = current-&gt;next;</span><br><span class="line">        current-&gt;next = prev;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-反转链表2"><a href="#6-反转链表2" class="headerlink" title="6. 反转链表2"></a>6. 反转链表2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode* reverseLists(struct ListNode* head,int left,int right) &#123;</span><br><span class="line">    if (head == NULL || left == right) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* dummy = new ListNode();</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    struct ListNode* pre = dummy;</span><br><span class="line">    for (int i = 0; i &lt; left-1; i++) &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* cur = pre-&gt;next;</span><br><span class="line">    struct ListNode* next = NULL;</span><br><span class="line">    for (int i = 0; i &lt; right - left; ++i) &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-删除值为val的节点"><a href="#7-删除值为val的节点" class="headerlink" title="7.删除值为val的节点"></a>7.删除值为val的节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode* deleteLists(struct ListNode* l, int val) &#123;</span><br><span class="line">    struct ListNode dummy;//创建一个名为 dummy 的虚拟头节点，其 next 指针指向原始链表的头部。这样做的目的是简化边界情况的处理，因为无论原始链表是否为空，我们都能够使用 dummy.next 访问到链表的头部。</span><br><span class="line">    dummy.next = l;</span><br><span class="line">    struct ListNode* current = &amp;dummy;</span><br><span class="line"></span><br><span class="line">    while (current-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if (current-&gt;next-&gt;val == val) &#123;</span><br><span class="line">            struct ListNode* temp = current-&gt;next;</span><br><span class="line">            current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-删除最后第N个节点"><a href="#8-删除最后第N个节点" class="headerlink" title="8.删除最后第N个节点"></a>8.删除最后第N个节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode* deleteLists(struct ListNode* l, int num) &#123;</span><br><span class="line">    l = reverseList(l);</span><br><span class="line">    struct ListNode dummy;//创建一个名为 dummy 的虚拟头节点，其 next 指针指向原始链表的头部。这样做的目的是简化边界情况的处理，因为无论原始链表是否为空，我们都能够使用 dummy.next 访问到链表的头部。</span><br><span class="line">    dummy.next = l;</span><br><span class="line">    struct ListNode* current = &amp;dummy;</span><br><span class="line">    int number = 1;</span><br><span class="line">    while (current-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if (number==num) &#123;</span><br><span class="line">            struct ListNode* temp = current-&gt;next;</span><br><span class="line">            current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return reverseList(dummy.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-合并有序链表（递归）"><a href="#9-合并有序链表（递归）" class="headerlink" title="9.合并有序链表（递归）"></a>9.合并有序链表（递归）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    if (l1 == NULL) &#123;</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (l2 == NULL) &#123;</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;</span><br><span class="line">    l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">    return l2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-链表孪生和"><a href="#10-链表孪生和" class="headerlink" title="10.链表孪生和"></a>10.链表孪生和</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int pairSum(ListNode* head) &#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head-&gt;next;</span><br><span class="line">    while (fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 反转链表</span><br><span class="line">    ListNode* last = slow-&gt;next;</span><br><span class="line">    while (last-&gt;next) &#123;</span><br><span class="line">        ListNode* cur = last-&gt;next;</span><br><span class="line">        last-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    ListNode* x = head;</span><br><span class="line">    ListNode* y = slow-&gt;next;</span><br><span class="line">    while (y) &#123;</span><br><span class="line">        ans = max(ans, x-&gt;val + y-&gt;val);</span><br><span class="line">        x = x-&gt;next;</span><br><span class="line">        y = y-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-两数相加"><a href="#11-两数相加" class="headerlink" title="11.两数相加"></a>11.两数相加</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    if (l1 == NULL) &#123;</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (l2 == NULL) &#123;</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* result = NULL;</span><br><span class="line">    struct ListNode* current = NULL;</span><br><span class="line">    int carry = 0;</span><br><span class="line">    while (l1 != NULL || l2 != NULL || carry != 0) &#123;</span><br><span class="line">        int val1 = (l1 != NULL) ? l1-&gt;val : 0;</span><br><span class="line">        int val2 = (l2 != NULL) ? l2-&gt;val : 0;</span><br><span class="line"></span><br><span class="line">        int sum = val1 + val2 + carry;</span><br><span class="line">        carry = sum / 10;</span><br><span class="line"></span><br><span class="line">        struct ListNode* newNode = createNode(sum % 10);</span><br><span class="line"></span><br><span class="line">        if (result == NULL) &#123;</span><br><span class="line">            result = newNode;</span><br><span class="line">            current = result;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            current-&gt;next = newNode;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (l1 != NULL) l1 = l1-&gt;next;</span><br><span class="line">        if (l2 != NULL) l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Reverse the result list before returning</span><br><span class="line">    return reverseLists(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python.md</title>
      <link href="/2023/09/15/python-md/"/>
      <url>/2023/09/15/python-md/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构.md</title>
      <link href="/2023/09/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-md/"/>
      <url>/2023/09/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-md/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-什么是数据结构"><a href="#1-什么是数据结构" class="headerlink" title="1.什么是数据结构"></a>1.什么是数据结构</h2><p>数据结构(Data Structure)是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的<br>数据元素的集合。</p><h2 id="2-什么是算法"><a href="#2-什么是算法" class="headerlink" title="2.什么是算法"></a>2.什么是算法</h2><p>算法(Algorithm):就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为<br>输出。简单来说算法就是一系列的计算步骤，用来将输入数据转化成输出结果。</p><h2 id="3-顺序表"><a href="#3-顺序表" class="headerlink" title="3.顺序表"></a>3.顺序表</h2><h2 id="4-时间空间复杂度"><a href="#4-时间空间复杂度" class="headerlink" title="4.时间空间复杂度"></a>4.时间空间复杂度</h2><p>基本语句重复执行的次数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i=1;i&lt;=n;i++</span><br><span class="line">   for j=1;j&lt;=i;j++</span><br><span class="line">    for(k=1;k&lt;=j;k++)</span><br></pre></td></tr></table></figure><p>O(n(n+1)(n+2)&#x2F;6)&#x3D;O(n^3);</p><h2 id="稀疏多项式的计算"><a href="#稀疏多项式的计算" class="headerlink" title="稀疏多项式的计算"></a>稀疏多项式的计算</h2><h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><h3 id="1-轮转数组"><a href="#1-轮转数组" class="headerlink" title="1.轮转数组"></a>1.轮转数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="所要复习内容ghp-SsO3HpcByJoDa2aRTVuNmaODanGMBo4FJBYI"><a href="#所要复习内容ghp-SsO3HpcByJoDa2aRTVuNmaODanGMBo4FJBYI" class="headerlink" title="所要复习内容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"></a>所要复习内容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</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\image-20231218103331349.png" alt="image-20231218103331349"></p><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h2><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312181038146.png" alt="image-20231218103806039"></p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312181040083.png" alt="image-20231218104013941"></p><h3 id="顺序表定义"><a href="#顺序表定义" class="headerlink" title="顺序表定义"></a>顺序表定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXSIZE 100//最大长度</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    ElemType *elem(int arr[100])</span><br><span class="line">    int length;</span><br><span class="line">&#125;SQList;</span><br></pre></td></tr></table></figure><p>例子</p><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312181050457.png" alt="image-20231218105044313"></p><h4 id="malloc，C语言的动态分配函数"><a href="#malloc，C语言的动态分配函数" class="headerlink" title="malloc，C语言的动态分配函数"></a>malloc，C语言的动态分配函数</h4><p><img src="https://cdn.jsdelivr.net/gh/nice020310/blogimage@main/202312181053391.png" alt="image-20231218105340314"></p><h3 id="初始化顺序表"><a href="#初始化顺序表" class="headerlink" title="初始化顺序表"></a>初始化顺序表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Status InitList_Sq(SqList &amp;L)                   //构造一 个空的顺序表L</span><br><span class="line">&#123;</span><br><span class="line">    L.elem= （ElemType*）malloc(MAXSIZE * sizeof(ElemType));   //为顺序表分配空间</span><br><span class="line">    if(!L.elem) exit(OVERFLOW);           //存储分配失败</span><br><span class="line">    L.length=0;     //空表长度为0</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁和清空线性表"><a href="#销毁和清空线性表" class="headerlink" title="销毁和清空线性表"></a>销毁和清空线性表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//销毁</span><br><span class="line">void DestroyList(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">  if (L.elem) delete[]L.elem;   </span><br><span class="line"> //释放存储空间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空</span><br><span class="line">void ClearList(SqList &amp;L) </span><br><span class="line">&#123;</span><br><span class="line">   L.length=0;               </span><br><span class="line"> //将线性表的长度置为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="求线性表L的长度"><a href="#求线性表L的长度" class="headerlink" title="求线性表L的长度"></a>求线性表L的长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int GetLength(SqList L)</span><br><span class="line">&#123;</span><br><span class="line">   return (L.length);             </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="判断线性表是否为空"><a href="#判断线性表是否为空" class="headerlink" title="判断线性表是否为空"></a>判断线性表是否为空</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int IsEmpty(SqList L)</span><br><span class="line">&#123;</span><br><span class="line">  if (L.length==0) return 1;      </span><br><span class="line">   else return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="取值（根据位置i获取相应位置数据元素的内容）"><a href="#取值（根据位置i获取相应位置数据元素的内容）" class="headerlink" title="取值（根据位置i获取相应位置数据元素的内容）"></a>取值（根据位置i获取相应位置数据元素的内容）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int GetElem(SqList L,int i,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">  if (i&lt;1||i&gt;L.length) return ERROR;   </span><br><span class="line">   //判断i值是否合理，若不合理，返回ERROR</span><br><span class="line">  e=L.elem[i-1];   //第i-1的单元存储着第i个数据</span><br><span class="line">  return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数模.md</title>
      <link href="/2023/09/15/%E6%95%B0%E6%A8%A1-md/"/>
      <url>/2023/09/15/%E6%95%B0%E6%A8%A1-md/</url>
      
        <content type="html"><![CDATA[<h1 id="竞赛流程"><a href="#竞赛流程" class="headerlink" title="竞赛流程"></a>竞赛流程</h1><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693383660748.png" alt="1693383660748"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693383677461.png" alt="1693383677461"></p><h1 id="赛题"><a href="#赛题" class="headerlink" title="赛题"></a>赛题</h1><h2 id="1-优化类"><a href="#1-优化类" class="headerlink" title="1.优化类"></a>1.优化类</h2><p>特点最优最短最合适</p><p>模型算法：线性规划，非线性规划，多目标规划，最短路径,最小生成树，动态规划</p><h2 id="2-预测类"><a href="#2-预测类" class="headerlink" title="2.预测类"></a>2.预测类</h2><p>特点：短&#x2F;长期和周期</p><p>灰色预测，时间序列，回归分析，支持向量机，神经网络预测，马尔科夫链</p><h2 id="3-评价决策类"><a href="#3-评价决策类" class="headerlink" title="3.评价决策类"></a>3.评价决策类</h2><p>特点：孰优孰劣</p><p>层次分析，TOPSIS法，灰色关联分析，</p><p>模糊综合评价,主成分分析，聚类分析</p><h2 id="4-NP-hard类"><a href="#4-NP-hard类" class="headerlink" title="4.NP-hard类"></a>4.NP-hard类</h2><p>特点：无法求最优解</p><p>蚁群算法，粒子群算法，遗传算法，模拟退火</p><h1 id="赛前准备"><a href="#赛前准备" class="headerlink" title="赛前准备"></a>赛前准备</h1><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693384484192.png" alt="1693384484192"></p><p>MD5码只允许上传一次，生成后就不要碰文件，打开都不行</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693384766458.png" alt="1693384766458"></p><h2 id="大三再来"><a href="#大三再来" class="headerlink" title="大三再来"></a>大三再来</h2><h1 id="赛题选择"><a href="#赛题选择" class="headerlink" title="赛题选择"></a>赛题选择</h1><h2 id="A题偏向物理-x2F-工程类"><a href="#A题偏向物理-x2F-工程类" class="headerlink" title="A题偏向物理&#x2F;工程类"></a>A题偏向物理&#x2F;工程类</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693384923453.png" alt="1693384923453"></p><h2 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693385022874.png" alt="1693385022874"></p><h2 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693385032735.png" alt="1693385032735"></p><p>数据需要自己找</p><h1 id="如何进行选题"><a href="#如何进行选题" class="headerlink" title="如何进行选题"></a>如何进行选题</h1><h2 id="1-排除背景看不懂的题"><a href="#1-排除背景看不懂的题" class="headerlink" title="1.排除背景看不懂的题"></a>1.排除背景看不懂的题</h2><h2 id="2-定题"><a href="#2-定题" class="headerlink" title="2.定题"></a>2.定题</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693385161622.png" alt="1693385161622"></p><h1 id="搜索技巧"><a href="#搜索技巧" class="headerlink" title="搜索技巧"></a>搜索技巧</h1><h2 id><a href="#" class="headerlink" title></a><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693385293856.png" alt="1693385293856"></h2><h1 id="查文献"><a href="#查文献" class="headerlink" title="查文献"></a>查文献</h1><h2 id="1-查知网"><a href="#1-查知网" class="headerlink" title="1.查知网"></a>1.查知网</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693385405336.png" alt="1693385405336"></p><h2 id="2-找数据"><a href="#2-找数据" class="headerlink" title="2.找数据"></a>2.找数据</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693385803512.png" alt="1693385803512"></p><p>\国家统计局</p><p><a href="https://data.stats.gov.cn/">国家数据 (stats.gov.cn)</a></p><p>EPSDATA</p><p><a href="https://www.epsnet.com.cn/">https://www.epsnet.com.cn/</a></p><h2 id="3-数据预处理"><a href="#3-数据预处理" class="headerlink" title="3.数据预处理"></a>3.数据预处理</h2><p>缺失40%直接删</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693387528832.png" alt="1693387528832"></p><p>异常值</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693387614179.png" alt="1693387614179"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693387802174.png" alt="1693387802174"></p><h1 id="建模过程"><a href="#建模过程" class="headerlink" title="建模过程"></a>建模过程</h1><h2 id="1-主要是写论文"><a href="#1-主要是写论文" class="headerlink" title="1.主要是写论文"></a>1.主要是写论文</h2><h3 id="摘要，问题重述，模型假设和符号说明，模型建立与求解（最长），模型优缺点，参考文献，和附录"><a href="#摘要，问题重述，模型假设和符号说明，模型建立与求解（最长），模型优缺点，参考文献，和附录" class="headerlink" title="摘要，问题重述，模型假设和符号说明，模型建立与求解（最长），模型优缺点，参考文献，和附录"></a>摘要，问题重述，模型假设和符号说明，模型建立与求解（最长），模型优缺点，参考文献，和附录</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693444862278.png" alt="1693444862278"></p><h2 id="2-模型建立"><a href="#2-模型建立" class="headerlink" title="2.模型建立"></a>2.模型建立</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693444994177.png" alt="1693444994177"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693445019711.png" alt="1693445019711"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693445133694.png" alt="1693445133694"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693445175250.png" alt="1693445175250"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693445199820.png" alt="1693445199820"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693445586529.png" alt="1693445586529"></p><h1 id="2022C题"><a href="#2022C题" class="headerlink" title="2022C题"></a>2022C题</h1><h2 id="1-审题"><a href="#1-审题" class="headerlink" title="1.审题"></a>1.审题</h2><h2 id="2-问题1分析"><a href="#2-问题1分析" class="headerlink" title="2.问题1分析"></a>2.问题1分析</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693461592185.png" alt="1693461592185"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693446937221.png" alt="1693446937221"></p><h3 id="1-卡方检验"><a href="#1-卡方检验" class="headerlink" title="1.卡方检验"></a>1.卡方检验</h3><p>卡方检验是卡方分布为基础的一种检验方法，主要用于<strong>分类变量</strong>，根据样本数据推断总体的分布与期望分布是否有显著差异，或推断两个分类变量是否相关或相互独立。</p><h3 id="2-数据预处理，逻辑回归"><a href="#2-数据预处理，逻辑回归" class="headerlink" title="2.数据预处理，逻辑回归"></a>2.数据预处理，逻辑回归</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693448007220.png" alt="1693448007220"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693448055922.png" alt="1693448055922"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693448770406.png" alt="1693448770406"></p><h3 id="3-逆用逻辑回归遍历合理性检验"><a href="#3-逆用逻辑回归遍历合理性检验" class="headerlink" title="3.逆用逻辑回归遍历合理性检验"></a>3.逆用逻辑回归遍历合理性检验</h3><h2 id="3-问题2分析"><a href="#3-问题2分析" class="headerlink" title="3.问题2分析"></a>3.问题2分析</h2><h3 id="1-逻辑回归"><a href="#1-逻辑回归" class="headerlink" title="1.逻辑回归"></a>1.逻辑回归</h3><h3 id="2-K-means聚类"><a href="#2-K-means聚类" class="headerlink" title="2.K-means聚类"></a>2.K-means聚类</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693448972730.png" alt="1693448972730"></p><h3 id="3-合理性检验与敏感性分析"><a href="#3-合理性检验与敏感性分析" class="headerlink" title="3.合理性检验与敏感性分析"></a>3.合理性检验与敏感性分析</h3><h2 id="4-问题3分析"><a href="#4-问题3分析" class="headerlink" title="4.问题3分析"></a>4.问题3分析</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.<img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693447619765.png" alt="1693447619765"></h3><h2 id="5-问题4分析"><a href="#5-问题4分析" class="headerlink" title="5.问题4分析"></a>5.问题4分析</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693449545406.png" alt="1693449545406"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693449609040.png" alt="1693449609040"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693447643341.png" alt="1693447643341"></p><h3 id="1-斯皮尔曼相关性"><a href="#1-斯皮尔曼相关性" class="headerlink" title="1.斯皮尔曼相关性"></a>1.斯皮尔曼相关性</h3><h3 id="2-因子分析"><a href="#2-因子分析" class="headerlink" title="2.因子分析"></a>2.因子分析</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693449677698.png" alt="1693449677698"></p><h1 id="MATLAB"><a href="#MATLAB" class="headerlink" title="MATLAB"></a>MATLAB</h1><h2 id="1-输入输出"><a href="#1-输入输出" class="headerlink" title="1.输入输出"></a>1.输入输出</h2><p>1.disp相当于C语言里的printf,输出</p><p>2.input，输入</p><h2 id="2-字符串合并"><a href="#2-字符串合并" class="headerlink" title="2.字符串合并"></a>2.字符串合并</h2><p>1.strcat(str1,str2,str3)</p><p>2.[str1,str2,……]</p><h2 id="3-数字转换字符串"><a href="#3-数字转换字符串" class="headerlink" title="3.数字转换字符串"></a>3.数字转换字符串</h2><p>num2str</p><p>ex:c&#x3D;100</p><p>num2str(c)</p><h2 id="4-求和函数-乘法函数"><a href="#4-求和函数-乘法函数" class="headerlink" title="4.求和函数,乘法函数"></a>4.求和函数,乘法函数</h2><p>1.sum</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1691219512207.png" alt="1691219512207"></p><p>2.prod</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1691763404747.png" alt="1691763404747"></p><h2 id="5-判断矩阵"><a href="#5-判断矩阵" class="headerlink" title="5.判断矩阵"></a>5.判断矩阵</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1691219264637.png" alt="1691219264637"></p><h2 id="6-算数平均法求权重"><a href="#6-算数平均法求权重" class="headerlink" title="6.算数平均法求权重"></a>6.算数平均法求权重</h2><h2 id="7-如何在MATLAB提取矩阵中指定位置"><a href="#7-如何在MATLAB提取矩阵中指定位置" class="headerlink" title="7.如何在MATLAB提取矩阵中指定位置"></a>7.如何在MATLAB提取矩阵中指定位置</h2><h4 id="1-取指定行和列的一个元素"><a href="#1-取指定行和列的一个元素" class="headerlink" title="1.取指定行和列的一个元素"></a>1.取指定行和列的一个元素</h4><p>A(1,2)</p><h4 id="2-取指定某一行或某一列的所有元素"><a href="#2-取指定某一行或某一列的所有元素" class="headerlink" title="2.取指定某一行或某一列的所有元素"></a>2.取指定某一行或某一列的所有元素</h4><p>A(1,:),A(:,2)</p><h4 id="3-取某些行列"><a href="#3-取某些行列" class="headerlink" title="3.取某些行列"></a>3.取某些行列</h4><p>A([2,5],:)表示只取2,5行</p><p>A(2:5,:)取2-5行</p><p>A(2:2:5,:)中间的2代表要取2,4行，等差数列为2</p><p>A(2:end,:)</p><h1 id="8-size函数"><a href="#8-size函数" class="headerlink" title="8.size函数"></a>8.size函数</h1><p>[r,c] &#x3D; size(A)</p><p>r&#x3D; size(A,1)%返回行数</p><p>c &#x3D; size(A,2)%返回列数</p><h1 id="9-repmat函数"><a href="#9-repmat函数" class="headerlink" title="9.repmat函数"></a>9.repmat函数</h1><p>B &#x3D; repmat（A,m,n)；将矩阵a复制m*n块</p><h1 id="10-求权重三种方法"><a href="#10-求权重三种方法" class="headerlink" title="10.求权重三种方法"></a>10.求权重三种方法</h1><h2 id="1-算术平均法求权重"><a href="#1-算术平均法求权重" class="headerlink" title="1.算术平均法求权重"></a>1.算术平均法求权重</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1691763497193.png" alt="1691763497193"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1691763507387.png" alt="1691763507387"></p><h2 id="2-几何平均法求权重"><a href="#2-几何平均法求权重" class="headerlink" title="2.几何平均法求权重"></a>2.几何平均法求权重</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1691763659497.png" alt="1691763659497"></p><h2 id="3-特征值法求权重"><a href="#3-特征值法求权重" class="headerlink" title="3.特征值法求权重"></a>3.特征值法求权重</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1691763693228.png" alt="1691763693228"></p><h1 id="11-计算一致性比例CR"><a href="#11-计算一致性比例CR" class="headerlink" title="11.计算一致性比例CR"></a>11.计算一致性比例CR</h1><h1 id="12-TOPSIS法（评价）"><a href="#12-TOPSIS法（评价）" class="headerlink" title="12.TOPSIS法（评价）"></a>12.TOPSIS法（评价）</h1><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1692503264150.png" alt="1692503264150"></p><h2 id="1-指标正向化"><a href="#1-指标正向化" class="headerlink" title="1.指标正向化"></a>1.指标正向化</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1692503513552.png" alt="1692503513552"></p><h2 id="2-标准化处理"><a href="#2-标准化处理" class="headerlink" title="2.标准化处理"></a>2.标准化处理</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1692503659516.png" alt="1692503659516"></p><h2 id="3-类比只有一个指标得分"><a href="#3-类比只有一个指标得分" class="headerlink" title="3.类比只有一个指标得分"></a>3.类比只有一个指标得分</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1692504000012.png" alt="1692504000012"></p><h2 id="4-如何计算得分"><a href="#4-如何计算得分" class="headerlink" title="4.如何计算得分"></a>4.如何计算得分</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1692504089672.png" alt="1692504089672"></p><h2 id="5-第一步将原始矩阵正向化"><a href="#5-第一步将原始矩阵正向化" class="headerlink" title="5.第一步将原始矩阵正向化"></a>5.第一步将原始矩阵正向化</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1692504212831.png" alt="1692504212831"></p><h3 id="1-极小转极大"><a href="#1-极小转极大" class="headerlink" title="1.极小转极大"></a>1.极小转极大</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1692504809796.png" alt="1692504809796"></p><h3 id="2-中间型转极大"><a href="#2-中间型转极大" class="headerlink" title="2.中间型转极大"></a>2.中间型转极大</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1692504837319.png" alt="1692504837319"></p><h3 id="3-区间型转极大型"><a href="#3-区间型转极大型" class="headerlink" title="3.区间型转极大型"></a>3.区间型转极大型</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1692504638180.png" alt="1692504638180"></p><h2 id="6-第二步正向矩阵标准化"><a href="#6-第二步正向矩阵标准化" class="headerlink" title="6.第二步正向矩阵标准化"></a>6.第二步正向矩阵标准化</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1692505236278.png" alt="1692505236278"></p><h2 id="7-第三步计算得分并归一化"><a href="#7-第三步计算得分并归一化" class="headerlink" title="7.第三步计算得分并归一化"></a>7.第三步计算得分并归一化</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1692505293516.png" alt="1692505293516"></p><h2 id="8-代码"><a href="#8-代码" class="headerlink" title="8.代码"></a>8.代码</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1692505603544.png" alt="1692505603544"></p><h1 id="22-解决异方差"><a href="#22-解决异方差" class="headerlink" title="22.解决异方差"></a>22.解决异方差</h1><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693020583921.png" alt="1693020583921"></p><h2 id="检验异方差"><a href="#检验异方差" class="headerlink" title="检验异方差"></a>检验异方差</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693020655963.png" alt="1693020655963"></p><h2 id="拟合值出现负数的原因"><a href="#拟合值出现负数的原因" class="headerlink" title="拟合值出现负数的原因"></a>拟合值出现负数的原因</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693021201736.png" alt="1693021201736"></p><h2 id="异方差假设检验"><a href="#异方差假设检验" class="headerlink" title="异方差假设检验"></a>异方差假设检验</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693021283351.png" alt="1693021283351"></p><p>BP检验与怀特检验的区别</p><p>更推荐怀特检验</p><h2 id="怀特检验"><a href="#怀特检验" class="headerlink" title="怀特检验"></a>怀特检验</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693021350588.png" alt="1693021350588"></p><h2 id="异方差处理方法"><a href="#异方差处理方法" class="headerlink" title="异方差处理方法"></a>异方差处理方法</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693021404090.png" alt="1693021404090"></p><h3 id="1-使用OLS-稳健的标准误（推荐，stata）"><a href="#1-使用OLS-稳健的标准误（推荐，stata）" class="headerlink" title="1.使用OLS+稳健的标准误（推荐，stata）"></a>1.使用OLS+稳健的标准误（推荐，stata）</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693021540821.png" alt="1693021540821"></p><h3 id="2-广义最小二乘法"><a href="#2-广义最小二乘法" class="headerlink" title="2.广义最小二乘法"></a>2.广义最小二乘法</h3><h2 id="多重共线性"><a href="#多重共线性" class="headerlink" title="多重共线性"></a>多重共线性</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693021588743.png" alt="1693021588743"></p><h2 id="检验多重共线性"><a href="#检验多重共线性" class="headerlink" title="检验多重共线性"></a>检验多重共线性</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693021751571.png" alt="1693021751571"></p><h2 id="如何解决多重共线性"><a href="#如何解决多重共线性" class="headerlink" title="如何解决多重共线性"></a>如何解决多重共线性</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693021862001.png" alt="1693021862001"></p><h2 id="逐步回归分析"><a href="#逐步回归分析" class="headerlink" title="逐步回归分析"></a>逐步回归分析</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693021995957.png" alt="1693021995957"></p><h3 id="推荐向后逐步回归"><a href="#推荐向后逐步回归" class="headerlink" title="推荐向后逐步回归"></a>推荐向后逐步回归</h3><h3 id="stata实现逐步回归法"><a href="#stata实现逐步回归法" class="headerlink" title="stata实现逐步回归法"></a>stata实现逐步回归法</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693022052846.png" alt="1693022052846"></p><h2 id="完全多重共线性的错误"><a href="#完全多重共线性的错误" class="headerlink" title="完全多重共线性的错误"></a>完全多重共线性的错误</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693022210304.png" alt="1693022210304"></p><h2 id="逐步回归的说明"><a href="#逐步回归的说明" class="headerlink" title="逐步回归的说明"></a>逐步回归的说明</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693030012683.png" alt="1693030012683"></p><p>推荐向后逐步回归，剔除多重共线性</p><h1 id="23-图论最短路径问题"><a href="#23-图论最短路径问题" class="headerlink" title="23.图论最短路径问题"></a>23.图论最短路径问题</h1><h2 id="1-图的概念"><a href="#1-图的概念" class="headerlink" title="1.图的概念"></a>1.图的概念</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693030276210.png" alt="1693030276210"></p><h2 id="2-在线作图"><a href="#2-在线作图" class="headerlink" title="2.在线作图"></a>2.在线作图</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693030491799.png" alt="1693030491799"></p><h2 id="3-MATLAB作图"><a href="#3-MATLAB作图" class="headerlink" title="3.MATLAB作图"></a>3.MATLAB作图</h2><h3 id="1-无向图无权图"><a href="#1-无向图无权图" class="headerlink" title="1.无向图无权图"></a>1.无向图无权图</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693030539352.png" alt="1693030539352"></p><h3 id="2-无向图有权图"><a href="#2-无向图有权图" class="headerlink" title="2.无向图有权图"></a>2.无向图有权图</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693030886036.png" alt="1693030886036"></p><h3 id="3-有向图无权图"><a href="#3-有向图无权图" class="headerlink" title="3.有向图无权图"></a>3.有向图无权图</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693030950874.png" alt="1693030950874"></p><h3 id="4-有向图有权图"><a href="#4-有向图有权图" class="headerlink" title="4.有向图有权图"></a>4.有向图有权图</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693030967904.png" alt="1693030967904"></p><h3 id="推荐在线作图网站"><a href="#推荐在线作图网站" class="headerlink" title="推荐在线作图网站"></a>推荐在线作图网站</h3><h2 id="4-无向图的权重领接矩阵"><a href="#4-无向图的权重领接矩阵" class="headerlink" title="4.无向图的权重领接矩阵"></a>4.无向图的权重领接矩阵</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693031102204.png" alt="1693031102204"></p><p>inf无穷，无连接</p><h1 id="24-迪杰斯特拉算法（戴克斯特拉算法）"><a href="#24-迪杰斯特拉算法（戴克斯特拉算法）" class="headerlink" title="24.迪杰斯特拉算法（戴克斯特拉算法）"></a>24.迪杰斯特拉算法（戴克斯特拉算法）</h1><p>算法动画图解,APP</p><h3 id="最短路径，"><a href="#最短路径，" class="headerlink" title="最短路径，"></a>最短路径，</h3><p>三个数组，编号，节点距离，父亲（即来自于哪个节点)</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693034895433.png" alt="1693034895433"></p><h1 id="25-贝尔曼-福特算法（贪婪思想）BellmanFord"><a href="#25-贝尔曼-福特算法（贪婪思想）BellmanFord" class="headerlink" title="25.贝尔曼-福特算法（贪婪思想）BellmanFord"></a>25.贝尔曼-福特算法（贪婪思想）BellmanFord</h1><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693035211116.png" alt="1693035211116"></p><h1 id="26-负权回路"><a href="#26-负权回路" class="headerlink" title="26.负权回路"></a>26.负权回路</h1><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693035303760.png" alt="1693035303760"></p><h2 id="maltab计算最短路径"><a href="#maltab计算最短路径" class="headerlink" title="maltab计算最短路径"></a>maltab计算最短路径</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693036172147.png" alt="1693036172147"></p><h3 id="可选算法"><a href="#可选算法" class="headerlink" title="可选算法"></a>可选算法</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693036200821.png" alt="1693036200821"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693036326138.png" alt="1693036326138"></p><p><strong><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693036453319.png" alt="1693036453319"></strong></p><h1 id="27-分类模型"><a href="#27-分类模型" class="headerlink" title="27.分类模型"></a>27.分类模型</h1><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693102973494.png" alt="1693102973494"></p><h2 id="1-SPSS数据预处理"><a href="#1-SPSS数据预处理" class="headerlink" title="1.SPSS数据预处理"></a>1.SPSS数据预处理</h2><h2 id="2-线性概率模型"><a href="#2-线性概率模型" class="headerlink" title="2.线性概率模型"></a>2.线性概率模型</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693103006080.png" alt="1693103006080"></p><h3 id="两点分布（伯努利模型）"><a href="#两点分布（伯努利模型）" class="headerlink" title="两点分布（伯努利模型）"></a>两点分布（伯努利模型）</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693103120902.png" alt="1693103120902"></p><p>求期望</p><h2 id="3-连接函数的取法"><a href="#3-连接函数的取法" class="headerlink" title="3.连接函数的取法"></a>3.连接函数的取法</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693103389005.png" alt="1693103389005"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693103399829.png" alt="1693103399829"></p><h2 id="怎么用于分类"><a href="#怎么用于分类" class="headerlink" title="怎么用于分类"></a>怎么用于分类</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693103533694.png" alt="1693103533694"></p><h2 id="SPSS求解逻辑回归"><a href="#SPSS求解逻辑回归" class="headerlink" title="SPSS求解逻辑回归"></a>SPSS求解逻辑回归</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693103630175.png" alt="1693103630175"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693104114668.png" alt="1693104114668"></p><p>逐步回归的设置</p><h3 id="自变量有分类变量"><a href="#自变量有分类变量" class="headerlink" title="自变量有分类变量"></a>自变量有分类变量</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693104150405.png" alt="1693104150405"></p><h3 id="预测结果很差不理想"><a href="#预测结果很差不理想" class="headerlink" title="预测结果很差不理想"></a>预测结果很差不理想</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693104176814.png" alt="1693104176814"></p><h3 id="过拟合现象"><a href="#过拟合现象" class="headerlink" title="过拟合现象"></a>过拟合现象</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693104344274.png" alt="1693104344274"></p><h3 id="如何确定合适的模型"><a href="#如何确定合适的模型" class="headerlink" title="如何确定合适的模型"></a>如何确定合适的模型</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693104367142.png" alt="1693104367142"></p><h1 id="28-Fish线性判别分析"><a href="#28-Fish线性判别分析" class="headerlink" title="28.Fish线性判别分析"></a>28.Fish线性判别分析</h1><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693104620813.png" alt="1693104620813"></p><h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><p>SPSS需要会运用</p><h1 id="29-聚类模型"><a href="#29-聚类模型" class="headerlink" title="29.聚类模型"></a>29.聚类模型</h1><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693105660433.png" alt="1693105660433"></p><h2 id="1-K-means算法"><a href="#1-K-means算法" class="headerlink" title="1.K-means算法"></a>1.K-means算法</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693105775161.png" alt="1693105775161"></p><p>K-均值聚类可视化: <a href="https://www.naftaliharris.com/blog/visualizing-k-means-clustering/">https://www.naftaliharris.com/blog/visualizing-k-means-clustering/</a></p><p>算法流程图不易查重</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693106151280.png" alt="1693106151280"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h3 id="-1"><a href="#-1" class="headerlink" title></a><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693106247076.png" alt="1693106247076"></h3><h2 id="K-means-算法"><a href="#K-means-算法" class="headerlink" title="K-means++算法"></a>K-means++算法</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693106271392.png" alt="1693106271392"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693106452106.png" alt="1693106452106"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693106930219.png" alt="1693106930219"></p><h1 id="系统聚类"><a href="#系统聚类" class="headerlink" title="系统聚类"></a>系统聚类</h1><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693114864926.png" alt="1693114864926"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693116376152.png" alt="1693116376152"></p><h2 id="系统聚类法的过程"><a href="#系统聚类法的过程" class="headerlink" title="系统聚类法的过程"></a>系统聚类法的过程</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693116506822.png" alt="1693116506822"></p><h2 id="聚类分析需要注意的问题"><a href="#聚类分析需要注意的问题" class="headerlink" title="聚类分析需要注意的问题"></a>聚类分析需要注意的问题</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693116958306.png" alt="1693116958306"></p><h3 id="聚类谱系图"><a href="#聚类谱系图" class="headerlink" title="聚类谱系图"></a>聚类谱系图</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693117347001.png" alt="1693117347001"></p><h2 id="用图形估计聚类的数量"><a href="#用图形估计聚类的数量" class="headerlink" title="用图形估计聚类的数量"></a>用图形估计聚类的数量</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693117413137.png" alt="1693117413137"></p><h2 id="聚合系数折线图的画法"><a href="#聚合系数折线图的画法" class="headerlink" title="聚合系数折线图的画法"></a>聚合系数折线图的画法</h2><h1 id="DBSCAN算法（聚类）"><a href="#DBSCAN算法（聚类）" class="headerlink" title="DBSCAN算法（聚类）"></a>DBSCAN算法（聚类）</h1><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693124925873.png" alt="1693124925873"></p><p><a href="https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/">https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/</a></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693125255119.png" alt="1693125255119"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693125715750.png" alt="1693125715750"></p><h2 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h2><h1 id="30时间序列分析"><a href="#30时间序列分析" class="headerlink" title="30时间序列分析"></a>30时间序列分析</h1><h2 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693126012463.png" alt="1693126012463"></p><h2 id="循环变动"><a href="#循环变动" class="headerlink" title="循环变动"></a>循环变动</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693144636029.png" alt="1693144636029"></p><h2 id="不规则变动"><a href="#不规则变动" class="headerlink" title="不规则变动"></a>不规则变动</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693144681930.png" alt="1693144681930"></p><h2 id="长期变动趋势"><a href="#长期变动趋势" class="headerlink" title="长期变动趋势"></a>长期变动趋势</h2><h2 id="季节变动"><a href="#季节变动" class="headerlink" title="季节变动"></a>季节变动</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693144708410.png" alt="1693144708410"></p><h2 id="时间序列分解"><a href="#时间序列分解" class="headerlink" title="时间序列分解"></a>时间序列分解</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693144726367.png" alt="1693144726367"></p><h2 id="叠加模型和乘积模型"><a href="#叠加模型和乘积模型" class="headerlink" title="叠加模型和乘积模型"></a>叠加模型和乘积模型</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693144757063.png" alt="1693144757063"></p><h2 id="SPSS处理时间序列中的缺失值"><a href="#SPSS处理时间序列中的缺失值" class="headerlink" title="SPSS处理时间序列中的缺失值"></a>SPSS处理时间序列中的缺失值</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693144971007.png" alt="1693144971007"></p><h2 id="替换缺失值的五种方法"><a href="#替换缺失值的五种方法" class="headerlink" title="替换缺失值的五种方法"></a>替换缺失值的五种方法</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693145124169.png" alt="1693145124169"></p><h2 id="时间序列分析"><a href="#时间序列分析" class="headerlink" title="时间序列分析"></a>时间序列分析</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693146079388.png" alt="1693146079388"></p><h1 id="31-SPSS七种指数平滑的介绍方法"><a href="#31-SPSS七种指数平滑的介绍方法" class="headerlink" title="31.SPSS七种指数平滑的介绍方法"></a>31.SPSS七种指数平滑的介绍方法</h1><h2 id="1-Simple模型"><a href="#1-Simple模型" class="headerlink" title="1.Simple模型"></a>1.Simple模型</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693189999990.png" alt="1693189999990"></p><h2 id="2-简单指数平滑法预测"><a href="#2-简单指数平滑法预测" class="headerlink" title="2.简单指数平滑法预测"></a>2.简单指数平滑法预测</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693190327136.png" alt="1693190327136"></p><h2 id="3-线性趋势模型"><a href="#3-线性趋势模型" class="headerlink" title="3.线性趋势模型"></a>3.线性趋势模型</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693190342176.png" alt="1693190342176"></p><h2 id="4-阻尼趋势模型"><a href="#4-阻尼趋势模型" class="headerlink" title="4.阻尼趋势模型"></a>4.阻尼趋势模型</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693190478643.png" alt="1693190478643"></p><h2 id="5-简单季节性"><a href="#5-简单季节性" class="headerlink" title="5.简单季节性"></a>5.简单季节性</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693190697467.png" alt="1693190697467"></p><h2 id="6-一元时间序列分析的模型"><a href="#6-一元时间序列分析的模型" class="headerlink" title="6.一元时间序列分析的模型"></a>6.一元时间序列分析的模型</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693193173027.png" alt="1693193173027"></p><h2 id="7-时间序列的平稳性"><a href="#7-时间序列的平稳性" class="headerlink" title="7.时间序列的平稳性"></a>7.时间序列的平稳性</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693194958468.png" alt="1693194958468"></p><h2 id="8-差分方程"><a href="#8-差分方程" class="headerlink" title="8.差分方程"></a>8.差分方程</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693211593092.png" alt="1693211593092"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693211747360.png" alt="1693211747360"></p><h2 id="9-滞后算子"><a href="#9-滞后算子" class="headerlink" title="9.滞后算子"></a>9.滞后算子</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693212544477.png" alt="1693212544477"></p><h2 id="10-AR-p-模型"><a href="#10-AR-p-模型" class="headerlink" title="10.AR(p)模型"></a>10.AR(p)模型</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693212806752.png" alt="1693212806752"></p><h3 id="平稳的条件"><a href="#平稳的条件" class="headerlink" title="平稳的条件"></a>平稳的条件</h3><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693212977139.png" alt="1693212977139"></p><h2 id="MA-q-模型"><a href="#MA-q-模型" class="headerlink" title="MA(q)模型"></a>MA(q)模型</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693213413859.png" alt="1693213413859"></p><h2 id="MA与AR之间的关系"><a href="#MA与AR之间的关系" class="headerlink" title="MA与AR之间的关系"></a>MA与AR之间的关系</h2><h2 id="-2"><a href="#-2" class="headerlink" title></a><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693213551984.png" alt="1693213551984"></h2><h2 id="ARMA-pq-的平稳性"><a href="#ARMA-pq-的平稳性" class="headerlink" title="ARMA(pq)的平稳性"></a>ARMA(pq)的平稳性</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693214343789.png" alt="1693214343789"></p><h2 id="ACF自相关系数"><a href="#ACF自相关系数" class="headerlink" title="ACF自相关系数"></a>ACF自相关系数</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693214557839.png" alt="1693214557839"></p><h2 id="模型选择：AIC和BIC准则（选小原则）"><a href="#模型选择：AIC和BIC准则（选小原则）" class="headerlink" title="模型选择：AIC和BIC准则（选小原则）"></a>模型选择：AIC和BIC准则（选小原则）</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693215844460.png" alt="1693215844460"></p><h2 id="检验模型是否识别完全"><a href="#检验模型是否识别完全" class="headerlink" title="检验模型是否识别完全"></a>检验模型是否识别完全</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693216439809.png" alt="1693216439809"></p><h2 id="ARIMA-查分自回归移动平均模型"><a href="#ARIMA-查分自回归移动平均模型" class="headerlink" title="ARIMA(查分自回归移动平均模型)"></a>ARIMA(查分自回归移动平均模型)</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693216753685.png" alt="1693216753685"></p><h2 id="SARIMA模型"><a href="#SARIMA模型" class="headerlink" title="SARIMA模型"></a>SARIMA模型</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693216904559.png" alt="1693216904559"></p><h1 id="32-蒙特卡罗模拟"><a href="#32-蒙特卡罗模拟" class="headerlink" title="32.蒙特卡罗模拟"></a>32.蒙特卡罗模拟</h1><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693308040663.png" alt="1693308040663"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693308534855.png" alt="1693308534855"></p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693310302265.png" alt="1693310302265"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693311240744.png" alt="1693311240744"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693312205458.png" alt="1693312205458"></p><h1 id="蒙特卡罗应用"><a href="#蒙特卡罗应用" class="headerlink" title="蒙特卡罗应用"></a>蒙特卡罗应用</h1><h2 id="1-三门问题"><a href="#1-三门问题" class="headerlink" title="1.三门问题"></a>1.三门问题</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693359080905.png" alt="1693359080905"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693359469615.png" alt="1693359469615"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693361436999.png" alt="1693361436999"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693360767117.png" alt="1693360767117"></p><h2 id="2-模拟排队"><a href="#2-模拟排队" class="headerlink" title="2.模拟排队"></a>2.模拟排队</h2><h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><h2 id="1-无数值数据时，进行量化处理运用单因素方差分析"><a href="#1-无数值数据时，进行量化处理运用单因素方差分析" class="headerlink" title="1.无数值数据时，进行量化处理运用单因素方差分析"></a>1.无数值数据时，进行量化处理运用单因素方差分析</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693461577251.png" alt="1693461577251"></p><p>分析关系</p><p>有相关性分析和差异性分析</p><p>相关性有皮尔曼还有斯皮尔曼</p><p>差异性分析：卡方检验</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1693462404323.png" alt="1693462404323"></p><p>spsspro</p>]]></content>
      
      
      <categories>
          
          <category> 数模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实训CTF第三天</title>
      <link href="/2023/07/27/%E5%AE%9E%E8%AE%ADCTF%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
      <url>/2023/07/27/%E5%AE%9E%E8%AE%ADCTF%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实训CTF第二天</title>
      <link href="/2023/07/27/%E5%AE%9E%E8%AE%ADCTF%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
      <url>/2023/07/27/%E5%AE%9E%E8%AE%ADCTF%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="一、密码题型（一些上课讲的，也有没讲到的我在网上找到的，可以看看）"><a href="#一、密码题型（一些上课讲的，也有没讲到的我在网上找到的，可以看看）" class="headerlink" title="一、密码题型（一些上课讲的，也有没讲到的我在网上找到的，可以看看）"></a>一、密码题型（一些上课讲的，也有没讲到的我在网上找到的，可以看看）</h1><p>解密网站<a href="http://tool.bugku.com/">http://tool.bugku.com/</a></p><p><a href="http://www.hiencode.com/%EF%BC%8C%E5%9F%BA%E6%9C%AC%E9%83%BD%E6%9C%89">http://www.hiencode.com/，基本都有</a></p><h2 id="1-摩斯密码"><a href="#1-摩斯密码" class="headerlink" title="1.摩斯密码"></a>1.摩斯密码</h2><p>特征：点和横的组合。</p><p>可用<a href="https://tool.lu/ko_KR/morse/">https://tool.lu/ko_KR/morse/</a></p><h2 id="2-移位密码"><a href="#2-移位密码" class="headerlink" title="2.移位密码"></a>2.移位密码</h2><h3 id="（1）栅栏密码"><a href="#（1）栅栏密码" class="headerlink" title="（1）栅栏密码"></a>（1）栅栏密码</h3><p>e.g. </p><p>一只小羊翻过了2个栅栏</p><p>这个2就是移位数</p><p>特征：大小写和字符，其实就是分组替换加密，<a href="http://tool.bugku.com/jiemi/">http://tool.bugku.com/jiemi/</a></p><p>可依据key的格式进行寻找</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689855535829.png" alt="1689855535829"></p><h3 id><a href="#" class="headerlink" title></a><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689855576830.png" alt="1689855576830"></h3><p>先进行ASCLL解密，得一串字符，依据key格式，即CTF{}，进行列排序</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689855647502.png" alt="1689855647502"></p><h3 id="2-云影密码"><a href="#2-云影密码" class="headerlink" title="(2)云影密码"></a>(2)云影密码<img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689855498137.png" alt="1689855498137"></h3><h2 id="3-ASCLL-Hex编码"><a href="#3-ASCLL-Hex编码" class="headerlink" title="3. ASCLL Hex编码"></a>3. ASCLL Hex编码</h2><p>举例</p><p>原⽂：flag_{swjctfpx123456} </p><p>编码后得到： 66 6c 61 67 5f 7b 73 77 6a 63 74 66 70 78 31 32 33 34 35 36 7d</p><p>特征 两位数字或字母组合</p><h2 id="4-url-encode"><a href="#4-url-encode" class="headerlink" title="4. url encode"></a>4. url encode</h2><p>URL编码原理 url编码⼜叫百分号编码，是统⼀资源定位(URL)编码⽅式。 </p><p>URL地址（常说⽹址）规定了常⽤的数字和字⺟可以直接使⽤，另外⼀批作为特殊⽤户字符也可以直接⽤ </p><p>（&#x2F;,:@等），剩下的其它所有字符必须通过 %xx编码处理。 现在已经成为⼀种规范了，基本所有程序语⾔都有 </p><p>这种编码，如js：有encodeURI、encodeURIComponent，PHP有 urlencode、urldecode等。 </p><p>那么urlencode编码结果是 %20 编码⽅法很简单,在该字节ascii码的的16进制字符前⾯加%。如空格字符, ascii码 </p><p>是32,对应16进制是“20 ”。</p><p><strong>特征：%加数字</strong></p><p>举例</p><p>将下列数据⽤url encode进⾏解码 </p><p>%66%20%6c%20%61%20%67%20%7b%20%68%20%61%20%70%20%70%20%79%20%5f%20%65%20%76%20%65%20%72%20%79 </p><p>%20%6f%20%6e%20%65%20%7d </p><p>解码网站   <a href="https://www.iamwawa.cn/urldecode.html">https://www.iamwawa.cn/urldecode.html</a></p><h2 id="5-敲击码"><a href="#5-敲击码" class="headerlink" title="5.敲击码"></a>5.敲击码</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689854557081.png" alt="1689854557081"></p><p><a href="http://www.hiencode.com/tapcode.html">http://www.hiencode.com/tapcode.html</a></p><h2 id="6-盲文"><a href="#6-盲文" class="headerlink" title="6.盲文"></a>6.盲文</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689854652406.png" alt="1689854652406"></p><h2 id="7-Base家族"><a href="#7-Base家族" class="headerlink" title="7.Base家族"></a>7.Base家族</h2><p>有base16,32,64，其中base64最多</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689854836411.png" alt="1689854836411"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689855049510.png" alt="1689855049510"></p><p>特征：看到密文最后两个字符是相同的，就有可能是Base64编码过的，因为Base64编码结尾通常是 <strong>&#x3D;&#x3D;</strong> 。<br>有可能和其他密码混合使用，进行二次加密&#x2F;编码。<br>Base64 是编码（encode）</p><p>举例</p><p>e.g.</p><p>也是Bugku里的一道题：</p><p>e6Z9i<del>]8R</del>U<del>QHE{RnY{QXg</del>QnQ{^XVlRXlp^XI5Q6Q6SKY8jUAA</p><p>结尾是 AA，有点像Base64编码，但是被加密过了，这么蠢的加密方式又有点像凯撒，看ASC II 码，发现 &#x3D; 是 61， A是 65，往后延了4位，那么我们把密文所有数据的ASC II 码 减4，得到Base64的代码，再解码即得到明文flag: key{68743000650173230e4a58ee153c68e8}</p><p>复合题就需要多种解码工具，要看特征选择正确的解码工具</p><h2 id="8-曲路密码"><a href="#8-曲路密码" class="headerlink" title="8.曲路密码"></a>8.曲路密码</h2><p>曲路密码(Curve Cipher)是⼀种换位密码，需要事先双⽅约定密钥(也就是曲路路径)。 </p><p>例如，明⽂为abcdefghijklmnopqrstuvwxy，填⼊5⾏5列表(事先约定填充的⾏列数) </p><p>加密的回路线(事先约定填充的⾏列数)。</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689855414612.png" alt="1689855414612"></p><p>照图划线</p><h2 id="9-凯撒密码"><a href="#9-凯撒密码" class="headerlink" title="9.凯撒密码"></a>9.凯撒密码</h2><p>凯撒密码通过将字⺟移动⼀定的位数来实现加密和解密。明⽂中的所有字⺟都在字⺟表上向后 (或向前)按照⼀个 </p><p>固定的数⽬进⾏偏移后被替换成密⽂。例如，当偏移量是3的时候，所有的字⺟A都将被替换成D，B变成E，依此 </p><p>类推， X将变成A，Y变成B，Z变成C。在偏移量为4的时候，字⺟的替代结果如下所示</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689855710554.png" alt="1689855710554"></p><h2 id="10-ROT密码（回转密码）"><a href="#10-ROT密码（回转密码）" class="headerlink" title="10.ROT密码（回转密码）"></a>10.ROT密码（回转密码）</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689855744111.png" alt="1689855744111"></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689855985945.png" alt="1689855985945"></p><h2 id="11-猪圈密码"><a href="#11-猪圈密码" class="headerlink" title="11.猪圈密码"></a>11.猪圈密码</h2><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689855818321.png" alt="1689855818321"></p><p><a href="http://www.simonsingh.net/The_Black_Chamber/pigpen.html%EF%BC%8C%E4%B8%8A%E8%AF%BE%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%91%E4%BA%86%E4%B8%80%E4%B8%AAflag.txt,%E9%9C%80%E8%A6%81%E5%8A%A0base64%E5%A4%B4%EF%BC%8Cdata:image/png;base64,base64%E7%BC%96%E7%A0%81%E8%BD%AC%E5%9B%BE%E7%89%87%EF%BC%8C%E5%BE%97%E5%88%B0%E5%8F%AF%E4%BB%A5%E5%AF%B9%E7%85%A7%E5%9B%BE%E7%89%87%E8%A7%A3%E5%AF%86%E7%9A%84%E7%8C%AA%E5%9C%88%E5%AF%86%E7%A0%81">http://www.simonsingh.net/The_Black_Chamber/pigpen.html，上课的代码，发了一个flag.txt,需要加base64头，data:image/png;base64,base64编码转图片，得到可以对照图片解密的猪圈密码</a></p><h2 id="12-组合密码（复合密码"><a href="#12-组合密码（复合密码" class="headerlink" title="12.组合密码（复合密码)"></a>12.组合密码（复合密码)</h2><p>bugku,<img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689856194868.png" alt="1689856194868"></p><p>要根据题目的提醒，发现加密类型，这个需要用到 aWxvdmVjdGY8月前</p><p>1、盲文解密 <a href="https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen">https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen</a> 2、rabbit解密 <a href="https://www.sojson.com/encrypt_rabbit.html">https://www.sojson.com/encrypt_rabbit.html</a> 3、音乐解密 <a href="https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=yinyue">https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=yinyue</a> 4、得到答案</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689856244597.png" alt="1689856244597"></p><p>需要用到易经64卦，在进行python脚本</p>]]></content>
      
      
      <categories>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实训CTF第一天</title>
      <link href="/2023/07/27/%E5%AE%9E%E8%AE%ADCTF%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2023/07/27/%E5%AE%9E%E8%AE%ADCTF%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-robots协议"><a href="#1-robots协议" class="headerlink" title="1.  robots协议"></a>1.  robots协议</h2><p>题目描述:<br>X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。</p><p>题目场景:<br><a href="http://61.147.171.105:58740/">http://61.147.171.105:58740</a></p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689766937638.png" alt="1689766937638"></p><p>只需在<a href="http://61.147.171.105:58740加上/robots.txt，出现f1ag_1s_h3re.php，所以打开(http://61.147.171.105:58740/f1ag_1s_h3re.php)即可找到flag">http://61.147.171.105:58740加上/robots.txt，出现f1ag_1s_h3re.php，所以打开(http://61.147.171.105:58740/f1ag_1s_h3re.php)即可找到flag</a></p><h2 id="2-disabled-button"><a href="#2-disabled-button" class="headerlink" title="2.  disabled_button"></a>2.  disabled_button</h2><p>disabled_button:<a href="http://61.147.171.105:57160/%EF%BC%8C%E6%8C%89%E9%92%AE%E4%B8%8D%E8%83%BD%E6%8C%89%EF%BC%8C%E8%AF%B4%E6%98%8E%E5%9C%A8%E5%86%99%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E5%80%99%E9%99%90%E5%88%B6%E4%BA%86%E8%BF%99%E4%B8%AA%E5%8A%9F%E8%83%BD%EF%BC%8CF12%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%EF%BC%8C%E5%8F%91%E7%8E%B0disable%EF%BC%8C%E5%B0%86%E5%85%B6%E4%BF%AE%E6%94%B9%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0flag">http://61.147.171.105:57160/，按钮不能按，说明在写页面的时候限制了这个功能，F12查看页面元素，发现disable，将其修改即可看到flag</a></p><h2 id="3-view-source"><a href="#3-view-source" class="headerlink" title="3. view_source:"></a>3. view_source:</h2><p>view_source:<a href="http://61.147.171.105:60874/,%E6%98%AF%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2%E4%BB%A3%E7%A0%81%EF%BC%8Cf12%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0">http://61.147.171.105:60874/,是一道简单查看页面代码，f12即可看到</a></p><h2 id="4-计算器"><a href="#4-计算器" class="headerlink" title="4.计算器"></a>4.计算器</h2><p>计算器：<a href="http://114.67.175.224:13512/%EF%BC%8C%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E9%A2%98%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AA%E8%83%BD%E8%BE%93%E5%85%A51%E4%BD%8D%E6%95%B0%E5%AD%97%EF%BC%8C%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2%E4%BB%A3%E7%A0%81%E5%8F%91%E7%8E%B0%E8%BE%93%E5%85%A5%E9%95%BF%E5%BA%A6%E5%8F%97%E5%88%B0%E9%99%90%E5%88%B6%EF%BC%8C%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%A1%AB%E5%85%A5%E6%AD%A3%E7%A1%AE%E7%AD%94%E6%A1%88%E5%8D%B3%E5%8F%AF%E8%8E%B7%E5%8F%96flag">http://114.67.175.224:13512/，简单计算题，但是只能输入1位数字，查看页面代码发现输入长度受到限制，进行修改，填入正确答案即可获取flag</a></p><h2 id="5-请求方式"><a href="#5-请求方式" class="headerlink" title="5.请求方式"></a>5.请求方式</h2><p>直接根据提示，抓包完发送到repeater中把get修改为CTFHUB进行发送</p><h2 id="6-你必须让他停下"><a href="#6-你必须让他停下" class="headerlink" title="6.你必须让他停下"></a>6.你必须让他停下</h2><p>第一种方法关闭页面js，使其停止刷新，然后f12不断刷新，就会出现flag，第二钟，直接进行抓包，运气好刚好抓到出现flag的时候，不好就需要多次抓包，第三钟f12，在源代码一栏找到暂停脚本执行，即可</p><h2 id="7-get-post"><a href="#7-get-post" class="headerlink" title="7.get_post:"></a>7.get_post:</h2><p>get_post:<a href="http://61.147.171.105:60477/">http://61.147.171.105:60477/</a></p><p>get方式，可以直接在url后面加?a&#x3D;1，此时又出现提示，用post方式，采用burpsuite抓包，，发送到repeater里，把get修改为post，可以改成a&#x3D;1&amp;b&#x3D;2,或者在后面加b&#x3D;2，此时改用post需要加入</p><p>（在中间行） Content-Type: application&#x2F;x-www-form-urlencoded，发送即可</p><h2 id="8-xff-referer"><a href="#8-xff-referer" class="headerlink" title="8.xff_referer"></a>8.xff_referer</h2><p>xff_referer:<a href="http://61.147.171.105:53014/%EF%BC%8C%E6%9B%B4%E6%94%B9ip%E9%9C%80%E8%A6%81X-Forwarded-For">http://61.147.171.105:53014/，更改ip需要X-Forwarded-For</a>: 加对应IP地址，后出现提示，需要使用谷歌浏览器打开，采用referer：<a href="http://www.google.com,发送即可获得flag/">www.google.com，发送即可获得flag</a></p><h2 id="9-爆破"><a href="#9-爆破" class="headerlink" title="9.爆破"></a>9.爆破</h2><p>采用burpsuite的intruder模块，选用狙击手模式，选中需要爆破对象进行add，在payloads里把密码库导入进行爆破即可</p><h2 id="10-phpinfo"><a href="#10-phpinfo" class="headerlink" title="10.phpinfo"></a>10.phpinfo</h2><p>在网站URL后面加这将显示出当前PHP服务器的详细信息，包括PHP版本、已加载的模块、配置选项等。</p><p>即可找到flag</p><h2 id="11-文件上传：无障碍–蚁剑"><a href="#11-文件上传：无障碍–蚁剑" class="headerlink" title="11.文件上传：无障碍–蚁剑"></a>11.文件上传：无障碍–蚁剑</h2><p>需要编写一句话木马，进行绕过，老师已给出<?phpeval($_POST['sec_test']);?>，其中sec_test就是连接密码，需要把文件后缀改为.php进行文件上传，得到文件相对路径，在蚁剑右键添加数据</p><p><img src="/.com//Users\Nice\AppData\Roaming\Typora\typora-user-images\1689772115918.png" alt="1689772115918"></p><p>URL地址就是网站地址加相对路径，密码就是一句话木马里注入的sec_test，点击连接连接成功，进入里面即可发现flag文件</p>]]></content>
      
      
      <categories>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2023/07/05/HTML/"/>
      <url>/2023/07/05/HTML/</url>
      
        <content type="html"><![CDATA[<h3 id="HTML的语言特征"><a href="#HTML的语言特征" class="headerlink" title="HTML的语言特征"></a><strong>HTML的语言特征</strong></h3><p>l HTML代码是由头和体组成。</p><html><p>​<head></head></p><p>​<title> 标题</title></p><p>​<body>需要展示给用户看的信息内容</body></p></html> <html>标签就相当于 java类 大括号<head>中存放的都是网页的说明性内容，例如标题</head><ul><li><p>HTML文件的扩展名为html或者htm。Htm是老的命名规范，html的新的</p></li><li><p>HTML文件由浏览器直接解析执行，无需编译，直接由上到下依次解析执行。</p></li><li><p>HTML标签通常由开始标签和结束标签组成。例如:<font>内容体</font>开始标签和结束标签之间的内容叫做内容体</p></li><li><p>HTML没有内容体的标签叫做空标签。仅由一个标签组成。例如：<br>  自关闭</p></li><li><p>HTML标签不区分大小写，为了方便阅读，建议使用小写。</p></li><li><p>HTML标签是有属性的，格式为：属性名&#x3D;”属性值”，属性值用引号引起。引号包含单引号和双引号</p></li></ul><p>HTML标签建议包裹嵌套，不建议交叉嵌套</p><pre><code>&lt;head&gt; &lt;title&gt;html 快速入门&lt;/title&gt; &lt;body&gt;     &lt;font color=&quot;red&quot;&gt;&lt;/font&gt; &lt;/body&gt;</code></pre> #### **<font>**<p>字体标签，用于展示效果中修饰文字样式</p><p>&lt;font 属性名&#x3D;”属性值”&gt;文字</p></font><p></p><p>Ø size:控制字体大小.最小1 ~ 最大7。 如果设置范围不在1~7之间，设置无效</p><p>Ø color：控制字体颜色. 使用英文设置（例如：red,blue…） </p><p>Ø face：控制字体类型。只能设置系统字库中存在的字体类型</p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps1.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps2.jpg" alt="img"> </p><h4 id="2-1-2、"><a href="#2-1-2、" class="headerlink" title="2.1.2、"></a><strong>2.1.2、<br></strong></h4><p>HTML源码中换行，浏览器解析时会自动忽略。</p><p>换行标签，用于展示效果中换行</p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps3.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps4.jpg" alt="img"> </p><h4 id="2-1-3、"><a href="#2-1-3、" class="headerlink" title="2.1.3、"></a><strong>2.1.3、<p></p></strong></h4><p>段落标签，用于展示效果中划分段落。并且自动在段前和段后自动加空白行</p><p>Ø align:段落内容的对齐方式</p><p>默认是left， 内容居左</p><p>Right  右</p><p>Center 居中</p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps5.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps6.jpg" alt="img"> </p><h4 id="2-1-4、"><a href="#2-1-4、" class="headerlink" title="2.1.4、"></a><strong>2.1.4、<h1></h1></strong></h4><p>标题标签，用于展示效果中划分标题</p><p>其中</p><h1>最大，<h6>最小<p></p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps7.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps8.jpg" alt="img"> </p><h4 id="2-1-5、"><a href="#2-1-5、" class="headerlink" title="2.1.5、"></a><strong>2.1.5、</strong></h4><p>HTML源码中的多个空格，效果中最终会合并成一个。</p><p>空格符号，用于展示效果中显示一个空白的位置</p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps9.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps10.jpg" alt="img"> </p><h4 id="2-1-6、HTML注释"><a href="#2-1-6、HTML注释" class="headerlink" title="2.1.6、HTML注释"></a><strong>2.1.6、HTML注释</strong></h4><p>用于注释HTML源码，不在HTML效果中展示。 </p><p>只能在源码中看到，页面展示效果中是没有</p><p>格式：<!--HTML注释内容 --></p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps11.jpg" alt="img"> </p><p>效果：在HTML效果展示中不会显示，只能在源码中看到</p><h3 id="2-2、图片标签"><a href="#2-2、图片标签" class="headerlink" title="2.2、图片标签"></a><strong>2.2、</strong><strong>图片标签</strong></h3><h4 id="2-2-1、"><a href="#2-2-1、" class="headerlink" title="2.2.1、"></a><strong>2.2.1、<img></strong></h4><p>用于在页面效果中展示一张图片。</p><p>Ø src：指明图片的路径。（必有属性）</p><p>图片路径的写法：</p><p>​①内网路径：</p><p>​绝对路径：文件在硬盘上的具体位置。【不建议使用】</p><p>​例如：C:\ JavaWeb001_html\img\c_1.jpg</p><p>​相对路径：从引入者所在目录出发。【建议使用相对路径】</p><p>​例如：..&#x2F;img&#x2F;c_1.jpg</p><p>​..&#x2F;表示上一层目录</p><p>​.&#x2F;表示当前目录</p><p>​<img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps12.jpg" alt="img"></p><p>​②互联网路径：</p><p>​必须前面加上http:&#x2F;&#x2F;</p><p>​例如：<a href="http://www.baidu.com/xxx.jpg">http://www.baidu.com/xxx.jpg</a></p><p>Ø width：图片宽度</p><p>Ø height：图片的高度</p><p>宽度和高度的设置：</p><p>默认单位是px，像素。例如：width&#x3D;”400”   其实设置的是 width&#x3D;”400px”。固定设置方式</p><p>百分比设置。例如：width&#x3D;”50%”。  是父标签的百分比。 动态改变的。</p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps13.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps14.jpg" alt="img"> </p><h3 id="2-3、列表标签"><a href="#2-3、列表标签" class="headerlink" title="2.3、列表标签"></a><strong>2.3、</strong><strong>列表标签</strong></h3><h4 id="2-3-1、"><a href="#2-3-1、" class="headerlink" title="2.3.1、"></a><strong>2.3.1、<ul></ul></strong></h4><p>无序列表标签，用于在效果中定义一个无序列表</p><h4 id="2-3-2、"><a href="#2-3-2、" class="headerlink" title="2.3.2、"></a><strong>2.3.2、<li></li></strong></h4><p>列表条目项标签，用于在效果中定义一个列表的条目</p><h4 id="2-3-3、"><a href="#2-3-3、" class="headerlink" title="2.3.3、"></a><strong>2.3.3、<ol></ol></strong></h4><p>有序列表标签，用于在效果中定义一个有序列表</p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps15.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps16.jpg" alt="img"> </p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps17.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps18.jpg" alt="img"> </p><h3 id="2-4、超链接标签"><a href="#2-4、超链接标签" class="headerlink" title="2.4、超链接标签"></a><strong>2.4、</strong><strong>超链接标签</strong></h3><h4 id="2-4-1、"><a href="#2-4-1、" class="headerlink" title="2.4.1、"></a><strong>2.4.1、<a></a></strong></h4><p>超链接标签，用于在效果中定义一个可以点击跳转的链接</p><p>Ø href：超链接跳转的路径 (必有属性)</p><p>内网本机路径：相对路径和绝对路径</p><p>互联网路径：http:&#x2F;&#x2F;地址</p><p>本页：默认跳转到本页</p><p>超链接正常工作：①a标签中必须有内容</p><p>​②a标签必须有href属性</p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps19.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps20.jpg" alt="img"> </p><p>注意：</p><p>​①a标签内容体，不仅仅是文字，也可以是其他内容，例如图片</p><p>​②a标签的href属性，不仅仅可以链接到html上，也可以链接到其他文件上，例如图片</p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps21.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps22.jpg" alt="img"> </p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps23.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps24.jpg" alt="img"> </p><h3 id="2-5、表格标签"><a href="#2-5、表格标签" class="headerlink" title="2.5、表格标签"></a><strong>2.5、</strong><strong>表格标签</strong></h3><h4 id="2-5-1、"><a href="#2-5-1、" class="headerlink" title="2.5.1、"></a><strong>2.5.1、<table></table></strong></h4><p>表格标签，用于在效果中定义一个表格</p><p>Ø border：设置表格的边框粗细</p><p>Ø width：设置表格的宽度</p><h4 id="2-5-2-、"><a href="#2-5-2-、" class="headerlink" title="2.5.2 、"></a><strong>2.5.2 、<tr></tr></strong></h4><p>表格的行标签，用于在效果中定义一个表格行</p><h4 id="2-5-3、"><a href="#2-5-3、" class="headerlink" title="2.5.3、"></a><strong>2.5.3、<td></td></strong></h4><p>表格的单元格标签，用于在效果中定义一个表格行中的单元格</p><p>表格的书写顺序：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps25.jpg" alt="img"> </p><p>步骤1：定义一个表格 <table></table></p><p>步骤2：定义表格中的一行  <tr></tr></p><p>步骤3：在表格一行中定义单元格 <td></td>   内容就可以写在单元格中</p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps26.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps27.jpg" alt="img"> </p><h4 id="2-5-4、"><a href="#2-5-4、" class="headerlink" title="2.5.4、"></a><strong>2.5.4、<th></th></strong></h4><p>表格的表头单元格标签，用于在效果中定义一个表格行中的表头单元格</p><th>和</th><td>唯一区别：<th>内容 居中加粗   <p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps28.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps29.jpg" alt="img"> </p><h4 id="2-5-5、单元格合并"><a href="#2-5-5、单元格合并" class="headerlink" title="2.5.5、单元格合并"></a><strong>2.5.5、单元格合并</strong></h4></th></td><td>或者<th>都有两个单元格合并属性： <p>Ø colspan：跨列合并单元格</p><p>Ø rowspan：跨行合并单元格</p><p>合并步骤：</p><p>① 确定合并哪几个单元格，确定是跨列合并还是跨行合并</p><p>② 在第一个出现的单元格上书写 合并单元格属性</p><p>③ 合并几个单元格，属性值就书写几</p><p>④ 被合并的单元格必须删掉</p><p>示例1：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps30.jpg" alt="img"> </p><p>效果1：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps31.jpg" alt="img"> </p><p>示例2：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps32.jpg" alt="img"> </p><p>效果2：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps33.jpg" alt="img"> </p><p>示例3：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps34.jpg" alt="img"> </p><p>效果3：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps35.jpg" alt="img"> </p><h3 id="2-6、块标签"><a href="#2-6、块标签" class="headerlink" title="2.6、块标签"></a><strong>2.6、块标签</strong></h3><h4 id="2-6-1、"><a href="#2-6-1、" class="headerlink" title="2.6.1、"></a><strong>2.6.1、<span></span></strong></h4><p>行级的块标签，用于在效果中 一行上定义一个块，进行内容显示。</p><p>① span有多少内容，就会占用多大空间。</p><p>②Span不会自动换行</p><p>适用于少量数据展示</p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps36.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps37.jpg" alt="img"> </p><h4 id="2-6-2、"><a href="#2-6-2、" class="headerlink" title="2.6.2、"></a><strong>2.6.2、<div></div></strong></h4><p>块级的块标签，用于在效果中 定义一块，默认占满一行，进行内容的显示</p><p>① 默认占满一行</p><p>② 会自动换行</p><p>适用于大量数据展示</p><p>示例：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps38.jpg" alt="img"> </p><p>效果：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps39.jpg" alt="img"> </p><h4 id="2-6-3、Div和span的应用场景："><a href="#2-6-3、Div和span的应用场景：" class="headerlink" title="2.6.3、Div和span的应用场景："></a><strong>2</strong><strong>.6.3、<strong><strong>Div和</strong></strong>span的应用场景：</strong></h4><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps40.jpg" alt="img"> </p><h2 id="3、HTML的表单标签"><a href="#3、HTML的表单标签" class="headerlink" title="3、HTML的表单标签"></a><strong>3、HTML的表单标签</strong></h2><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps41.jpg" alt="img"> </p><h3 id="3-1、输入项标签"><a href="#3-1、输入项标签" class="headerlink" title="3.1、输入项标签"></a><strong>3.1、输入项标签</strong></h3><p><input>标签</p><p>表单输入项标签之一，用户可以在该标签上 通过填写和选择 进行数据的输入。</p><p>Ø type:设置该标签的种类</p><p>ü text:文本框。 默认</p><p>ü password:密码框。  内容为非明文</p><p>ü radio:单选框。   在同一组内有单选效果</p><p>ü checkbox:复选框。  在同一组内有复选效果</p><p>ü submit:提交按钮。用于控制表单提交数据</p><p>ü reset:重置按钮。 用于将表单输入项恢复到默认状态</p><p>ü file:附件框。用于文件上传。</p><p>ü hidden:隐藏域。一般用作提交服务器需要拿到，但用户不需要看到的数据。</p><p>ü button:普通按钮。需要和JS事件一起用</p><p>Ø name: 单选框、复选框进行数据的分组。&#x2F;    设置该标签对应的参数名</p><p>某个表单输入项需要通过参数列表提交，就必须设置name属性</p><p>Ø value:设置该标签对应的参数值。   &#x2F;   作为按钮的名字</p><p>value属性的设置策略：</p><p>​①文本框、密码框这样的表单输入项，可以不强制指定value，因为用户可以自由输入</p><p>​②单选框、复选框这样的表单输入项，必须强制指定value，因为用户无法输入，只能选择，如果不指定value，那么提交上去的只有on</p><p>Ø checked:设置单选框&#x2F;复选框的默认选中状态</p><p>Ø readonly:设置该标签的参数值只读，用户无法手动更改。数据是可以正常提交</p><p>Ø disabled:设置该标签不可用，参数值无法更改，且参数值也无法提交</p><p>参数列表的格式：</p><p>参数名1&#x3D;参数值1&amp;参数名2&#x3D;参数值2&amp;参数名3&#x3D;参数值3…….</p><p>例如：username&#x3D;zhangsan&amp;password&#x3D;123&amp;sex&#x3D;man</p><p>示例1：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps42.jpg" alt="img"> </p><p>效果1：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps43.jpg" alt="img"> </p><p>示例2：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps44.jpg" alt="img"> </p><p>效果2：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps45.jpg" alt="img"> </p><p>示例3：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps46.jpg" alt="img"> </p><p>效果3：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps47.jpg" alt="img"> </p><h3 id="3-2、选择框标签"><a href="#3-2、选择框标签" class="headerlink" title="3.2、选择框标签"></a><strong>3.2、选择框标签</strong></h3><p><select></select>标签  定义一个选择框</p><p>Ø name: 设置该标签对应的参数名</p><p>Ø multiple：设置该标签选项全部显示，并且可以进行多选提交。默认为单选。</p><option></option>标签<p>选项标签，用于为一个选择框添加一个选项</p><p>Ø value:设置需要提交的参数值。</p><p>Ø selected:设置选项的默认选中状态</p><p>注意事项：</p><p>​Option的内容体一般是用来进行展示</p><p>​参数值 应该是option的value属性值</p><p>示例1：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps48.jpg" alt="img"> </p><p>效果1：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps49.jpg" alt="img"> </p><p>示例2：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps50.jpg" alt="img"> </p><p>效果2：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps51.jpg" alt="img"> </p><p>示例3：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps52.jpg" alt="img"> </p><p>效果3：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps53.jpg" alt="img"> </p><h3 id="3-3、文本域标签"><a href="#3-3、文本域标签" class="headerlink" title="3.3、文本域标签"></a><strong>3.3、文本域标签</strong></h3><textarea></textarea>标签<p>表单输入项标签之一，用户可以在该标签上 通过输入 进行数据的输入。</p><p>Ø name: 设置该标签对应的参数名</p><p>文本域和文本框区别：</p><p>① 文本框不能换行，文本域可以</p><p>② 文本框参数值是value属性，文本域参数值是标签的内容体</p><p>示例1：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps54.jpg" alt="img"> </p><p>效果1：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps55.jpg" alt="img"> </p><p>示例2：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps56.jpg" alt="img"> </p><p>效果2：</p><p><img src="file:///C:\Users\Nice\AppData\Local\Temp\ksohtml27660\wps57.jpg" alt="img"> </p><h3 id="3-4、表单标签"><a href="#3-4、表单标签" class="headerlink" title="3.4、表单标签"></a><strong>3.4、表单标签</strong></h3><form></form>标签。<p>用于在效果中定义一个表单，用于提交用户填写的数据。</p><p>Ø action:将数据提交到何处。</p><p>默认提交到本页。</p><p>本机内网路径：</p><p>​相对路径：</p><p>​绝对路径：</p><p>互联网路径：</p><p>​<a href="http://www.baidu.com/xxx">http://www.baidu.com/xxx</a></p><p>Ø method:将数据以何种方式提交</p><p>默认为：get</p><p>提交方式可定义：get     或者     post</p><p>Get提交方式特点：把数据拼接到地址栏上</p><p>Post提交方式特点：没有把提交数据拼接到地址栏上。请求体</p><p>Get和post提交方式区别：</p><p>① get提交的参数列表拼接到了地址栏后面</p><p>post方式不会 拼接地址栏</p><p>​②get方式提交的数据 敏感信息不安全</p><p>​Post方式提交的数据  相对安全</p><p>​③get方式提交的数据量 有限的</p><p>​   Post方式从理论上提交的数据量 无限大</p><p>尽量使用post方式提交表单</p><h3 id="3-5、提交表单注意事项"><a href="#3-5、提交表单注意事项" class="headerlink" title="3.5、提交表单注意事项"></a><strong>3.5、提交表单注意事项</strong></h3><h4 id="3-5-1、提交中文问题"><a href="#3-5-1、提交中文问题" class="headerlink" title="3.5.1、提交中文问题"></a><strong>3.5.1、提交中文问题</strong></h4><h5 id="3-5-1-1、为什么要使用URL编码？"><a href="#3-5-1-1、为什么要使用URL编码？" class="headerlink" title="3.5.1.1、为什么要使用URL编码？"></a><strong>3.5.1.1、为什么要使用URL编码？</strong></h5><p>正常提交数据：</p><p>?password&#x3D;123&amp;username&#x3D;zhangsan</p><p>非正常提交数据：</p><p>?password&#x3D;123#ohheih&amp;dlajfk&amp;dskfklas&amp;username&#x3D;zhangsan</p><p>URL编码解决方式：特殊符号，中文</p><p>例如：&amp;   -à %26</p><p>?password&#x3D;123#ohheih&amp;dlajfk&amp;dskfklas&amp;username&#x3D;zhangsan</p><p>编码完：?password&#x3D;123#ohheih %26dlajfk %26dskfklas&amp;username&#x3D;zhangsan</p><p>为了保证表单数据传递时能更好区分出name和value。</p><p>保证数据传递的完整性</p><h5 id="3-5-1-2、URL编码的表现形式-amp-本质"><a href="#3-5-1-2、URL编码的表现形式-amp-本质" class="headerlink" title="3.5.1.2、URL编码的表现形式&amp;本质"></a><strong>3.5.1.2、URL编码的表现形式&amp;本质</strong></h5><p>①你好，进行普通的编码，编码成字节数组。【使用的是页面规定的字符集，例如utf-8】</p><p>② 字节数组中的每一个元素，都会从10进制，转为16进制</p><p>③ 把已经转为16进制的字节数组，以%进行拼接 。拼接出的字符串，就是URL编码后的结果</p><p>例如：你好，用UTF-8编码，编码的字节数组为：</p><p>[-28, -67, -96, -27, -91, -67]</p><p>URL编码后：</p><p>%E4%BD%A0%E5%A5%BD</p><p>html   表示颜色</p></th></td></h6></h1></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>6.1快乐</title>
      <link href="/2023/06/01/6-1%E5%BF%AB%E4%B9%90/"/>
      <url>/2023/06/01/6-1%E5%BF%AB%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<p>6.1六一儿童节，今天是快乐的一天</p><div class="gallery">    <div class="fj-gallery  data" data-rowheight="220" data-limit="10">    <span class="gallery-data">[{"url":"D:\\QQ\\Image\\MobileFile\\IMG20230601213237.jpg","alt":""}]</span>    </div>    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>    </div>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>math(1)</title>
      <link href="/2023/05/30/math-1/"/>
      <url>/2023/05/30/math-1/</url>
      
        <content type="html"><![CDATA[<p>行列式公式总结</p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行列式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络爬虫</title>
      <link href="/2023/05/27/title/"/>
      <url>/2023/05/27/title/</url>
      
        <content type="html"><![CDATA[<ul><li>爬虫基本原理</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">requet = urllib.request.Request(<span class="string">&#x27;https://python.org&#x27;</span>)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"><span class="built_in">print</span>(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> url </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My New Post</title>
      <link href="/2023/05/25/My-New-Post/"/>
      <url>/2023/05/25/My-New-Post/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/25/hello-world/"/>
      <url>/2023/05/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
